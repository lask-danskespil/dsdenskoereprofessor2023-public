declare module "@gdk/core" {
	export * from "@gdk/core/core/index";
	export * from "@gdk/core/logger/index";
	export * from "@gdk/core/sound/index";
	export * from "@gdk/core/tools/index";
	export * from "@gdk/core/tracking/index";
	export * from "@gdk/core/decorators/index";
	export const VERSION: string;
}

declare module "@gdk/core/core/index" {
	export { GameCore } from "@gdk/core/core/gameCore";
	export { State, IState, EStateEvents } from "@gdk/core/core/state";
	export { IView } from "@gdk/core/core/view";
	export { EOrientation } from "@gdk/core/core/orientation";
	export { Settings } from "@gdk/core/core/settings";
	export { Loader, ILoader } from "@gdk/core/core/loader/loader";
	export { DefaultLoader } from "@gdk/core/core/loader/default";
	export * from "@gdk/core/core/loader/gameConfigurationTypes";
}

declare module "@gdk/core/core/gameCore" {
	import { Settings } from "@gdk/core/core/settings";
	import { Loader } from "@gdk/core/core/loader/loader";
	import type { State } from "@gdk/core/core/state";
	import type { IGameConf } from "@gdk/core/core/loader/gameConfigurationTypes";
	export class GameCore {
	    state: State;
	    canvas: HTMLCanvasElement;
	    gameDiv: HTMLElement;
	    window: Window;
	    settings: Settings;
	    loader: Loader;
	    gameConfig: IGameConf;
	    metadata: any;
	    onBlur: () => void;
	    onFocus: () => void;
	    /**
	     * Constructor
	     * @param window specifies the window to work on
	     * @param canvas specifies the canvas to work on
	     * @param createGameDiv if a game div should be created to put canvas in it
	     */
	    constructor(window?: Window, canvas?: HTMLCanvasElement, createGameDiv?: boolean);
	    /**
	     * Starts the game.
	     * @param view Specifies the first view to make appear.
	     * @returns A promise resolved when the game is loaded and started or void for backward compatibility.
	     */
	    start(view?: string): Promise<void> | void;
	    /**
	     * Requests fullscreen on browser
	     * @return true if fullscreen is possible, false if not available (i.e iPhones)
	     */
	    requestFullscreen(): boolean;
	    /**
	     * Returns the resource identified by the given key
	     * @param key the key of the value to get
	     */
	    resource<T>(key: string): T;
	    /**
	     * Displays information about a game: its version, gdk modules versions
	     */
	    infos(): Promise<void>;
	    /**
	     * Return the game's infos. Should be overidden to add
	     * more informations to log
	     */
	    protected getInfos(): Promise<any>;
	    /**
	     * Create container div for the game
	     * Called by gameCore constructor
	     * Can be overrided
	     */
	    protected createGameDiv(): void;
	    private _blur;
	    private _focus;
	    private _getVersion;
	    private _getModulesVersions;
	    private _getGameVersion;
	}
}

declare module "@gdk/core/core/settings" {
	import { EOrientation } from "@gdk/core/core/orientation";
	export interface IVersions {
	    theme?: string;
	    i18n?: string;
	}
	export class Settings {
	    orientation: EOrientation;
	    language: string;
	    versions: IVersions;
	}
}

declare module "@gdk/core/core/orientation" {
	/**
	 * Enum which represents the game orientation
	 */
	export enum EOrientation {
	    Both = 0,
	    Portrait = 1,
	    Landscape = 2
	}
}

declare module "@gdk/core/core/loader/loader" {
	import { DefaultLoader } from "@gdk/core/core/loader/default";
	import type { GameCore } from "@gdk/core/core/gameCore";
	import type { IGameConf, IAssetConf } from "@gdk/core/core/loader/gameConfigurationTypes";
	export class LoaderError extends Error {
	    constructor(message: string);
	}
	export interface ILoader {
	    extensions: string[];
	    baseUrl: string;
	    /**
	     * Add the file to load identified by the given key.
	     * @param filename the relative path of the file.
	     * @param key the key in the dictionary that identifies the file in order to retrieve using .get.
	     * @param options optionnal object that loaders can use. Typically metadata in the case of pixi.js loader.
	     */
	    add(filename: string, key?: string, options?: any): void;
	    /**
	     * Load all files previously added.
	     * @param callback called once all files have been loaded.
	     * @param progress called each time a file has been loaded.
	     * @param error called once if a file failed to load.
	     */
	    load(callback: () => void, progress?: (filename?: string) => void, error?: (file: string) => void): void;
	    /**
	     * Clear all the files to load dictionary.
	     */
	    clear?(): void;
	    /**
	     * Get resource/raw data from a loaded file.
	     * @param key identifier of the file to retrieve in the dictionary
	     * @param raw optionnal option to specifiy if you want the resource of the raw data.
	     * @returns the resource or the raw data of the file that has been loaded.
	     */
	    get?<T>(key: string, raw?: boolean): T;
	    /**
	     * Remove a file from the dictionary.
	     * @param key identifier of the file to remove.
	     */
	    remove?(key: string): void;
	}
	export class Loader {
	    game: GameCore;
	    /**
	     * Registers a loader which implements the interface ILoader
	     * @param loader the loader to register
	     */
	    static register(loader: ILoader): void;
	    /**
	     * Returns the resource identified by the given key
	     * @param key the key of the value to get
	     */
	    static get<T>(key: string, raw?: boolean): T;
	    static get loaders(): ILoader[];
	    private static _loaders;
	    onProgress: (percentage: number, loadedFile?: string) => void;
	    onError: (file: string) => void;
	    assetsPath: string;
	    protected filesCount: number;
	    protected _baseUrl: string;
	    /**
	     * Constructor
	     */
	    constructor(game: GameCore);
	    /**
	     * Returns the default loader
	     */
	    get defaultLoader(): DefaultLoader;
	    /**
	     * Gets the base Url of the loader
	     */
	    get baseUrl(): string;
	    /**
	     * Sets the base Url of the loader
	     */
	    set baseUrl(url: string);
	    /**
	     * Add the given file to the right loader
	     * @param file: the file to add to the proper loader
	     * @param key: optional, the key of the asset when calling get(key);
	     */
	    add(file: string | IAssetConf, key?: string, options?: any): void;
	    /**
	     * Clears all the loaders
	     */
	    clear(): void;
	    /**
	     * Removes the given entry identified by the given key
	     * @param key the key used to identify the entry to remove
	     */
	    remove(key: string): void;
	    /**
	     * Calls all loaders
	     * @param callback called when all loaders have loaded their files
	     */
	    load(callback?: () => void): Promise<void>;
	    /**
	     * Returns the resource identified by the given key
	     * @param key the key of the value to get
	     */
	    get<T>(key: string, raw?: boolean): T;
	    get loaders(): ILoader[];
	    /**
	     * Configures the loader from the current theme's base Url
	     * @param language the language configuration of the game (mandatory to know which locales to load)
	     * @param baseUrl the base Url which contains the files.json file and all other files to load
	     * @param i18nBaseUrl the base Url where to find i18n files (not necessary the same folder or ../)
	     * @example loader.baseUrl = urlOfThemeFolder;
	     * @example loader.configureFromTheme("vi", "fr-FR");
	     * @example await loader.load();
	     * @example const locales = this.loader.get("vi-i18n-base"); // Get main locales (i18n)
	     * @example const overridenLocales = this.loader.get("vi-i18n"); // Get overriden locales (i18n)
	     */
	    configureFromTheme(namespace: string, language: string, baseUrl?: string, i18nBaseUrl?: string): Promise<void>;
	    /**
	     * Parses the game conf and adds files to load (assets, i18n, etc.)
	     * @param conf the game configuration object to parse
	     */
	    loadFrom(conf: IGameConf, callback: () => void): void;
	    private _addFileAdvanced;
	    private _i18nConfig;
	}
}

declare module "@gdk/core/core/loader/default" {
	import type { ILoader } from "@gdk/core/core/loader/loader";
	export interface IFileType {
	    data: string;
	    filename: string;
	}
	export class DefaultLoader implements ILoader {
	    extensions: string[];
	    baseUrl: string;
	    filesToLoad: {
	        [index: string]: IFileType;
	    };
	    /**
	     * Add the given file to the files to load
	     * @param filename the file to add
	     */
	    add(filename: string, key?: string): void;
	    /**
	     * Clears the files to load dictionary
	     */
	    clear(): void;
	    /**
	     * Returns the resource identified by the given key
	     * @param key the key of the value to get
	     */
	    get<T>(key: string): T;
	    /**
	     * Load all files previously added
	     * @param callback called when all files loaded
	     */
	    load(callback?: () => void, progress?: (filename?: string) => void, error?: (file: string) => void): Promise<void>;
	    protected loadFile(filename: string, key: string, useArrayBuffer: boolean, callback: (filename: string) => void, error: (file: string) => void): void;
	}
}

declare module "@gdk/core/core/loader/gameConfigurationTypes" {
	import type { IAmount } from "@gdk/core/tools/index";
	export enum EEngine {
	    ITG = "ITG",
	    MTR = "MTR",
	    MTP = "MTP"
	}
	export enum EBetMode {
	    AUTO = "BET_AUTO_CLAIM",
	    MANUAL = "BET_MANUAL_CLAIM"
	}
	export interface INumberOfStakes {
	    min: number;
	    max?: number;
	}
	export interface IAssetsConf {
	    [index: string]: string | IAssetConf;
	}
	export interface IAssetConf {
	    default?: string | undefined;
	    [index: string]: string | undefined;
	    options?: any;
	}
	export interface IModules {
	    paths: {
	        [name: string]: string;
	    };
	}
	export interface ITheme {
	    game: string;
	    [index: string]: string;
	}
	export interface IStake {
	    /**
	     * value of the stake given in the smallest fraction digit of the currency (eg: 100 for 1€)
	     */
	    value: number;
	    /**
	     * Locale currency of the stake
	     */
	    currency: string;
	    /**
	     * The associated service name for the request (typically bet request)
	     */
	    serviceName: string;
	}
	export type StopReplayView = "reveal" | "result" | string;
	export type ActiveGameState = "load" | "splash" | "play" | string;
	export type DisplayButtonType = "all" | "retry" | "none" | string;
	export interface IHomeButtonSettings {
	    /**
	     * The order of children by their names
	     */
	    order?: string[];
	    /**
	     * The space between each buttons
	     */
	    separator?: number;
	    /**
	     * The orientation of the component
	     */
	    orientation?: "portrait" | "landscape" | "auto";
	    /**
	     * Display quit on a particular moment
	     */
	    displayQuitButton?: DisplayButtonType;
	}
	export interface IGame {
	    /**
	     * The current theme name of the game
	     */
	    theme: string;
	    /**
	     * Additional custom parameters for the game
	     */
	    parameters: {
	        /**
	         * Keep assets from framework and override new loads to avoid error
	         */
	        overrideOnMultipleLoads?: boolean;
	        /**
	         * The number of stakes the game supports
	         */
	        numberOfStakes: number;
	        /**
	         * Gets wether or not the game should pause on the user shows the settings
	         */
	        pauseOnSettings?: boolean;
	        /**
	         * Gets wether or not the game should pause on the window is blurred
	         */
	        pauseOnBlur?: boolean;
	        /**
	         * Gets wether or not the sound should be paused on the window is blurred.
	         */
	        muteSoundOnBlur?: boolean;
	        /**
	         * Should the game have fullscreen on touch devices
	         */
	        fullscreenEnabled?: boolean;
	        /**
	         * Should the sound be enabled on start
	         */
	        soundEnabled?: boolean;
	        /**
	         * Should the game block context menu
	         */
	        contextMenuBlocked?: boolean;
	        /**
	         * Should the game reject right click
	         */
	        rightClickRejected?: boolean;
	        /**
	         * Should skip the splash view
	         */
	        skipSplash?: boolean;
	        /**
	         * Should skip the rules view
	         */
	        skipRules?: boolean;
	        /**
	         * Should activate the replay mode when game is loaded
	         */
	        startReplayOn?: ActiveGameState;
	        /**
	         * Should resume the previous game if a ticket is running
	         */
	        startResumeOn?: ActiveGameState;
	        /**
	         * List of buttons to display in the home view
	         */
	        homeButtons?: IHomeButtonSettings;
	        /**
	         * Know when to stop the replay mode
	         */
	        stopReplayOn?: StopReplayView;
	        /**
	         * Show the resume popup when the ticket is in resume mode
	         */
	        showResumePopup?: boolean;
	        /**
	         * Show the replay popup when the ticket is in replay mode
	         */
	        showReplayPopup?: boolean;
	        /**
	         * Any other custom parameter for the game
	         */
	        [key: string]: any;
	    };
	}
	export interface IVisualIdentity {
	    /**
	     * The current theme name of the visual identity
	     */
	    theme?: string;
	    /**
	     * If the VI should skip the introduction (typically the illiko animation)
	     */
	    skipIntroduction?: boolean;
	    /**
	     * Any other custom parameter for the VI
	     */
	    [key: string]: any;
	}
	export interface IAssets {
	    themes: Record<string, string>;
	    i18n: Record<string, string>;
	    behaviours: Record<string, string>;
	    services: Record<string, string>;
	}
	export interface IDemo {
	    /**
	     * Gets wether or not the demo mode is enabled
	     */
	    enabled?: boolean;
	    /**
	     * Gets wether or not the player can play without being authenticated
	     */
	    forceAuthentication?: boolean;
	}
	export interface ICrossSell {
	    /**
	     * The name of the game
	     */
	    name: string;
	    /**
	     * The skin name of the spineTimelineButton
	     */
	    skinName?: string;
	    /**
	     * The name of the spine timeline button
	     */
	    spineTimelineButtonId?: string;
	    /**
	     * The id of the game
	     */
	    gameId: string;
	    /**
	     * The type of the game (e.g. ITG)
	     */
	    type: string;
	    [key: string]: any;
	}
	export interface IGameDescription {
	    numberOfStakes: INumberOfStakes;
	    isJackpot?: boolean;
	    isConversion?: boolean;
	    jackpotCompatible?: boolean;
	    demoCompatible?: boolean;
	    replayCompatible?: boolean;
	    supportedBetModes?: EBetMode[];
	    assets: IAssets;
	}
	export interface IBehavioursParameters {
	    pauseOnBlur?: boolean;
	    skipSplash?: boolean;
	    confirmOnBet?: boolean;
	    autoButton?: boolean;
	    demoButton?: boolean;
	    handlePreBet?: boolean;
	    resumeHook?: boolean;
	    gameEndHook?: boolean;
	    viParameters?: IVisualIdentity;
	    backgroundRulesClickable?: boolean;
	    vi: string;
	    /**
	     * Any other custom parameter for the VI
	     */
	    [key: string]: any;
	}
	export interface IGameConf {
	    version: string;
	    lotteryGameCode: string;
	    engine: EEngine;
	    modules: IModules;
	    crossSell?: ICrossSell[];
	    demo: IDemo;
	    gameDescription: IGameDescription;
	    selectedTheme: string;
	    selectedBetMode?: string;
	    selectedLocale: string;
	    selectedBehaviour: string;
	    lotteryCode: string;
	    stakes: IAmount[];
	    gameParameters: IBehavioursParameters;
	    defaultStakeIndex?: number;
	    behavioursParameters: Record<string, IBehavioursParameters>;
	    baseUrl?: string;
	    frameworkPath?: string;
	    gamePath?: string;
	    symbolSprites?: string[];
	}
}

declare module "@gdk/core/tools/index" {
	export { Numeral, ICurrencyOptions, ELocaleStringCurrencyDisplayOption, ILocaleStringDigitsOptions, ELocaleStringMatcherOption, ELocaleStringStyleOption, ILocaleStringOptions, } from "@gdk/core/tools/numeral/numeral";
	export { Amount, IAmount } from "@gdk/core/tools/numeral/amount";
	export { Tools } from "@gdk/core/tools/tools";
	export { Vector2 } from "@gdk/core/tools/vector2";
	export { Scalar } from "@gdk/core/tools/scalar";
	export { MD5 } from "@gdk/core/tools/crypto/md5";
	export { deterministicStringify } from "@gdk/core/tools/json/deterministicStringify";
}

declare module "@gdk/core/tools/numeral/numeral" {
	import type { currencyFormats } from "@gdk/core/tools/numeral/localeString";
	import type { IAmount } from "@gdk/core/tools/numeral/amount";
	export enum ELocaleStringMatcherOption {
	    LookUp = "lookup",
	    BestFit = "bestfit"
	}
	export enum ELocaleStringStyleOption {
	    Decimal = "decimal",
	    Currency = "currency",
	    Percent = "percent"
	}
	export enum ELocaleStringCurrencyDisplayOption {
	    Symbol = "symbol",
	    Code = "code",
	    Name = "name"
	}
	/**
	 * Options to use in the currency function
	 */
	export interface ICurrencyOptions {
	    /**
	     * minimumFractionDigits
	     * The minimum number of fraction digits to use.
	     * Possible values are from 0 to 20;
	     * the default for plain number and percent formatting is 0;
	     * the default for currency formatting is the number of minor unit digits provided
	     * by the ISO 4217 currency code list (2 if the list doesn't provide that information).
	     */
	    minimumFractionDigits?: number;
	    /**
	     * symbolFormatName
	     * If specified, forces the used format name.
	     * Possible values are currencyFormats keys, among which:
	     *  "pre": currency code in front of value. ex.: $10
	     *  "post": currency code after value. ex: 10£
	     *  "postspace" / "prespace": same as post / pre, with unbreakable space between code and currency. ex.: 10 kr
	     *  "onlynum": no currency code, just the value. ex: 10
	     * default formatName is set in ./localeString.ts>currencyFormatMap
	     */
	    symbolFormatName?: keyof typeof currencyFormats;
	    /**
	     * currencyDisplay
	     * How to display the currency in currency formatting.
	     * Possible values are
	     *  "symbol" to use a localized currency symbol such as €,
	     *  "code" to use the ISO currency code,
	     *  "name" to use a localized currency name such as "dollar".
	     * the default is "symbol".
	     */
	    currencyDisplay?: string;
	    /**
	     * change the decimal format if the amount given doesn't have decimals
	     * if null, no rules used and the decimals are displayed
	     * exemple: nb-NO "10,00 €" will be "10,- €" when alternateDecimalSymbol value is ",-"
	     */
	    alternativeDecimalSymbol?: string;
	    /**
	     * use a presaved option for lottery that do not display currencies with only one rule
	     * should be the display type name
	     * exemple: for fr-CH, currency on button use the code before the value
	     */
	    displayPreset?: "gain" | "symbol";
	}
	/**
	 * The following properties fall into two groups:
	 * minimumIntegerDigits, minimumFractionDigits, and maximumFractionDigits in one group,
	 * minimumSignificantDigits and maximumSignificantDigits in the other.
	 * If at least one property from the second group is defined, then the first group is ignored.
	 */
	export interface ILocaleStringDigitsOptions {
	    /**
	     * minimumIntegerDigits
	     * The minimum number of integer digits to use. Possible values are from 1 to 21; the default is 1.
	     */
	    minimumIntegerDigits?: number;
	    /**
	     * minimumFractionDigits
	     * The minimum number of fraction digits to use.
	     * Possible values are from 0 to 20;
	     * the default for plain number and percent formatting is 0;
	     * the default for currency formatting is the number of minor unit digits provided by the ISO 4217
	     * currency code list (2 if the list doesn't provide that information).
	     */
	    minimumFractionDigits?: number;
	    /**
	     * maximumFractionDigits
	     * The maximum number of fraction digits to use.
	     * Possible values are from 0 to 20; the default for plain number formatting
	     * is the larger of minimumFractionDigits and 3;
	     * the default for currency formatting is the larger of minimumFractionDigits andthe number of minor
	     * unit digits provided by the ISO 4217 currency code list (2 if the list doesn't provide that information);
	     * the default for percent formatting is the larger of minimumFractionDigits and 0.
	     */
	    maximumFractionDigits?: number;
	    /**
	     * minimumSignificantDigits
	     * The minimum number of significant digits to use.
	     * Possible values are from 1 to 21;
	     * the default is 1.
	     */
	    minimumSignificantDigits?: number;
	    /**
	     * maximumSignificantDigits
	     * The maximum number of significant digits to use.
	     * Possible values are from 1 to 21;
	     * the default is minimumSignificantDigits.
	     */
	    maximumSignificantDigits?: number;
	}
	/**
	 * Options to use in the generic format function
	 */
	export interface ILocaleStringOptions extends ILocaleStringDigitsOptions {
	    /**
	     * style
	     * The formatting style to use.
	     * Possible values are
	     *  "decimal" for plain number formatting,
	     *  "currency" for currency formatting, and
	     *  "percent" for percent formatting;
	     * the default is "decimal"
	     */
	    style?: string;
	    /**
	     * currency
	     * The currency to use in currency formatting.
	     * Possible values are the ISO 4217 currency codes, such as "USD" for the US dollar,
	     * "EUR" for the euro, or "CNY" for the Chinese RMB — see the Current currency & funds code list.
	     * There is no default value; if the style is "currency", the currency property must be provided.
	     */
	    currency?: string;
	    /**
	     * localeMatcher
	     * The locale matching algorithm to use.
	     * Possible values are "lookup" and "best fit"; the default is "best fit".
	     * For information about this option, see the Intl page:
	     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_negotiation .
	     */
	    localeMatcher?: string;
	    /**
	     * currencyDisplay
	     * How to display the currency in currency formatting.
	     * Possible values are
	     *  "symbol" to use a localized currency symbol such as €,
	     *  "code" to use the ISO currency code,
	     *  "name" to use a localized currency name such as "dollar".
	     * the default is "symbol".
	     */
	    currencyDisplay?: string;
	    /**
	     * force decimals to be entirely displayed for currency wich shorten them
	     * exemple: nb-NO "10,- NOK" will be "10,00 NOK" when true
	     */
	    alternativeDecimalSymbol?: string;
	    /**
	     * useGrouping
	     * Whether to use grouping separators, such as thousands separators or thousand/lakh/crore separators.
	     * Possible values are true and false; the default is true.
	     */
	    useGrouping?: boolean;
	}
	/**
	 * Number formatting class exposing static methods as format (handles every cases)
	 * and currency (handle most common currency formatting)
	 * Fallback on a polyfill if native method is not supported
	 */
	export class Numeral {
	    static currencyCode: string;
	    static locale: string;
	    /**
	     * Check if Intl is supported
	     */
	    static hasSupport(): boolean;
	    /**
	     * Generic number formatting method
	     * will handle every options
	     */
	    static format(value: number, options?: ILocaleStringOptions): string;
	    /**
	     * Format a number or an amount into a locale currency string
	     * value to format must be given in the smallest fraction digit of the currency (eg: 100 for 1€)
	     */
	    static currency(amount: IAmount, options?: ICurrencyOptions): string;
	}
}

declare module "@gdk/core/tools/numeral/localeString" {
	import type { ICurrencyOptions } from "@gdk/core/tools/numeral/numeral";
	/**
	 * used instead of the currency symbol if there is no decimals (eg 100,00 become 100,-)
	 */
	export const atlernateDecimalsSymbols: {
	    "nb-NO": string;
	    "fr-CH": string;
	    "de-CH": string;
	};
	export const displayPresets: {
	    [index: string]: {
	        [index: string]: ICurrencyOptions;
	    };
	};
	/**
	 * Constants
	 */
	export const digits: {
	    [index: string]: number;
	};
	export const currencyFormats: {
	    pre: string;
	    post: string;
	    postspace: string;
	    prespace: string;
	    onlynum: string;
	};
	export function toLocaleString(value: number, locale: string, options: any): string;
}

declare module "@gdk/core/tools/numeral/amount" {
	import type { ICurrencyOptions } from "@gdk/core/tools/numeral/numeral";
	/**
	 * Amount interface
	 * value is a number given in the fraction digits of the currency
	 * currency is an iso 4217 code
	 */
	export interface IAmount {
	    value: number;
	    currency: string;
	}
	/**
	 * Amount manipulation
	 * value is a number given in the fraction digits of the currency
	 * currency is an iso 4217 code
	 */
	export class Amount implements IAmount {
	    value: number;
	    currency: string;
	    /**
	     * Creates an amount object from an IAmount or a value.
	     * If only a number value is given, the currency code will be the Numeral one.
	     */
	    constructor(a: IAmount | number);
	    /**
	     * Multiplies an amount with a scalar
	     * @return a new amount with the operation result
	     */
	    multiply(scalar: number): Amount;
	    /**
	     * Sum amounts
	     * @return a new amount with the operation result
	     */
	    sum(amount: IAmount): Amount;
	    /**
	     * Currency formatting
	     * shortcut for Numeral.currency(amount, options)
	     */
	    toString(options?: ICurrencyOptions): string;
	    /**
	     * Create an Amount object from a number
	     * @param value the value is a number given in the fraction digits of the currency
	     * the currencyCode will be the one of Numeral
	     */
	    static fromNumber(value: number): Amount;
	    /**
	     * Format an amount value to string and show 2 digits if it's a whole number
	     * @param value: The value is a number given in the fraction digits of the currency
	     * @param options: Options to pass to the Numeral.currency function
	     * @return The formatted amount in string
	     */
	    static formatFromWholeOrRealNumber(value: number, options?: ICurrencyOptions): string;
	}
}

declare module "@gdk/core/tools/tools" {
	export class Tools {
	    /**
	     * Copies the source(s) members into the target
	     * @param target the target object
	     * @param sources the source object(s)
	     */
	    static assign<T, U>(target: T, source: U): T & U;
	    static assign<T, U, V>(target: T, source1: U, source2: V): T & U & V;
	    static assign<T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;
	    static assign(target: object, ...sources: any[]): any;
	    /**
	     * Merges the target's members to the source members
	     * @param source the source object
	     * @param target the target object
	     */
	    static merge<T, U>(source: T, target: U): T & U;
	    /**
	     * Returns a perfect clone of the given object.
	     * @param object the object to clone.
	     * @warning take care of cyclic references.
	     * @warning should never be a class, only simple objects.
	     */
	    static cloneObject<T>(object: T): T;
	    /**
	     * Returns the extension of the file
	     * @param filename the filename
	     */
	    static getExtension(filename: string): string;
	    /**
	     * Returns the filename without extension
	     * @param filename: the filename (path)
	     * @param withPath: if the return value should contain all path
	     */
	    static getFilenameWithoutExtension(filename: string, withPath?: boolean): string;
	    /**
	     * Returns the filename
	     * @param filename: the complete filename with path
	     */
	    static getFilename(filename: string): string;
	    /**
	     * Returns the folder name containing the given filename
	     * @param filename the filename
	     */
	    static getFolder(filename: string): string;
	    /**
	     * Returns the constructor name of the given object
	     * @param obj the object
	     */
	    static getConstructorName(obj: any): string;
	    /**
	     * Creates a new native popup
	     * @param url: the URL of the web page
	     * @param title: the title of the popup
	     * @param width: the with of the popup. 800px by default
	     * @param height: the height of the popup. 600px by default
	     */
	    static createPopup(url: string, title: string, width?: number, height?: number): Window;
	    /**
	     * Generates an uuid. As it relies on Math.random it may not be truly unique,
	     * however it is strong enough for our needs.
	     */
	    static uuidv4(): string;
	    /**
	     * Returns the nearest power of two value
	     * @param value the value get the power of 2
	     * @param max the max value of the power of 2
	     */
	    static getPowerOfTwo(value: number, max?: number): number;
	    /**
	     * Loads a file given its URL
	     * @param url: the url of the file to load
	     * @param arrayBuffer: if the response should be an array buffer instead of a text
	     * @param callback: optional callback if not using promises
	     */
	    static loadFile<T extends string | ArrayBuffer>(url: string, arrayBuffer: boolean, callback?: (data: T) => void): Promise<T>;
	    /**
	     * Injects the given script code (javascript) to the DOM
	     * @param code the code of the script
	     * @param name the name of the script
	     * @param namespace the namespace of the script (to help debugging in devtools)
	     */
	    static injectScript(code: string, name: string, namespace?: string): HTMLScriptElement;
	    /**
	     * Imports the given script identified by its name or URL
	     * @param keyOrUrl the name of the script to import
	     * @param baseURL the base Url used to request the dependencies of the script
	     */
	    static importScript<T>(keyOrUrl: string, baseURL?: string): Promise<T>;
	    /**
	     * Returns the already script loaded using Tools.importScript or Tools.injectScript in case of a SystemJS module
	     * @param key the key of the script that has been registered
	     */
	    static getScript<T>(key: string): T;
	}
}

declare module "@gdk/core/tools/vector2" {
	export class Vector2 {
	    /**
	     * Returns a vector from another object type
	     * @param value the value containing (x, y)
	     */
	    static from(value: {
	        x: number;
	        y: number;
	    } & {
	        [index: string]: any;
	    }): Vector2;
	    /**
	     * Returns the distance between the vectors
	     * @param vector1: the first vector
	     * @param vector2: the second vector
	     */
	    static Distance(vector1: Vector2, vector2: Vector2): number;
	    /**
	     * Returns the squared distance between the vectors
	     * @param vector1: the first vector
	     * @param vector2: the second vector
	     */
	    static DistanceSquared(vector1: Vector2, vector2: Vector2): number;
	    /**
	     * Clamps the given vector in the interval [min,max].
	     * @param vector the vector to clamp.
	     * @param min the minimum value the vector can have.
	     * @param max the maximum value the vector can have,.
	     */
	    static clamp(vector: Vector2, min: Vector2, max: Vector2): Vector2;
	    /**
	     * Gets the dot product of the given vectors (left and right).
	     * @param left the first vector.
	     * @param right the second vector.
	     */
	    static dot(left: Vector2, right: Vector2): number;
	    /**
	     * Returns the vector located at the center of the given two vectors (vector1 and vector2).
	     * @param vector1 defines the first vector.
	     * @param vector2 defines the second vector.
	     */
	    static center(vector1: Vector2, vector2: Vector2): Vector2;
	    /**
	     * Gets a new Vector2(0, 0)
	     */
	    static zero(): Vector2;
	    /**
	     * Returns a new Vector2 from the given array (index 0 and index 1).
	     * @param array the array containing x and y.
	     */
	    static fromArray(array: number[]): Vector2;
	    /**
	     * The X value of the vector.
	     */
	    x: number;
	    /**
	     * The Y value of the vector.
	     */
	    y: number;
	    /**
	     * Constructor.
	     * @param x: the x value of the new vector.
	     * @param y: the y value of the new vector.
	     */
	    constructor(x: number, y: number);
	    /**
	     * Sets the vector's value
	     * @param x: the x value
	     * @param y: the y value
	     */
	    set(x: number, y: number): Vector2;
	    /**
	     * Copies the given vector to the current one.
	     * @param otherVector the other vector to copy.
	     */
	    copy(otherVector: Vector2): Vector2;
	    /**
	     * Adds another vector with the current one and returns the new vector reference.
	     * @param otherVector defines the other vector
	     */
	    add(otherVector: Vector2): Vector2;
	    /**
	     * Adds another vector in and with the current one.
	     * @param otherVector defines the other vector
	     */
	    addSelf(otherVector: Vector2): Vector2;
	    /**
	     * Subtracts this with the given vector and returns the new vector.
	     * @param otherVector the other vector to subtract.
	     */
	    subtract(otherVector: Vector2): Vector2;
	    /**
	     * Subtracts this in and with the given vector.
	     * @param otherVector the other vector to subtract.
	     */
	    subtractSelf(otherVector: Vector2): Vector2;
	    /**
	     * Returns a new Vector2 set with the multiplication of the current Vector2 and the given one and returns the new vector.
	     * @param otherVector defines the other vector
	     */
	    multiply(otherVector: Vector2): Vector2;
	    /**
	     * Returns the current Vector2 set with the multiplication of the current Vector2 and the given one.
	     * @param otherVector defines the other vector
	     */
	    multiplySelf(otherVector: Vector2): Vector2;
	    /**
	     * Returns a new Vector2 set with the Vector2 coordinates divided by the given one and returns the new vector.
	     * @param otherVector defines the other vector
	     */
	    divide(otherVector: Vector2): Vector2;
	    /**
	     * Returns the current Vector2 set with the Vector2 coordinates divided by the given one.
	     * @param otherVector defines the other vector
	     */
	    divideSelf(otherVector: Vector2): Vector2;
	    /**
	     * Gets the length of the vector.
	     */
	    length(): number;
	    /**
	     * Gets a new Vector2 with current Vector2 negated coordinates
	     * @returns a new Vector2
	     */
	    negate(): Vector2;
	    /**
	     * Negates the current vector.
	     */
	    negateSelf(): Vector2;
	    /**
	     * Returns a new Vector2 scaled by "scale" from the current Vector2.
	     * @param scale defines the scaling factor
	     */
	    scale(scale: number): Vector2;
	    /**
	     * Returns the current Vector2 scale by the given number.
	     * @param scale defines the scaling factor.
	     */
	    scaleSelf(scale: number): Vector2;
	    /**
	     * Returns true if the given vector "otherVector" is equal to this vector.
	     * @param otherVector defines the other vector
	     */
	    equals(otherVector: Vector2): boolean;
	    /**
	     * Normalizes the vector.
	     */
	    normalize(): Vector2;
	    /**
	     * Floors the current vector values and returns the new vector.
	     */
	    floor(): Vector2;
	    /**
	     * Floors the current vector values.
	     */
	    floorSelf(): Vector2;
	    /**
	     * Transforms the current vector to an array interpretation.
	     * @param array the optional array to write (x,y) in.
	     */
	    toArray(array?: number[]): number[];
	}
}

declare module "@gdk/core/tools/scalar" {
	export class Scalar {
	    /**
	     * Returns the value itself if it's between min and max.
	     * Returns min if the value is lower than min.
	     * Returns max if the value is greater than max.
	     * @param value the value to clmap
	     * @param min the min value to clamp to (default: 0)
	     * @param max the max value to clamp to (default: 1)
	     */
	    static clamp(value: number, min?: number, max?: number): number;
	    /**
	     * the log2 of value.
	     * @param value the value to compute log2 of the given value
	     */
	    static log2(value: number): number;
	    /**
	     * Returns -1 if value is negative and +1 is value is positive.
	     * @param value the value
	     * @returns the value itself if it's equal to zero.
	     */
	    static sign(value: number): number;
	    /**
	     * Returns true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)
	     * @param a number to compare with b
	     * @param b number to compare with a
	     * @param epsilon (default = 1.401298E-45)
	     */
	    static withinEpsilon(a: number, b: number, epsilon?: number): boolean;
	}
}

declare module "@gdk/core/tools/crypto/md5" {
	/**
	 * Class from https://github.com/Hipparch/Md5-typescript
	 */
	export class MD5 {
	    /**
	     * Hash string with MD5.
	     * @returns the hashed string
	     * @param str specifies the string to hash
	     */
	    static init(str: any): string;
	    private static _pString;
	    private static _x;
	    private static _k;
	    private static _AA;
	    private static _BB;
	    private static _CC;
	    private static _DD;
	    private static _a;
	    private static _b;
	    private static _c;
	    private static _d;
	    private static _S11;
	    private static _S12;
	    private static _S13;
	    private static _S14;
	    private static _S21;
	    private static _S22;
	    private static _S23;
	    private static _S24;
	    private static _S31;
	    private static _S32;
	    private static _S33;
	    private static _S34;
	    private static _S41;
	    private static _S42;
	    private static _S43;
	    private static _S44;
	    private static _RotateLeft;
	    private static _AddUnsigned;
	    private static _F;
	    private static _G;
	    private static _H;
	    private static _I;
	    private static _FF;
	    private static _GG;
	    private static _HH;
	    private static _II;
	    private static _ConvertToWordArray;
	    private static _WordToHex;
	    private static _Utf8Encode;
	}
}

declare module "@gdk/core/tools/json/deterministicStringify" {
	/**
	 * Function from https://github.com/substack/json-stable-stringify
	 * @param obj
	 * @param opts
	 */
	export function deterministicStringify(obj: object, opts?: any): string;
}

declare module "@gdk/core/core/state" {
	import type { IView } from "@gdk/core/core/view";
	export interface IState {
	    [index: string]: {
	        next?: string;
	        view: IView;
	    };
	}
	export enum EStateEvents {
	    Loaded = "stateloaded",
	    Change = "statechange",
	    Changed = "statechanged"
	}
	interface IEventEmitter {
	    /**
	     * Calls each of the listeners registered for a givent event.
	     * @param {(string | symbol)} event The event name.
	     * @param {...*} args Arguments that are passed to registered listeners.
	     * @returns {boolean} `true` if the event had listeners, else `false`.
	     */
	    emit(event: string | symbol, ...args: any[]): boolean;
	}
	export class State {
	    states: IState;
	    onLoaded: () => void;
	    onStateChange: (newState: string) => void;
	    onStateChanged: (state: string) => void;
	    private _keys;
	    private _eventEmitter?;
	    private _current;
	    private _previous;
	    private _currentView;
	    private _attrs;
	    protected _busyOn: null | string;
	    /**
	     * Constructor
	     * @param states: the states instance
	     */
	    constructor(states: IState);
	    /**
	     * Set event emitter for state event notification.
	     * @param eventEmitter The event emitter.
	     */
	    set eventEmitter(eventEmitter: IEventEmitter);
	    /**
	     * Get event emitter for state event notification.
	     */
	    get eventEmitter(): IEventEmitter;
	    /**
	     * Loads the views calling .onLoad
	     * @param view: specifies the first view to make appear
	     */
	    load(view?: string): Promise<void>;
	    /**
	     * Returns the current view name
	     */
	    current(): string;
	    /**
	     * Returns the current view instance
	     */
	    currentView<T extends IView>(): T;
	    /**
	     * Returns the previous view instance
	     * Note: returns null if no transition was done
	     */
	    previousView<T extends IView>(): T;
	    /**
	     * Returns true if state is currently changing view (waiting for onWillAppear/onDidAppear)
	     * @returns boolean
	     */
	    get busy(): boolean;
	    /**
	     * Switches to the given view
	     * @param view: the given view name
	     */
	    to(view: string, next?: string): Promise<void>;
	    /**
	     * Switches to the next view
	     */
	    next(): Promise<string>;
	    /**
	     * Executes onWillAppear and onDidAppear of the given view
	     * @param view the view to make appear
	     */
	    executeAppear(view: IView, done?: () => void): Promise<void>;
	    /**
	     * Executes onWillDisappear and onDidDisappear of the given view
	     * @param view the view to make disappear
	     */
	    executeDisappear(view: IView, done?: () => void): Promise<void>;
	    /**
	     * Get the value of the given key in attrs
	     * @param key the key to pick in attrs
	     * @param value the value to set
	     */
	    attrs<T>(key?: string, value?: T): T;
	    /**
	     * Returns the states keys
	     */
	    stateKeys(): string[];
	    /**
	     * Return the view associated to the given state
	     * @param key the state's key
	     */
	    getViewFromState<T extends IView>(key: string): T;
	    /**
	     * Return the state key associated to the given view
	     * @param view the view associated to a state
	     */
	    getStateFromView(view: IView): string;
	    private _switchCurrentView;
	    private _drawNewView;
	    private _executeCallback;
	    /** Track an event if the callback match a state change */
	    private _trackCall;
	    /**
	     * Executes lifecycle hook synchronously or asynchronously
	     * @param hook ViewLifecycleHook.
	     * @param context context of the hook.
	     * @returns a promise resolved when the hook is done.
	     */
	    private _executeViewLifecycleHook;
	}
	export {};
}

declare module "@gdk/core/core/view" {
	import type { ITrackableObject } from "@gdk/core/tracking/tracker";
	/**
	 * Lifecycle hook for view. Can take an optionnal callback or optionnaly return a promise to indicate when it is done.
	 */
	export type ViewLifecycleHook = (done?: () => void) => void | Promise<void>;
	/**
	 * IView interface which represents a view
	 * lifecycle. Everyting is optional except onLoad
	 */
	export interface IView extends ITrackableObject {
	    /**
	     * Called when starting the game core, all views
	     * will be loaded
	     */
	    onLoad: ViewLifecycleHook;
	    /**
	     * Called when the view will appear
	     * @param done: (optional), call done() once everything is done
	     * @return can optionally return a promise instead of using done callback
	     */
	    onWillAppear?: ViewLifecycleHook;
	    /**
	     * Called when the view did appear
	     * @param done: (optional), call done() once everything is done
	     * @return can optionally return a promise instead of using done callback
	     */
	    onDidAppear?: ViewLifecycleHook;
	    /**
	     * Called when the view will disappear
	     * @param done: (optional), call done() once everything is done
	     * @return can optionally return a promise instead of using done callback
	     */
	    onWillDisappear?: ViewLifecycleHook;
	    /**
	     * Called when the view did disappear
	     * @param done: (optional), call done() once everything is done
	     * @return can optionally return a promise instead of using done callback
	     */
	    onDidDisappear?: ViewLifecycleHook;
	}
}

declare module "@gdk/core/tracking/tracker" {
	import type { IEvent } from "@gdk/core/tracking/events/event";
	import type { Logger } from "@gdk/core/logger/index";
	export interface IComTracker {
	    /**
	     * Trigger action on bridge
	     * @param action the action's name
	     * @param params parameters to send to the action
	     */
	    trigger(action: string, params?: any): void;
	}
	export interface ITrackableObject {
	    /**
	     * Defines the optional name of the object to be tracked.
	     * If unset, a default value will be taken by the tracker. For example,
	     * the name of the object (button, scratch, etc.).
	     */
	    trackingName: string;
	}
	/** Tracker object allows to send tracked info to com layer. */
	export class Tracker {
	    private _com;
	    private _logger;
	    private _gameInfo;
	    private _viewInfo;
	    private _seqNum;
	    private _uuid;
	    /** To be called once, at game initialization */
	    init({ com, logger }: {
	        com: IComTracker;
	        logger: Logger;
	    }): void;
	    /**
	     * track an event
	     * @param event specifies event to track
	     */
	    track(event: IEvent): void;
	    /** To be called when applet is loaded or quit */
	    private _gameEvent;
	    /** To be called each time a view state change */
	    private _viewEvent;
	    /** Actual tracking */
	    private _actualTrack;
	    private _getFullInfo;
	}
}

declare module "@gdk/core/tracking/events/event" {
	export enum EEventType {
	    Click = "click",
	    Error = "error",
	    Game = "game",
	    Slide = "slide",
	    View = "view",
	    Settings = "settings",
	    GetContext = "getContext",
	    Execute = "execute",
	    Rendering = "rendering",
	    Scratch = "scratch"
	}
	export interface IEvent {
	    eventType: EEventType;
	    event: string;
	}
}

declare module "@gdk/core/logger/index" {
	export { ELevel, EOutput } from "@gdk/core/logger/constants";
	export { Logger } from "@gdk/core/logger/logger";
	export { IAdapter } from "@gdk/core/logger/adapter";
}

declare module "@gdk/core/logger/constants" {
	export enum ELevel {
	    Debug = 0,
	    Info = 1,
	    Warn = 2,
	    Error = 3
	}
	export enum EOutput {
	    Console = 0
	}
}

declare module "@gdk/core/logger/logger" {
	import { ELevel, EOutput } from "@gdk/core/logger/constants";
	import type { IAdapter } from "@gdk/core/logger/adapter";
	/**
	 * Logs library for game:
	 *
	 * @see Logger.init and Logger.getLogger for creating/getting instance
	 *
	 * Example:
	 * In Game initialisation:
	 *
	 *   import { Logger, LEVEL, OUTPUT, TAG } from "../src/index";
	 *
	 *   Logger.init(LEVEL.info, OUTPUT.console);
	 *
	 * Wherever logger is needed:
	 *    const logger = Logger.getLogger();
	 *
	 *    logger.log(LEVEL.info, "message");
	 *
	 *    logger.debug("warn");
	 *
	 *    logger.info("hello");
	 *    logger.info(TAG, {}); // add TAG info in {}
	 *
	 *    logger.info("warn");
	 *
	 *    logger.error("error");
	 *    logger.error(TAG, {}); // add TAG error params in {}
	 *
	 */
	export class Logger {
	    static LEVEL: typeof ELevel;
	    static OUTPUT: typeof EOutput;
	    /** Returns current logger (init must be called before)
	     * To log a message:
	     * logger.info('msg');
	     * To lag a TAG:
	     * logger.info(TAG, { TAG data })
	     */
	    static getLogger(): Logger;
	    /** Must be called when soft start to initiate the logger
	     * @param level: minimum level to log (default: LEVEL.info)
	     * @param outputs: where log will be send
	     */
	    static init(level?: ELevel, ...outputs: EOutput[]): Logger;
	    private static _logger;
	    private _adapters;
	    private constructor();
	    /**
	     * Add logger
	     * @param logger specifies logger to add
	     */
	    addLogger(logger: IAdapter): void;
	    /**
	     * Log
	     * @param level specifies the level of log (debug/ingo/warn/error)
	     * @param data specifies the data to log
	     */
	    log(level: ELevel, ...data: any[]): void;
	    /**
	     * Alias for log(ELevel.Debug, ...data);
	     * @param data specifies the data to log
	     */
	    debug(...data: any[]): void;
	    /**
	     * Alias for log(ELevel.Info, ...data);
	     * @param data specifies the data to log
	     */
	    info(...data: any[]): void;
	    /**
	     * Alias for log(ELevel.Warn, ...data);
	     * @param data specifies the data to log
	     */
	    warn(...data: any[]): void;
	    /**
	     * Alias for log(ELevel.Error, ...data);
	     * @param data specifies the data to log
	     */
	    error(...data: any[]): void;
	    private _hasLogger;
	}
}

declare module "@gdk/core/logger/adapter" {
	import type { ELevel } from "@gdk/core/logger/constants";
	export interface IAdapter {
	    /**
	     * Write the given data to the adapter output.
	     * @param level
	     * @param data
	     */
	    write(level: ELevel, ...data: any[]): void;
	}
}

declare module "@gdk/core/sound/index" {
	export { HowlerLoader } from "@gdk/core/sound/howlerLoader";
	export { SoundLayer } from "@gdk/core/sound/layer";
}

declare module "@gdk/core/sound/howlerLoader" {
	import { Howl } from "howler";
	import type { ILoader } from "@gdk/core/core/index";
	export interface IFileType {
	    /**
	     * The howler reference once the sound file has been loaded.
	     */
	    data: Howl;
	    /**
	     * The filename (path) of the sound file.
	     */
	    filename: string;
	    /**
	     * The layer where the sound is attached. -1 by default.
	     */
	    layer: number;
	}
	export class HowlerLoader implements ILoader {
	    extensions: string[];
	    baseUrl: string;
	    static sounds: {
	        [index: string]: IFileType;
	    };
	    /**
	     * Add the given file to the files to load
	     * @param filename the file to add
	     * @param key the key of the asset (works as a shortcut)
	     */
	    add(filename: string, key?: string): void;
	    /**
	     * Clears the files to load dictionary
	     */
	    clear(): void;
	    /**
	     * Returns the resource identified by the given key
	     * @param key the key of the value to get
	     */
	    get<T>(key: string): T;
	    /**
	     * Load all files previously added
	     * @param callback called when all files loaded
	     * @param progress called when a file has been loaded
	     * @param error called when an error happens
	     */
	    load(callback: () => void, progress?: (filename?: string) => void, error?: (file: string) => void): void;
	    private _getSrc;
	    private _createInstance;
	}
}

declare module "@gdk/core/sound/layer" {
	import type { Howl } from "howler";
	export class SoundLayer {
	    /**
	     * Returns all the sounds available in the given layer.
	     * @param layer the layer to get its sounds.
	     */
	    static getSoundsFromLayer(layer: number): Howl[];
	    /**
	     * Attach the given sound to the given layer.
	     * @param sound the sound reference to configure.
	     * @param layer the layer where to add the sound.
	     */
	    static setSoundLayer(sound: Howl, layer: number): void;
	    /**
	     * Sets the given layer muted or unmuted.
	     * @param layer the layer to mute or unmute.
	     * @param muted wether or not the layer should be muted.
	     */
	    static muteLayer(layer: number, muted: boolean): void;
	    /**
	     * Sets the given layer paused or resumed.
	     * @param layer the layer to pause or resume.
	     * @param muted wether or not the layer should be paused or resumed.
	     */
	    static pauseLayer(layer: number, paused: boolean): void;
	}
}

declare module "@gdk/core/tracking/index" {
	import { Tracker } from "@gdk/core/tracking/tracker";
	export { CLICK_EVENT, ClickEvent, ButtonClick, LinkClick } from "@gdk/core/tracking/events/click";
	export { GameLoaded, GameQuit } from "@gdk/core/tracking/events/game";
	export { EViewState, ViewStateEvent } from "@gdk/core/tracking/events/view";
	export { ErrorEvent } from "@gdk/core/tracking/events/error";
	export { ESlideEvent, SlideEvent } from "@gdk/core/tracking/events/slide";
	export { ESettingsEvent, SettingsEvent } from "@gdk/core/tracking/events/settings";
	export { EEventType, IEvent } from "@gdk/core/tracking/events/event";
	export { ITrackableObject } from "@gdk/core/tracking/tracker";
	const tracker: Tracker;
	export { Tracker, tracker };
}

declare module "@gdk/core/tracking/events/click" {
	import { EEventType } from "@gdk/core/tracking/events/event";
	import type { IEvent } from "@gdk/core/tracking/events/event";
	export enum CLICK_EVENT {
	    click = "click",
	    button = "buttonClick",
	    link = "linkClick"
	}
	/** Generic click event */
	export class ClickEvent implements IEvent {
	    name: string;
	    event: CLICK_EVENT | string;
	    eventType: EEventType;
	    constructor(name: string, event?: CLICK_EVENT | string);
	}
	/** To Track click on a button */
	export class ButtonClick extends ClickEvent {
	    eventType: EEventType;
	    constructor(name: string);
	}
	/** To Track link on a button */
	export class LinkClick extends ClickEvent {
	    url: string;
	    constructor(name: string, url: string);
	}
}

declare module "@gdk/core/tracking/events/game" {
	import { EEventType } from "@gdk/core/tracking/events/event";
	import type { IEvent } from "@gdk/core/tracking/events/event";
	export interface IGameInfo {
	    technicalName: string;
	    gameType: string;
	    locale: string;
	    currency: string;
	    theme: string;
	}
	export enum EGameEvent {
	    Loaded = "loaded",
	    Quit = "quit"
	}
	export interface IGameEvent extends IEvent {
	    event: EGameEvent;
	}
	export class GameLoaded implements IGameEvent {
	    gameInfo: IGameInfo;
	    eventType: EEventType;
	    event: EGameEvent;
	    constructor(gameInfo: IGameInfo);
	}
	export class GameQuit implements IGameEvent {
	    eventType: EEventType;
	    event: EGameEvent;
	}
}

declare module "@gdk/core/tracking/events/view" {
	import { EEventType } from "@gdk/core/tracking/events/event";
	import type { IEvent } from "@gdk/core/tracking/events/event";
	export enum EViewState {
	    WillDisappear = "willDisappear",
	    DidDisappear = "didDisappear",
	    WillAppear = "willAppear",
	    DidAppear = "didAppear"
	}
	export enum EViewEvent {
	    StateChange = "state"
	}
	export interface IViewInfo {
	    name: string;
	    state: EViewState;
	}
	export interface IViewEvent extends IEvent {
	    name: string;
	    event: EViewEvent;
	}
	export class ViewStateEvent implements IViewEvent {
	    name: string;
	    eventType: EEventType;
	    event: EViewEvent;
	    viewInfo: IViewInfo;
	    constructor(name: string, state: EViewState);
	}
}

declare module "@gdk/core/tracking/events/error" {
	import { EEventType } from "@gdk/core/tracking/events/event";
	import type { IEvent } from "@gdk/core/tracking/events/event";
	export class ErrorEvent implements IEvent {
	    errorMessage: string;
	    eventType: EEventType;
	    event: string;
	    constructor(errorMessage: string);
	}
}

declare module "@gdk/core/tracking/events/slide" {
	import { EEventType } from "@gdk/core/tracking/events/event";
	import type { IEvent } from "@gdk/core/tracking/events/event";
	export enum ESlideEvent {
	    Show = "show",
	    Hide = "hide"
	}
	export interface ISlideEvent extends IEvent {
	    event: ESlideEvent;
	}
	export class SlideEvent implements SlideEvent {
	    name: string;
	    event: ESlideEvent;
	    eventType: EEventType;
	    constructor(name: string, event: ESlideEvent);
	}
}

declare module "@gdk/core/tracking/events/settings" {
	import { EEventType } from "@gdk/core/tracking/events/event";
	import type { IEvent } from "@gdk/core/tracking/events/event";
	export enum ESettingsEvent {
	    Show = "show",
	    Hide = "hide"
	}
	export class SettingsEvent implements IEvent {
	    event: ESettingsEvent;
	    eventType: EEventType;
	    constructor(event: ESettingsEvent);
	}
}

declare module "@gdk/core/decorators/index" {
	export * from "@gdk/core/decorators/serialize";
}

declare module "@gdk/core/decorators/serialize" {
	export interface ISerializationObject {
	    /**
	     * Defines the name of the serialized property.
	     */
	    sourceName: string | symbol;
	    /**
	     * Defines the type of the serialized property.
	     */
	    type: string;
	}
	/**
	 * Defines the store that handles the serializable members.
	 */
	export const initialStore: {
	    [ctorName: string]: ISerializationObject[];
	};
	/**
	 * Resets the initial store by removing all available keys.
	 * @warning use with care.
	 */
	export function resetInitialStore(): void;
	/**
	 * Serializes the property which has a number.
	 * @param sourceName optional name to retrieve when serializing/deserializing.
	 */
	export function serializeAsNumber(sourceName?: string): any;
	/**
	 * Serializes the property which has a number.
	 * @param sourceName optional name to retrieve when serializing/deserializing.
	 */
	export function serializeAsString(sourceName?: string): any;
	/**
	 * Serializes the property which has a number.
	 * @param sourceName optional name to retrieve when serializing/deserializing.
	 */
	export function serializeAsBoolean(sourceName?: string): any;
	/**
	 * Generates a serialization member (decorator function).
	 * @param type the type of the property to serialize.
	 * @param sourceName the optional custom name of the property to serialize.
	 */
	export function generateSerializableMember(type: string, sourceName?: string): any;
}
