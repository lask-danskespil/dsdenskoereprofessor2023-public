"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BetManager = void 0;
const lodash_1 = __importDefault(require("lodash"));
const moment_1 = __importDefault(require("moment"));
const apiError_1 = require("../../routes/apiError");
const server_1 = __importDefault(require("../server"));
const croupier_1 = __importDefault(require("./croupier/croupier"));
const mocksStore_1 = require("./mocksStore");
const ticketStore_1 = require("./ticketStore");
const types_1 = require("./types");
const jackpot_1 = require("../jackpot");
const jackpotResults_1 = require("../jackpotResults");
class BetManager {
    constructor() {
        this._croupiers = {};
        this._receiptId = 0;
        this._tickets = new ticketStore_1.TicketStore();
        this._mocks = new mocksStore_1.MocksStore();
    }
    /**
     * Add croupier.
     */
    addCroupier(croupier, serviceName) {
        this._croupiers[serviceName] = croupier;
    }
    /**
     * Process bet requests.
     * @param betRequests
     */
    handleBetRequests(betRequests, player) {
        return Promise.all(betRequests.map((betRequest) => this.handleBetRequest(betRequest, player)));
    }
    /**
     * Process bet request.
     * @param betRequest
     */
    async handleBetRequest(betRequest, player) {
        if (!this._croupiers[betRequest.gameName.toLowerCase()]) {
            throw { message: `Could not find croupier for ${betRequest.gameName}.` };
        }
        server_1.default.getInstance().assert();
        betRequest.amount.currency = betRequest.amount.currency.toLowerCase().trim();
        const mock = this._mocks.getNext(betRequest.gameName.toLowerCase(), player.id);
        const { ticket, factor, prize } = this._croupierBet(betRequest, mock);
        const receiptId = this._nextReceiptId();
        if (jackpot_1.Jackpot.getInstances().length) {
            const jackpotResult = jackpot_1.Jackpot.bet(betRequest.amount);
            jackpotResults_1.JackpotResultsStore.getInstance().store(player.id, ticket.id, jackpotResult);
        }
        const wonAmount = {
            currency: betRequest.amount.currency,
            value: (betRequest.amount.value * factor.numerator) / factor.denominator,
        };
        player.updatePurseWithBet(betRequest.amount.value);
        if (betRequest.betMode === types_1.EBetMode.AUTO) {
            player.updatePurseWithWin(wonAmount.value);
        }
        const response = {
            demo: betRequest.demo,
            receiptId,
            platformBetId: String(ticket.id),
            serverMessage: [],
            wonAmount,
            data: {
                betAmount: betRequest.amount,
                demo: betRequest.demo,
                id: ticket.id,
                symbol: ticket.symbol,
                platformBetId: String(ticket.id),
                prize,
                claimedTime: null,
                status: betRequest.betMode === types_1.EBetMode.MANUAL ? "OPENED" : "CLAIMED",
                openedTime: moment_1.default.utc().format("YYYY-MM-DDThh:mm:ssZ"),
                wonAmount,
                receiptId,
                revelationData: null,
                serviceName: betRequest.gameName,
            },
        };
        this._tickets.store(player.id, response);
        return response;
    }
    /**
     * Retrieve croupier model for a service
     */
    getModel(serviceName) {
        const model = this._croupiers[serviceName.toLowerCase()].model;
        if (!model) {
            throw { message: `Could not find croupier for ${serviceName}.` };
        }
        return model;
    }
    /**
     * Returns all the tickets filtered by the given status and game name.
     * @param filters
     * @param player
     */
    getTickets(filters, player) {
        let tickets = this._tickets.filter((t) => (player ? t.playerId === player.id : true));
        if (filters.gameCode) {
            tickets = tickets.filter((t) => t.ticket.data.serviceName === filters.gameCode);
        }
        if (filters.ticketStatus) {
            tickets = tickets.filter((t) => t.ticket.data.status === filters.ticketStatus);
        }
        if (filters.gameCode) {
            tickets = tickets.filter((t) => t.ticket.data.serviceName === filters.gameCode);
        }
        tickets = tickets.filter((t) => t.ticket.demo === Boolean(filters.demoMode));
        return tickets.map((t) => t.ticket.data);
    }
    /**
     * Returns the first ticket identified by the given id.
     * @param id the id of the ticket to find.
     */
    getTicketById(id, player) {
        const res = this._tickets.find((t) => (player ? t.playerId === player.id : true) && t.ticket.data.id === id);
        return res ? res.ticket.data : null;
    }
    /**
     * Remove ticket by id
     * @param id the id of the ticket to find.
     */
    removeTicketById(id) {
        lodash_1.default.remove(this._tickets, (t) => t.ticket.data.id === id);
    }
    /**
     * Updates the given ticket's data identified by the given id.
     * @param id the id of the ticket to find and modify its revelation datas.
     * @param data the new revelation datas of the ticket to assign.
     * @param player the player requesting to update the ticket.
     */
    updateTicket(id, data, player) {
        const ticket = this._tickets.find((t) => t.playerId === player.id && t.ticket.data.id === id).ticket;
        if (!ticket) {
            throw { message: `No ticket found with id "${id}"` };
        }
        if (ticket.data.status === "CLAIMED") {
            throw { message: `Can't update a claimed ticket` };
        }
        if (data.status && data.status === "CLAIMED" && ticket.data.status !== "CLAIMED") {
            player.updatePurseWithWin(ticket.wonAmount.value);
        }
        Object.assign(ticket.data, data);
        return ticket;
    }
    /**
     * Get registered mocks values for a given service and a given player
     */
    getMocks(serviceName, player) {
        return this._mocks.get(serviceName.toLowerCase(), player.id);
    }
    /**
     * Add mocks values for future bets for a given service and a given player
     */
    addMocks(serviceName, player, mocks) {
        this._mocks.add(serviceName.toLowerCase(), player.id, mocks);
    }
    /**
     * Remove all mocks values for a given service and a given player
     */
    removeMocks(serviceName, player) {
        this._mocks.remove(serviceName.toLowerCase(), player.id);
    }
    _croupierBet(betRequest, mock) {
        const gameName = betRequest.gameName;
        const baseStake = this._croupiers[gameName].model.baseStake;
        const croupier = this._croupiers[gameName.toLowerCase()];
        if (croupier.masterGameCode) {
            const canBet = betRequest.amount.value % croupier.baseStake === 0;
            if (!canBet) {
                throw {
                    message: `Bet amount "${betRequest.amount.value}" not allowed. Must be a multiplier of ${croupier.baseStake}`,
                    code: apiError_1.ApiError.INVALID_STAKE.code,
                };
            }
        }
        else {
            const stakes = this._croupiers[gameName.toLowerCase()].stakes;
            const bet = stakes.find((stake) => {
                return (stake.value === betRequest.amount.value &&
                    stake.currency.toUpperCase() === betRequest.amount.currency.toUpperCase());
            });
            if (!bet) {
                throw {
                    message: `Bet amount "${betRequest.amount.value}" not found. Available: ${JSON.stringify(croupier.stakes, null, 2)}`,
                    code: apiError_1.ApiError.INVALID_STAKE.code,
                };
            }
        }
        const draw = this._croupiers[gameName.toLowerCase()].draw(betRequest.amount.value, mock);
        draw.ticket.id = croupier_1.default.ticketId++;
        return draw;
    }
    _nextReceiptId() {
        return `000000000${++this._receiptId}`.substr(-9);
    }
}
exports.BetManager = BetManager;
//# sourceMappingURL=betManager.js.map