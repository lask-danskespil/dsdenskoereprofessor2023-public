"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.localCompare = void 0;
const _ = __importStar(require("lodash"));
const croupierLoader_1 = require("./croupierLoader");
/**
 * A Javascrpipt localCompare on service name
 */
const localCompare = (a, b) => a.code.localeCompare(b.code);
exports.localCompare = localCompare;
/**
 * Croupier currently used by the game
 */
class Croupier {
    /**
     * Load the croupier from file.
     * @param croupierPath path to the croupier file, .json or .sql.
     * @param code expected serviceName.
     * @returns a promise resolving with the Croupier when loaded.
     */
    static async get(croupierPath, code) {
        const croupier = new Croupier();
        if (!(await croupier._load(croupierPath, code))) {
            throw { message: "Failed to load croupier." };
        }
        return croupier;
    }
    /**
     * Loads a coupier for the given serviceName.
     * @returns false if found no croupier for the service name
     */
    async _load(croupierPath, serviceName) {
        this.raw = await croupierLoader_1.CroupierLoader.load(croupierPath, serviceName);
        this.flat = [];
        this.raw.ranks.forEach((r) => {
            this.flat.push(...r.tickets.map((t) => {
                return {
                    ticket: t,
                    rank: {
                        id: r.id,
                        factor: r.factor,
                        type: r.prizeType,
                        description: r.prizeDescription,
                    },
                };
            }));
        });
        return this.raw !== null;
    }
    /**
     * Returns service name.
     * @returns the servicename of the croupier
     */
    getCroupierCode() {
        return this.raw ? this.raw.code : "unknown";
    }
    /**
     * Gets the current schema version of the croupier.
     */
    get schemaVersion() {
        return this.raw.schemaVersion;
    }
    /**
     * Gets the current master game code of the croupier.
     */
    get masterGameCode() {
        return this.raw.masterGameCode;
    }
    /**
     * Returns croupier model.
     */
    get model() {
        return this.raw;
    }
    /**
     * Returns the croupier ranks or an empty array
     */
    get ranks() {
        return this.raw ? this.raw.ranks : [];
    }
    /**
     * Returns the stakes or an empty array
     */
    get stakes() {
        return this.raw ? this.raw.stakes : [];
    }
    /**
     * Returns the base stake or an empty array
     */
    get baseStake() {
        return this.raw ? this.raw.baseStake : 1;
    }
    /**
     * Gets exported croupier.
     */
    getExportedCroupier() {
        return { ranks: this.ranks };
    }
    /**
     * Draw a ticket, randomely or mock driven
     */
    draw(stakeValue, mock) {
        if (!this.raw) {
            throw { message: "No croupier available" };
        }
        let tickets = this.flat;
        if (mock && !_.isUndefined(mock.rank)) {
            tickets = tickets.filter((t) => t.rank.id === mock.rank);
        }
        if (mock && !_.isUndefined(mock.symbol)) {
            tickets = tickets.filter((t) => t.ticket.symbol.indexOf(mock.symbol) !== -1);
        }
        if (mock && !_.isUndefined(mock.symbolPattern)) {
            const r = new RegExp(mock.symbolPattern);
            tickets = tickets.filter((t) => r.test(t.ticket.symbol));
        }
        if (mock && !_.isUndefined(mock.winAmount)) {
            tickets = tickets.filter((t) => (t.rank.factor.numerator * stakeValue) / t.rank.factor.denominator === mock.winAmount);
        }
        if (!tickets.length) {
            throw { message: "no matching ticket" };
        }
        const drawn = _.sample(tickets);
        const prize = {
            rank: drawn.rank.id,
            type: drawn.rank.type,
            description: drawn.rank.description,
        };
        return {
            ticket: drawn.ticket,
            factor: drawn.rank.factor,
            prize,
        };
    }
}
exports.default = Croupier;
/**
 * Current ticket id incremented when drawing.
 */
Croupier.ticketId = 0;
//# sourceMappingURL=croupier.js.map