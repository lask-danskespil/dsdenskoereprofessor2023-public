"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Player = void 0;
const _ = __importStar(require("lodash"));
const errors = __importStar(require("./errors"));
const helpers_1 = require("../helpers");
const apiError_1 = require("../routes/apiError");
class Player {
    /**
     * Get player instance.
     */
    static getInstance(id) {
        if (id === undefined) {
            return Player.player;
        }
        else {
            if (Player.players[id]) {
                return Player.players[id];
            }
            else {
                const p = new Player({
                    playerId: id,
                    alias: `${id}`,
                    avatarCode: `${((Math.random() * 5) >> 0).toString()}`,
                    purse: { value: 1000000 + Math.floor(Math.random() * 1000000), currency: "EUR" },
                });
                Player.players[id] = p;
                return p;
            }
        }
    }
    constructor(jsonPlayer) {
        this.errorHelper = new errors.ErrorHelper([
            errors.PLAYER_NOT_FOUND,
            errors.LOCKED_ACCOUNT,
            errors.NOT_ENOUGH_MONEY,
            errors.THRESHOLD_EXCEEDED,
        ]);
        this.id = jsonPlayer.playerId;
        this.alias = jsonPlayer.alias || `${jsonPlayer.playerId}`;
        this.avatarCode = jsonPlayer.avatarCode || "0";
        this.amount = _.isUndefined(jsonPlayer.purse)
            ? 10000 + Math.floor(Math.random() * 10000)
            : jsonPlayer.purse.value;
    }
    /**
     * Returns the playerId from an HAPI request
     * playerId can be set as a query param of the URL of the caller, or from cookies
     * @param request: the Hapi.request
     */
    static getPlayerId(request) {
        if (request && request.headers && request.headers.playerid !== undefined) {
            return request.headers.playerid;
        }
        else if (request && request.headers && request.headers.referer) {
            return (0, helpers_1.getRefererParameters)(request.headers.referer).playerId;
        }
        return undefined;
    }
    /**
     * Returns the player from an HAPI request
     * playerId can be set as a query param of the URL of the caller, or from cookies
     * @param request: the Hapi.request
     */
    static getPlayer(request) {
        const id = Player.getPlayerId(request);
        return Player.getPlayerFromId(id);
    }
    /**
     * Get a player from id
     * @param playerId
     */
    static getPlayerFromId(playerId) {
        return Player.getInstance(playerId);
    }
    /**
     * Remove a registered player from id
     * @param playerId
     */
    static removePlayer(playerId) {
        if (Player.players[playerId]) {
            delete Player.players[playerId];
        }
        else {
            throw { message: "player not found" };
        }
    }
    /**
     * Creates a player from json
     * @param jsonPlayer
     */
    static create(jsonPlayer) {
        if (Player.getPlayerFromId(jsonPlayer.playerId)) {
            throw { message: "unable to create player. player already exists" };
        }
        else {
            const p = new Player(jsonPlayer);
            Player.players[jsonPlayer.playerId] = p;
            return p;
        }
    }
    /**
     * Get full players list
     */
    static getPlayers(ids) {
        const players = Object.values(Player.players);
        return ids ? ids.map((id) => this.getPlayerFromId(id)) : players;
    }
    /**
     * Throws an exception if Player"s error is set
     */
    assert() {
        this.errorHelper.assert();
    }
    /**
     * Get error.
     */
    get error() {
        return this.errorHelper.error;
    }
    /**
     * Set error.
     */
    set error(newError) {
        if (newError && !this.errorHelper.getAvaiblable().includes(newError)) {
            throw new Error(`Try to set Player error with a non player error: ${newError}`);
        }
        this.errorHelper.error = newError;
    }
    /**
     * Set error.
     * @param newErrorCode
     */
    setError(newErrorCode) {
        const newError = this.errorHelper.getByCode(newErrorCode);
        if (newErrorCode && !newError) {
            throw new Error(`Try to set Player error with a non player error: ${newErrorCode}`);
        }
        this.errorHelper.error = newError;
    }
    /**
     * Get available errors.
     * @param gameType
     */
    getAvaiblableErrors(gameType) {
        return this.errorHelper.getAvaiblable(gameType);
    }
    /**
     * Update purse with bet.
     * @param betAmount
     */
    updatePurseWithBet(betAmount) {
        if (this.amount < betAmount) {
            throw apiError_1.ApiError.INSUFFICIANT_FUNDS;
        }
        this.amount -= betAmount;
    }
    /**
     * Update purse with win.
     * @param amount
     */
    updatePurseWithWin(amount) {
        if (amount < 0) {
            throw { message: `Cannot win a negative value: won amount ${amount}` };
        }
        this.amount += amount;
    }
    /**
     * Get a json format of a player
     */
    toJson() {
        return {
            playerId: this.id,
            alias: this.alias,
            avatarCode: this.avatarCode,
            purse: {
                value: this.amount,
                currency: "EUR",
            },
        };
    }
}
exports.Player = Player;
Player.players = {};
Player.player = new Player({
    playerId: "default",
    alias: "John Doe",
    avatarCode: "0",
    purse: { value: 1000000, currency: "EUR" },
});
//# sourceMappingURL=player.js.map