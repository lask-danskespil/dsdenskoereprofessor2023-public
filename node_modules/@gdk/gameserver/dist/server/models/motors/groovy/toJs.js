"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GroovyToJS = exports.Converter = void 0;
const vm = __importStar(require("vm"));
const fs = __importStar(require("fs"));
const helpers_1 = require("../../../helpers");
const player_1 = require("../../player");
const gamePrimitives = __importStar(require("./primitives"));
const augmentations_1 = require("./augmentations");
const MULTI_LINE = new RegExp(`"""`, "g");
const ITEM = "[a-zA-Z0-9_\\-\\.]*"; // can be a value or an identifier
const IDENTIFICATER = "[a-zA-Z][a-zA-Z0-9_-]*"; // want only an identifier
const EOL = ".*"; // everyting until the end of line
const CALLBACK_BEGIN = "\\s*\\(\\s*{"; // call must be passed using {[ syntax
const DEF = "def\\s+"; // def keywork must be followed by a space so taht can"t be confuse with name like defFoo
const GET_ITEM = `\\s*(${ITEM})\\s*`;
const GET_IDENTIFIER = `\\s*(${IDENTIFICATER})\\s*`;
// for callback with 2 parameters: a,b ->
const CALLBACK_GET_2_IDENTIFIERS = `${CALLBACK_BEGIN}${GET_IDENTIFIER},${GET_IDENTIFIER}->\\s*`;
const GET_EOL = `\\s*(.*)`;
// !! as CLOSURE use def, it must be apply before DEF_VARIABLE
// $1 name, $2 eol
const CLOSURE = new RegExp(`def${GET_IDENTIFIER}=\\s*{${GET_EOL}`, "g");
// no $, just for replaceing def keywork
const DEF_VARIABLE = new RegExp(`${DEF}`, "g");
// $1 first value, $2 second value
const STARSHIP_OPERATOR = new RegExp(`${GET_ITEM}<=>${GET_ITEM}`, "g");
// no $
const SIZE_METHOD = new RegExp("\\.size\\s*\\(\\)", "g");
const CONTAINSKEY_METHOD = new RegExp("\\.containsKey", "g");
// $1 first param, $2 second param, $3 eol
const SORT_METHOD = new RegExp(`\\.sort${CALLBACK_GET_2_IDENTIFIERS}${GET_EOL}`, "g");
// $1 eol
const EACH_METHOD = new RegExp(`.each${CALLBACK_BEGIN}${GET_EOL}`, "g");
// no $, just for replaceing by a method
const CAST_INT = new RegExp(`\\(int\\)`, "g");
class Converter {
    constructor(groovyCode) {
        this.buf = groovyCode;
    }
    convertClosure() {
        this.buf = this.buf.replace(CLOSURE, "let $1 = (it) => {$2");
        return this;
    }
    convertDef() {
        this.buf = this.buf.replace(DEF_VARIABLE, "let ");
        return this;
    }
    convertMultiLine() {
        this.buf = this.buf.replace(MULTI_LINE, "`");
        return this;
    }
    addPrimitives() {
        this.buf = Object.values(gamePrimitives).reduce((buf, primitive) => `${primitive}\n${buf}`, this.buf);
        return this;
    }
    augmentations() {
        this.buf = `
${augmentations_1.augmentations.toString()}
${augmentations_1.augmentify.toString()}
augmentations();
augmentify(session);
augmentify(param);
augmentify(constants);
${this.buf}\n`;
        return this;
    }
    replaceStarShip() {
        this.buf = this.buf.replace(STARSHIP_OPERATOR, "spaceshipOperator($1, $2)");
        return this;
    }
    replaceMethods() {
        this.buf = this.buf
            .replace(SIZE_METHOD, ".length")
            .replace(CONTAINSKEY_METHOD, ".hasOwnProperty")
            .replace(SORT_METHOD, ".sort(($1,$2) => {$3")
            .replace(EACH_METHOD, ".forEach((it) => {$1")
            .replace(CAST_INT, "parseInt");
        return this;
    }
    addCall() {
        this.buf = `function theCodeToExecute() {\n ${this.buf} };\ntheCodeToExecute();\n`;
        return this;
    }
    /**
     * Convert the current groovy script to javascript script.
     */
    convert() {
        this.addPrimitives()
            .augmentations()
            .convertClosure()
            .convertDef()
            .convertMultiLine()
            .replaceStarShip()
            .replaceMethods()
            .addCall();
        return this.buf;
    }
}
exports.Converter = Converter;
class GroovyToJS {
    constructor() { }
    /**
     * Returns a Node"VM that abble to run the given groovy script.
     * @param groovyCode the groovy code that will be executed
     * @param groovyCodeName Used as fileName in the stack trace case of execution error
     */
    getVM(groovyCode, groovyCodeName) {
        const jsCode = this.groovyToJs(groovyCode);
        return new vm.Script(jsCode, {
            filename: groovyCodeName,
            displayErrors: true,
        });
    }
    /** Execute a given Node VM and returns
     * By default, uses the primitve method defined in src/primitives. To overdide a primitive
     * set the overdide in the context:
     * ```
     * executeVM(script, {payAmount: () => { return 1; }}); // Use this payAmount instead of primitives" payAmount()
     * ```
     * @returns the groovy return code
     */
    execute(context, timeout = 1000000) {
        const actualContext = Object.assign({
            events: [],
            param: undefined,
            session: undefined,
        }, context, {
            Array,
            player: player_1.Player.getInstance(),
            fs,
            stdout: helpers_1.stdout,
            console,
        });
        const sandbox = vm.createContext(actualContext);
        return this.vm.runInContext(sandbox, { timeout });
    }
    /** Parse the groovy code to generate a javascript code */
    groovyToJs(groovyCode) {
        const converter = new Converter(groovyCode);
        return converter.convert();
    }
    /**
     * Create.
     * @param groovyCode
     * @param groovyCodeName
     */
    static create(groovyCode, groovyCodeName) {
        const instance = new GroovyToJS();
        instance.vm = instance.getVM(groovyCode, groovyCodeName);
        return instance;
    }
}
exports.GroovyToJS = GroovyToJS;
//# sourceMappingURL=toJs.js.map