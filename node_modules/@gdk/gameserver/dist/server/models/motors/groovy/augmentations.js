"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.augmentify = exports.augmentations = void 0;
function augmentations() {
    /**
     * Arrays
     */
    const arrayProtos = [Object.getPrototypeOf([]), Array.prototype];
    for (const proto of arrayProtos) {
        /**
         * Add contains in Array prototype which returns "true"
         * when the array contains the given value
         */
        proto.contains = function (value) {
            const index = this.indexOf(value);
            return index !== -1;
        };
        /**
         * Adds a new value, equivalent to "push"
         */
        proto.add = function (value) {
            this.push(value);
            return this.length - 1;
        };
        /**
         * @param indexOrValue
         * Remove first matching value (or value at index) from an array, modifies the original array
         *  - if indexOrValue is an integer : returns the removedValue if any were removed, false otherwise
         *  - if indexOrValue is not an integer : returns true if any value was removed, false otherwise
         */
        proto.remove = function (indexOrValue) {
            if (Number.isInteger(indexOrValue)) {
                // index
                if (indexOrValue >= this.length) {
                    throw new Error(`wrong index in Array.remove: ${indexOrValue} for an array of length ${this.length}`);
                }
                return this.splice(indexOrValue, 1)[0];
            }
            else {
                // value
                const index = this.indexOf(indexOrValue);
                if (index !== -1) {
                    this.splice(index, 1);
                    return true;
                }
                else {
                    return false;
                }
            }
        };
        /**
         * @param value
         * Remove all matching value from an array, return true if any where removed, false otherwise and modify the original array
         */
        proto.removeAll = function (value) {
            let index;
            let result = false;
            while ((index = this.indexOf(value)) !== -1) {
                this.splice(index, 1);
                result = true;
            }
            return result;
        };
        /**
         * Returns a sliced array with the 'value' first element of the array
         */
        proto.take = function (value) {
            return this.slice(0, value);
        };
        /**
         * Returns a sliced array without the 'value' first element of the array
         */
        proto.drop = function (value) {
            return this.slice(value);
        };
        /**
         * Returns the intersection of two arrays
         */
        proto.intersect = function (array) {
            const res = [];
            for (const each of this) {
                if (array.indexOf(each) > -1) {
                    res.push(each);
                }
            }
            return res;
        };
        /**
         * Test arrays equality
         */
        proto.equals = function (array) {
            if (this === array) {
                return true;
            }
            if (this == null || array == null) {
                return false;
            }
            if (this.length !== array.length) {
                return false;
            }
            for (let i = 0; i < this.length; i++) {
                if (this[i] !== array[i]) {
                    return false;
                }
            }
            return true;
        };
        /**
         * Return an array without duplicates
         * It modifies the array itself unless called with param false
         */
        proto.unique = function (bool = true) {
            if (bool === false) {
                // does not modify original object
                return this.filter((v, i, a) => a.indexOf(v) === i);
            }
            else {
                const unique = this.filter((v, i, a) => a.indexOf(v) === i);
                this.splice(0, this.length, ...unique);
                return this;
            }
        };
        /**
         * makes a copy of an array of primitive type
         */
        proto.clone = function () {
            return this.slice();
        };
    }
    /**
     * Object
     */
    const objectProtos = [Object.getPrototypeOf({}), Object.prototype];
    for (const proto of objectProtos) {
        proto.clone = function () {
            return Object.assign({}, this);
        };
    }
    /**
     * Strings
     */
    /**
     * Returns a sliced string with the 'value' first element of the string
     */
    String.prototype.take = function (value) {
        return this.slice(0, value);
    };
    function toInteger() {
        return parseInt(String(this), 10);
    }
    /**
     * Convert a string to integer
     */
    String.prototype.toInteger = toInteger;
    /**
     * Convert a float to integer
     */
    Number.prototype.toInteger = toInteger;
}
exports.augmentations = augmentations;
function augmentify(obj) {
    if (Array.isArray(obj)) {
        Object.setPrototypeOf(obj, Object.getPrototypeOf([]));
    }
    else if (typeof obj === "string") {
        Object.setPrototypeOf(obj, String.prototype);
        return;
    }
    else if (typeof obj === "object") {
        if (Object.getPrototypeOf(obj).clone === undefined) {
            Object.setPrototypeOf(obj, Object.getPrototypeOf(new Object()));
        }
        else {
            return;
        }
    }
    for (const thing in obj) {
        if (!obj.hasOwnProperty(thing)) {
            continue;
        }
        augmentify(obj[thing]);
    }
}
exports.augmentify = augmentify;
//# sourceMappingURL=augmentations.js.map