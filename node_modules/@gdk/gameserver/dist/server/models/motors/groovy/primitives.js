"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.notify = exports.formatCurrency = exports.currency = exports.formatDate = exports.logDebug = exports.rand = exports.shuffle2 = exports.shuffle = exports.resetUniver = exports.removeUniver = exports.payAmount = exports.setCurrentGain = exports.sampleWReplacement = exports.sampleWoutReplacement = exports.multipleSampleWReplacement = exports.multipleSampleWoutReplacement = exports.addInResult = exports.sendError = exports.spaceshipOperator = exports.addUniver = exports.UniversData = exports.getUniverse = void 0;
function getUniverse(univerId, nbSample = 0) {
    const univerInstance = gameSession.univerInstances.find((ui) => ui.id === univerId);
    if (!univerInstance) {
        throw new Error(`Univer instance named "${univerId}" not found (multipleSampleWoutReplacement)`);
    }
    if (nbSample > univerInstance.data.totalWeight()) {
        throw new Error(`Univer instance has "${univerInstance.data.totalWeight()}" elements, you requested "${nbSample}"`);
    }
    return univerInstance;
}
exports.getUniverse = getUniverse;
var universeData_1 = require("../universeData");
Object.defineProperty(exports, "UniversData", { enumerable: true, get: function () { return universeData_1.UniversData; } });
function addUniver(name, data) {
    // eval prevents typescript to use the name of UniverseData defined outside the VM
    // typically UniverseData becomes "universeData_1"
    const universData = eval("new UniversData()");
    for (const value of data) {
        universData.add({
            value,
            weight: 1,
            originalWeight: 1,
        });
    }
    const univers = {
        id: name,
        name,
        type: "weight",
        data: universData,
    };
    gameSession.univerInstances.push(univers);
}
exports.addUniver = addUniver;
/** Aims to replace groovy <=> operator */
function spaceshipOperator(a, b) {
    if (a < b) {
        return -1;
    }
    if (a == b) {
        return 0;
    }
    return 1;
}
exports.spaceshipOperator = spaceshipOperator;
function sendError(code, msg) {
    throw new Error(`Error occured code ${code}: ${msg}`);
}
exports.sendError = sendError;
function addInResult(key, value) {
    if (key.length > 3 || key.length === 0) {
        throw new Error(`Cannot add in result the key ${key} with value "${value}". Key length must be in inverval [1, 3]`);
    }
    sessionResults[key] = value;
}
exports.addInResult = addInResult;
function multipleSampleWoutReplacement(univerId, nbSample) {
    const univerInstance = getUniverse(univerId, nbSample);
    const result = [];
    for (let i = 0; i < nbSample; i++) {
        result.push(univerInstance.data.pull(mocks.getNextMockValue(gameSession.gameId)));
    }
    return result;
}
exports.multipleSampleWoutReplacement = multipleSampleWoutReplacement;
function multipleSampleWReplacement(univerId, nbSample) {
    const univerInstance = getUniverse(univerId, nbSample);
    const result = [];
    for (let i = 0; i < nbSample; i++) {
        result.push(univerInstance.data.get(mocks.getNextMockValue(gameSession.gameId)));
    }
    return result;
}
exports.multipleSampleWReplacement = multipleSampleWReplacement;
function sampleWoutReplacement(univerId) {
    const univerInstance = getUniverse(univerId, 1);
    return univerInstance.data.pull(mocks.getNextMockValue(gameSession.gameId));
}
exports.sampleWoutReplacement = sampleWoutReplacement;
function sampleWReplacement(univerId) {
    const univerInstance = getUniverse(univerId, 1);
    return univerInstance.data.get(mocks.getNextMockValue(gameSession.gameId));
}
exports.sampleWReplacement = sampleWReplacement;
function setCurrentGain(_amount) {
    // This primitive does not have a direct impact on session.
}
exports.setCurrentGain = setCurrentGain;
function payAmount(amount = 0) {
    // When payAmount is called, messages response field contains the cashier action
    player.amount += amount;
    gameSession.messages.push("NO_ACTION");
    gameSession.wonAmount = {
        value: amount,
        currency: gameSession.amountCurrency,
    };
}
exports.payAmount = payAmount;
function removeUniver(univerId) {
    // Remove instance
    for (let i = 0; i < gameSession.univerInstances.length; i++) {
        const univer = gameSession.univerInstances[i];
        if (univer.id === univerId) {
            gameSession.univerInstances.splice(i, 1);
            break;
        }
    }
}
exports.removeUniver = removeUniver;
/* reset univers instance to initial values */
function resetUniver(univerId) {
    const univerInstance = getUniverse(univerId, 0);
    univerInstance.data.reset();
}
exports.resetUniver = resetUniver;
/* shuffle won"t consume the mocks */
function shuffle(data) {
    throw new Error("shuffle is deprecated, use shuffle2");
}
exports.shuffle = shuffle;
/* shuffle won"t consume the mocks */
function shuffle2(data) {
    const newArray = data.slice(0, data.length);
    for (let i = newArray.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
    }
    return newArray;
}
exports.shuffle2 = shuffle2;
/* rand must consume the mocks */
function rand(min, max) {
    const mockValue = mocks.getNextMockValue(gameSession.gameId);
    return mockValue !== undefined ? min + mockValue : min + Math.floor(Math.random() * (max - min));
}
exports.rand = rand;
function logDebug(message) {
    stdout(`Log Debug from motors: ${message}`);
}
exports.logDebug = logDebug;
function formatDate(dateTime) {
    const dateObject = new Date(dateTime);
    return dateObject.toLocaleString("en-US");
}
exports.formatDate = formatDate;
function currency() {
    return gameSession.amountCurrency;
}
exports.currency = currency;
function formatCurrency(amount, currencyCode) {
    const displayCurrency = currencyCode;
    return `${amount} ${displayCurrency}`;
}
exports.formatCurrency = formatCurrency;
/**
 * Notify function of gamification
 *
 * @access public
 * @param {string} eventName, The event name
 * @param {any} value, The event data
 */
function notify(eventName, value) {
    stdout(`Event notified with name : ${eventName}`);
    if (session.gamificationContextMap.filePath && session.gamificationContextMap.code) {
        const sessionFile = JSON.parse(fs.readFileSync(session.gamificationContextMap.filePath.toString()));
        eval(session.gamificationContextMap.code);
        fs.writeFileSync(session.gamificationContextMap.filePath, JSON.stringify(sessionFile, null, "\t"));
    }
}
exports.notify = notify;
//# sourceMappingURL=primitives.js.map