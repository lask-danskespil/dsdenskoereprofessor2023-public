"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const toJs_1 = require("../groovy/toJs");
class Transition {
    constructor(xmlSnippet, gameModel) {
        this.xmlSnippet = xmlSnippet;
        this.gameModel = gameModel;
    }
    /**
     * Check if has trigger.
     */
    hasTrigger() {
        return this.xmlSnippet.$.trigger !== undefined;
    }
    /**
     * Trigger.
     * @param params
     */
    async trigger(params) {
        const code = this.gameModel.getTrigger(this.xmlSnippet.$.trigger)._;
        if (!code) {
            return true;
        }
        const vm = toJs_1.GroovyToJS.create(code, this.xmlSnippet.$.trigger);
        return vm.execute(params);
    }
    /**
     * Do Action.
     * @param params
     */
    async action(params) {
        const action = this.gameModel.getAction(this.xmlSnippet.$.action);
        if (!action) {
            return this.xmlSnippet.$.to;
        }
        const code = action._;
        if (code) {
            const vm = toJs_1.GroovyToJS.create(code, this.xmlSnippet.$.name);
            vm.execute(params);
        }
        return this.xmlSnippet.$.to;
    }
    /**
     * To.
     */
    get to() {
        return this.xmlSnippet.$.to;
    }
    /**
     * Find transition.
     * @param transitions
     * @param params
     */
    static async findTransition(transitions, params) {
        for (const trans of transitions) {
            if (!trans.hasTrigger() || (await trans.trigger(params))) {
                return trans;
            }
        }
        return undefined;
    }
    /**
     * Get event transition.
     * @param gameModel
     * @param xmlSnippet
     * @param event
     * @param params
     */
    static async getEventTransition(gameModel, xmlSnippet, event, params) {
        const transitionList = Transition.mapTransitions(gameModel, xmlSnippet, event);
        return await Transition.findTransition(transitionList, params);
    }
    /**
     * Get decision transition.
     * @param gameModel
     * @param decisionXmlSnippet
     * @param params
     */
    static async getDecisionTransition(gameModel, decisionXmlSnippet, params) {
        const transitions = Transition.mapTransitions(gameModel, decisionXmlSnippet);
        return await Transition.findTransition(transitions, params);
    }
    /**
     * Map transitions.
     * @param gameModel
     * @param xmlSnippet
     * @param event
     */
    static mapTransitions(gameModel, xmlSnippet, event) {
        let transitionList = xmlSnippet.TransitionList[0].Transition;
        if (event) {
            transitionList = transitionList.filter((transition) => {
                // Motors specs, event and name cannot be same string. Then, we can use the "OR"
                return transition.$.event === event || transition.$.name === event;
            });
        }
        return transitionList.map((transition) => new Transition(transition, gameModel));
    }
}
exports.default = Transition;
//# sourceMappingURL=transition.js.map