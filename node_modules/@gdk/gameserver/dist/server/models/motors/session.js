"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.saveSession = exports.getEvent2 = exports.getEvent = exports.updateGameSession = exports.createGameSession = exports.getGameSession = exports.stateMachineDo = exports.stateMachineInit = exports.generateSession = exports.findBetAmount = exports.createSession = exports.getSessionById = exports.getSession = exports.onEvent = void 0;
const v8_1 = require("v8");
const _ = __importStar(require("lodash"));
const helpers_1 = require("./helpers");
const gameModel_1 = __importDefault(require("./tools/gameModel"));
const errors = __importStar(require("../errors"));
const prsContext_1 = __importDefault(require("./tools/prsContext"));
const universe_1 = __importDefault(require("./tools/universe"));
const universeData_1 = require("./universeData");
const stateMachine_1 = __importDefault(require("./tools/stateMachine"));
async function onEvent(event, gamifSessionManager, gameSessionDB) {
    let gameSession;
    let gamifSession;
    try {
        gameSession = await getGameSession(gameSessionDB, event.sessionId, event.gameName);
        gamifSession = gamifSessionManager.get(event.gameName);
        await stateMachineDo(event.eventName, event.sessionId, event.stateMachineParams, gameSession, gamifSession);
        await updateGameSession(gameSessionDB, gameSession, event);
        gameSession.steps.push({
            dat: new Date().getTime(),
            nam: event.eventName,
            par: (0, v8_1.deserialize)((0, v8_1.serialize)(event.stateMachineParams.prm)),
            st: (0, v8_1.deserialize)((0, v8_1.serialize)(gameSession.state)),
            res: (0, v8_1.deserialize)((0, v8_1.serialize)(event.stateMachineParams.results)),
        });
        return gameSession;
    }
    catch (up) {
        const message = (0, helpers_1.getMotorsErrorMessage)(up);
        if (event && gameSession) {
            event.stateMachineParams.results.msg = Array.isArray(message) ? message.join(",") : message;
            await updateGameSession(gameSessionDB, gameSession, event);
        }
        throw new Error(message);
    }
}
exports.onEvent = onEvent;
async function getSession(gameSessionDB, motorsScriptManager, serviceName) {
    const gameDB = motorsScriptManager.get(serviceName);
    const gameSession = gameSessionDB.get((session) => session.gameId === gameDB._id && session.state !== "final");
    if (!gameSession) {
        return null;
    }
    const gameModel = await gameModel_1.default.get(gameSession.manifestFilePath);
    let stateMachine = stateMachine_1.default.get(gameSession._id);
    if (!stateMachine) {
        stateMachine = new stateMachine_1.default(gameModel);
        stateMachine.setState(gameSession.state);
        stateMachine_1.default.set(stateMachine, gameSession._id);
    }
    return gameSession;
}
exports.getSession = getSession;
async function getSessionById(gameSessionDB, motorsScriptManager, serviceName, sessionId) {
    const gameDB = motorsScriptManager.get(serviceName);
    const gameSession = gameSessionDB.get((session) => session.gameId === gameDB._id && session._id === sessionId);
    if (!gameSession) {
        return null;
    }
    const gameModel = await gameModel_1.default.get(gameSession.manifestFilePath);
    let stateMachine = stateMachine_1.default.get(gameSession._id);
    if (!stateMachine) {
        stateMachine = new stateMachine_1.default(gameModel);
        stateMachine.setState(gameSession.state);
        stateMachine_1.default.set(stateMachine, gameSession._id);
    }
    return gameSession;
}
exports.getSessionById = getSessionById;
async function createSession(gameSessionDB, motorsScriptManager, gamifSessionManager, data, token) {
    let gameSession;
    let gamifSession;
    try {
        const script = motorsScriptManager.get(data.serviceName);
        const gameModel = await gameModel_1.default.get(script.manifestFilePath);
        const prsTicketInfo = await prsContext_1.default.get(script.manifestFilePath, token);
        data.stateMachineParams.data.prm = {};
        if (prsTicketInfo !== null) {
            if (prsTicketInfo.status === "DRAWN" && prsTicketInfo.token !== "default-token") {
                throw new Error(`presto token "${prsTicketInfo.token}" has already been used, use a different token or restart your gameserver.`);
            }
            prsTicketInfo.status = "DRAWN";
            data.stateMachineParams.data.prm.prsContext = prsTicketInfo.info;
        }
        findBetAmount(gameModel, data);
        gameSession = generateSession(script, gameModel, data);
        gamifSession = gamifSessionManager.get(data.serviceName);
        await stateMachineInit(gameModel, data, gameSession, gamifSession);
        await createGameSession(gameSessionDB, gameSession, data);
        gameSession.steps.push({
            dat: new Date().getTime(),
            nam: "init",
            par: (0, v8_1.deserialize)((0, v8_1.serialize)(data.stateMachineParams.prm)),
            st: (0, v8_1.deserialize)((0, v8_1.serialize)(gameSession.state)),
            res: (0, v8_1.deserialize)((0, v8_1.serialize)(gameSession.data)),
        });
        return gameSession;
    }
    catch (up) {
        const message = (0, helpers_1.getMotorsErrorMessage)(up);
        if (data && gameSession) {
            data.stateMachineParams.results.msg = message;
            createGameSession(gameSessionDB, gameSession, data);
        }
        throw new Error(message);
    }
}
exports.createSession = createSession;
function findBetAmount(gameModel, data) {
    const betAmount = gameModel.getBetAmount(data.bet, data.amountCurrency);
    if (betAmount === undefined) {
        throw new errors.DataException(`Unable to find a bet for the amount ${data.bet} with currency ${data.amountCurrency}`, errors.BET_NOT_FOUND);
    }
}
exports.findBetAmount = findBetAmount;
function generateSession(script, gameModel, data) {
    const universe = new universe_1.default(gameModel);
    return {
        _id: Date.now().toString(),
        bet: data.bet,
        amountCurrency: data.amountCurrency,
        gameId: script._id,
        state: undefined,
        data: gameModel.session,
        manifestFilePath: script.manifestFilePath,
        univerInstances: universe.createInstances(),
        messages: [],
        events: [],
        steps: [],
        demoMode: data.demoMode,
    };
}
exports.generateSession = generateSession;
async function stateMachineInit(gameModel, data, gameSession, gamifSession) {
    const stateMachine = new stateMachine_1.default(gameModel);
    data.stateMachineParams.prm = data.stateMachineParams.data.prm;
    delete data.stateMachineParams.data.prm;
    try {
        await stateMachine.doInit(gameSession, gamifSession, data.stateMachineParams);
        // Store state machine only when initialisation is sucessfull
        stateMachine_1.default.set(stateMachine, gameSession._id);
    }
    finally {
        // we need to update session state even uin case of error
        gameSession.state = stateMachine.state;
    }
}
exports.stateMachineInit = stateMachineInit;
async function stateMachineDo(eventName, sessionID, stateMachineParams, gameSession, gamifSession) {
    const stateMachine = stateMachine_1.default.get(sessionID);
    if (!stateMachine) {
        throw new errors.DataException(`unable to find statemachine ${sessionID}`, errors.GAME_EXECUTION);
    }
    try {
        await stateMachine.on(eventName, gameSession, gamifSession, stateMachineParams);
    }
    finally {
        // !! Even in case of error we need to update session state and to register an event
        gameSession.state = stateMachine.state;
    }
}
exports.stateMachineDo = stateMachineDo;
async function getGameSession(gameSessionDB, sessionID, gameName) {
    const gameSession = gameSessionDB.get((session) => session._id === sessionID);
    if (!gameSession) {
        throw new errors.DataException(`game not found: ${gameName}`, errors.SESSION_NOT_FOUND);
    }
    if (gameSession.univerInstances) {
        gameSession.univerInstances.forEach((univers) => {
            univers.data = new universeData_1.UniversData(univers.data);
        });
    }
    await gameModel_1.default.get(gameSession.manifestFilePath); // must have this to throw an error when model is not accesible
    return gameSession;
}
exports.getGameSession = getGameSession;
function createGameSession(gameSessionDB, gameSession, data) {
    const event = getEvent(data.stateMachineParams);
    gameSession.events.push(event);
    return gameSessionDB.add(gameSession);
}
exports.createGameSession = createGameSession;
function updateGameSession(gameSessionDB, gameSession, data) {
    const event = getEvent2(data.eventName, data.stateMachineParams);
    gameSession.events.push(event);
    return saveSession(gameSessionDB, gameSession);
}
exports.updateGameSession = updateGameSession;
function getEvent(stateMachineParams) {
    const eventParams = _.cloneDeep(stateMachineParams.prm);
    const eventResponse = stateMachineParams.results;
    return {
        dateOfEvent: Date.now(),
        eventName: "init",
        eventParams,
        eventResponse,
    };
}
exports.getEvent = getEvent;
function getEvent2(eventName, stateMachineParams) {
    const eventParams = _.cloneDeep(stateMachineParams.prm);
    const eventResponse = _.cloneDeep(stateMachineParams.results);
    return {
        dateOfEvent: Date.now(),
        eventName,
        eventParams,
        eventResponse,
    };
}
exports.getEvent2 = getEvent2;
function saveSession(gameSessionDB, gameSession) {
    return gameSessionDB.update(gameSession._id, {
        data: gameSession.data,
        univerInstances: gameSession.univerInstances,
        state: gameSession.state,
        events: gameSession.events,
        messages: gameSession.messages,
    });
}
exports.saveSession = saveSession;
//# sourceMappingURL=session.js.map