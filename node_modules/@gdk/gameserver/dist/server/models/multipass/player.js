"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Player = void 0;
const lodash_1 = __importDefault(require("lodash"));
const player_1 = require("../player");
const person_1 = require("./person");
const models_1 = require("./models");
const error_1 = require("./error");
class Player extends person_1.Person {
    /**
     * Constructor
     * @param person person reference being a new player
     */
    constructor(person) {
        super(person.id, person.room, person.channel);
        this.protected = {
            id: person.id,
            bet: null,
        };
        this.public = {};
        this.private = {};
    }
    /**
     * The player executes an action
     * @param eventName the name of the event
     * @param data the data in the execute request
     */
    execute(eventName, data) {
        this.room.gameEngine.isLocked =
            this.room.lockPolicy === models_1.ELockPolicy.ACTION_ONLY || this.room.lockPolicy === models_1.ELockPolicy.ALL;
        this.room.gameEngine.emit("gameEvent", {
            type: "gameEvent",
            eventName,
            playerId: this.id,
            eventData: data,
            session: this.room.currentSession.getSessionForScript(),
        });
    }
    /**
     * The player leaves the room
     */
    cancelBet() {
        if (this.room.gameEngine.state !== models_1.EGameState.PENDING) {
            throw new error_1.MTPError("Cannot cancel bet while the session is running or completed");
        }
        const player = lodash_1.default.find(this.room.currentSession.players, (p) => p.id === this.id);
        if (player) {
            // Emit that the player is leaving
            this.room.gameEngine.emit("playerLeaving", {
                type: "playerLeaving",
                playerId: this.id,
                session: this.room.currentSession.getSessionForScript(),
            });
            // Re-give purse
            player_1.Player.getInstance(this.id).updatePurseWithWin(player.protected.bet);
        }
    }
    /**
     * Returns full json of the player
     * @param playerId the id of the player
     */
    toFullJson(playerId) {
        if (playerId === undefined) {
            return {
                id: this.id,
                private: this.private,
                public: this.public,
                protected: this.protected,
            };
        }
        if (playerId === this.id) {
            return {
                id: this.id,
                public: this.public,
                protected: this.protected,
            };
        }
        return {
            id: this.id,
            public: this.public,
        };
    }
    // Static methods
    /**
     * Returns the player"s id from the request (referrer or whatever)
     * @param request the request containing the player Id
     */
    static getPlayerId(request) {
        const id = player_1.Player.getPlayerId(request);
        if (!id) {
            throw new error_1.MTPError("Cannot identify player. Try setting your URL localhost:port/?playerId=myId");
        }
        return id;
    }
}
exports.Player = Player;
//# sourceMappingURL=player.js.map