"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultipassManager = void 0;
const lodash_1 = __importDefault(require("lodash"));
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
const error_1 = require("./error");
const mtpGame_1 = require("./mtpGame");
class MultipassManager {
    constructor() {
        this._multipassConfirations = {};
        this._gamesMap = {};
    }
    /**
     * Get a game given its variantName
     * @param gameVariantName
     */
    async get(gameVariantName) {
        if (!this._gamesMap[gameVariantName]) {
            const folderPath = this._findConfigurationByGameVariantName(gameVariantName);
            const game = new mtpGame_1.MtpGame(gameVariantName, folderPath);
            await game.load();
            this._gamesMap[gameVariantName] = game;
        }
        return this._gamesMap[gameVariantName];
    }
    /**
     * Get a room by its roomId
     * Throws an MTPError if room not found
     * @param roomId
     */
    getRoomById(roomId) {
        let rooms = [];
        lodash_1.default.each(this._gamesMap, (g) => (rooms = rooms.concat(g.rooms)));
        const room = lodash_1.default.find(rooms, { id: roomId });
        if (!room) {
            throw new error_1.MTPError(`room ${roomId} not found`);
        }
        return room;
    }
    /**
     * Get a session given sessionId
     * Throws an MTPError if session not found
     * @param roomId
     */
    getSessionById(sessionId) {
        let rooms = [];
        lodash_1.default.each(this._gamesMap, (g) => (rooms = rooms.concat(g.rooms)));
        const room = lodash_1.default.find(rooms, (r) => r.currentSession.id === sessionId);
        if (!room) {
            throw new error_1.MTPError(`session ${sessionId} not found`);
        }
        return room.currentSession;
    }
    /**
     * Returns list of sessions of a game.
     * @param gameVariantName
     */
    async listSessions(gameVariantName) {
        const game = await this.get(gameVariantName);
        return game.sessions.map((s) => ({
            id: s.id,
            status: s.state,
            players: s.players.length,
            roomId: s.room.id,
        }));
    }
    /**
     * Get details of a game's session.
     * @param gameVariantName
     * @param sessionId
     */
    async getGameSessionDetails(gameVariantName, sessionId) {
        const game = await this.get(gameVariantName);
        const session = game.sessions.find((s) => s.id === sessionId);
        if (!session) {
            throw new error_1.MTPError(`session with id ${sessionId} does not exist on game variant ${gameVariantName}`);
        }
        return session.toHistory();
    }
    /**
     * Filters the given rooms array to return only rooms of the given player
     * @param rooms the rooms array to filter
     * @param playerId the player id to find
     */
    filterByPlayerId(rooms, playerId) {
        if (!playerId) {
            return rooms;
        }
        return rooms.filter((r) => r.people.find((p) => p.id === playerId));
    }
    /**
     * Inserts the given multipass configuration into the DB
     * @param config the multipass config containing paths to the files
     * @returns Promise<IMultipassConfiguration> added configuration
     */
    async addConfiguration(configurationPath) {
        const configuration = await (0, fs_extra_1.readJSON)(configurationPath);
        const configurationDirectory = (0, path_1.dirname)(configurationPath);
        [
            "scriptFilePath",
            "historyFilePath",
            "parametersFilePath",
            "variantParametersFilePath",
            "declarationFilePath",
        ].forEach((key) => {
            configuration[key] = (0, path_1.resolve)(configurationDirectory, configuration[key]);
        });
        this._multipassConfirations[configuration.gameVariantName] = configuration;
        return configuration;
    }
    /**
     * Finds an existing (or not) multipass configuration in the DB
     * @param gameVariantName the variant name to find
     */
    _findConfigurationByGameVariantName(gameVariantName) {
        return this._multipassConfirations[gameVariantName];
    }
}
exports.MultipassManager = MultipassManager;
//# sourceMappingURL=multipassManager.js.map