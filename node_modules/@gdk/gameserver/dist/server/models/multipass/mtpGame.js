"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MtpGame = void 0;
const fs_extra_1 = require("fs-extra");
const lodash_1 = __importDefault(require("lodash"));
const room_1 = require("./room");
const error_1 = require("./error");
class MtpGame {
    /**
     * Constructor of an MTPGame
     * @param gameVariantName
     * @param folderPath
     */
    constructor(gameVariantName, folderPath) {
        this.content = null;
        this.historyScript = null;
        this.parameters = null;
        this.variantParameters = null;
        this.declaration = null;
        this.rooms = [];
        this.sessions = [];
        this.gameVariantName = gameVariantName;
        this.folderPath = folderPath;
        this.rooms = [];
    }
    /**
     * Load or reload an MTPGame
     * Will load script an parameters from disk and reset all engine
     */
    async load() {
        // Reload content and parameters
        try {
            this.content = await (0, fs_extra_1.readFile)(this.folderPath.scriptFilePath, { encoding: "utf-8" });
        }
        catch (e) {
            throw new error_1.MTPError(`Cannot read script file "${this.folderPath.scriptFilePath}". Error: ${e.message}`);
        }
        try {
            this.historyScript = await (0, fs_extra_1.readFile)(this.folderPath.historyFilePath, { encoding: "utf-8" });
        }
        catch (e) {
            throw new error_1.MTPError(`Cannot read history file "${this.folderPath.historyFilePath}". Error: ${e.message}`);
        }
        this.parameters = await this._requireParametersJson(this.folderPath.parametersFilePath);
        // TODO: validate against schema
        this.variantParameters = await this._requireParametersJson(this.folderPath.variantParametersFilePath);
        // TODO: validate against schema
        this.declaration = await this._requireParametersJson(this.folderPath.declarationFilePath);
        // TODO: validate against schema
        this.minPlayers = this.variantParameters.minPlayers;
        this.maxPlayers = this.variantParameters.maxPlayers;
        this.bets = this.variantParameters.bets.map((b, index) => {
            return {
                id: `${index}`,
                ranges: b,
            };
        });
        delete this.variantParameters.minPlayers;
        delete this.variantParameters.maxPlayers;
    }
    /**
     * Get game parameters
     */
    getScriptVariant() {
        return {
            minPlayers: this.minPlayers,
            maxPlayers: this.maxPlayers,
            betLevelList: this.bets,
            content: this.variantParameters.parameters,
            gameVariantExternalId: this.gameVariantName,
        };
    }
    /** Close a room (delete it)
     * @param roomId the id of the room
     */
    close(roomId) {
        // Try to get room first
        const room = this.getRoomById(roomId);
        room.close();
        lodash_1.default.remove(room.game.rooms, (r) => r.id === roomId);
    }
    /**
     * Creates a new room
     * @param betLevelId for the room to create
     */
    async createRoom(betLevelId, debug = false) {
        // Create room and register room
        const room = new room_1.Room(this, betLevelId, debug);
        this.rooms.push(room);
        room.restart();
        return room;
    }
    /**
     * Get a list of rooms matching criteria
     * @param bet the bet attached to the rooms to find
     */
    getRooms(betLevelId) {
        return this.rooms.filter((r) => {
            if (!lodash_1.default.isUndefined(betLevelId) && betLevelId !== r.betLevelId) {
                return false;
            }
            return true;
        });
    }
    /**
     * Get a room matching criteria
     * throw if no matching room exists
     * @param betLevelId attached to the room to find
     * @param onlyNonFull optionnal boolean if true, returns only non full room
     */
    getRoom(betLevelId, onlyNonFull = false) {
        let rooms;
        if (!this.rooms || this.rooms.length === 0) {
            throw new error_1.MTPError(`No room created for ${this.gameVariantName}, please create one before`);
        }
        if (!lodash_1.default.isUndefined(betLevelId)) {
            rooms = this.rooms.filter((r) => r.betLevelId === betLevelId);
            if (!rooms.length) {
                throw new error_1.MTPError(`No room found for betLevelId ${betLevelId}`);
            }
        }
        if (onlyNonFull) {
            rooms = rooms.filter((r) => r.people.length < r.game.maxPlayers);
            if (!rooms.length) {
                throw new error_1.MTPError(`No room with space left for betLevelId ${betLevelId}`);
            }
        }
        return lodash_1.default.sample(rooms);
    }
    /**
     * Get a room by id
     * @param roomId the id of the room to get
     */
    getRoomById(roomId) {
        const room = this.rooms.find((r) => r.id === roomId);
        if (!room) {
            throw new error_1.MTPError(`No room found with id ${roomId}`);
        }
        return room;
    }
    /**
     * Requires a JSON parameters file and throws an explicit error
     * if an error occurs when requiring JSON file
     * @param path the path of the JSON
     */
    async _requireParametersJson(path) {
        try {
            return JSON.parse(await (0, fs_extra_1.readFile)(path, { encoding: "utf-8" }));
        }
        catch (e) {
            throw new error_1.MTPError(`Cannot require JSON file "${path}", error: ${e.message}`);
        }
    }
}
exports.MtpGame = MtpGame;
//# sourceMappingURL=mtpGame.js.map