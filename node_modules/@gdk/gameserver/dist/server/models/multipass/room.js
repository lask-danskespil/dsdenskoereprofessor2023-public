"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Room = void 0;
const vm = __importStar(require("vm"));
const uuid_1 = require("uuid");
const lodash_1 = __importDefault(require("lodash"));
const backutils_1 = require("@gdk/backutils");
const gameEngine_1 = require("./engines/gameEngine");
const randomEngine_1 = require("./engines/randomEngine");
const notificationEngine_1 = require("./engines/notificationEngine");
const person_1 = require("./person");
const session_1 = require("./session");
const sseChannel_1 = require("./sseChannel");
const models_1 = require("./models");
const error_1 = require("./error");
class Room {
    /**
     * Constructor
     */
    constructor(game, betLevelId, debug = false) {
        // Room properties
        this.id = (0, uuid_1.v4)();
        this.betLevelId = null;
        this.betLevel = null;
        this.people = []; // observers and players
        // Script properties
        this.vm = null;
        this.currentSession = null;
        this.notificationEngine = new notificationEngine_1.NotificationEngine(this);
        this.gameEngine = null;
        this.randomEngine = null;
        this.game = game;
        this.betLevelId = betLevelId;
        const betLevel = game.bets.find((b) => b.id === betLevelId);
        if (!betLevel) {
            throw new error_1.MTPError(`betLevelId ${betLevelId} not available for ${game.gameVariantName}`, 1);
        }
        this.betLevel = betLevel;
        this.debug = debug;
    }
    /**
     * Validates the given bet. If error, then throw a new MTPError
     * @param bet the bet data to validate
     */
    validateBet(bet, playerId) {
        if (this.currentSession.players.find((p) => p.id === playerId)) {
            throw new error_1.MTPError("Player already bet and in the session");
        }
        if (this.gameEngine.getGameState() !== models_1.EGameState.PENDING) {
            throw new error_1.MTPError("Cannot bet on a room while a session is ongoing or completed");
        }
        if (bet.amount.value < this.betLevel.ranges.min ||
            bet.amount.value > this.betLevel.ranges.max) {
            throw new error_1.MTPError(`invalid bet ${bet.amount.value}${bet.amount.currency} for room ${this.id}`);
        }
    }
    /**
     * Returns th person which has the given id
     * @param personId the id of the person to get
     */
    getPerson(personId) {
        const person = this.people.find((p) => p.id === personId);
        if (!person) {
            throw new error_1.MTPError(`Cannot find person with id ${personId}`);
        }
        return person;
    }
    /**
     * Add a player to a room (adds it to the current session as well)
     * @param personId the id of the person to add in the room
     */
    addPerson(personId) {
        // If player already in the room, do not add
        let person = this.people.find((p) => p.id === personId);
        if (person) {
            throw new error_1.MTPError(`Player with id ${personId} already in the room ${this.id}`);
        }
        if (this.people.length >= this.game.maxPlayers) {
            throw new error_1.MTPError(`the room is ${this.game.maxPlayers} players max`);
        }
        person = new person_1.Person(personId, this, sseChannel_1.SSEChannel.create(this));
        this.people.push(person);
        // Notify people that person joined
        this.notificationEngine.backendNotify(models_1.EPushNotificationType.PLAYER_ENTER, {
            nbPlayers: this.people.length,
        });
        return person;
    }
    /**
     * Remove a player from a room
     * @param personId: the id of the person
     */
    removePerson(personId, force = false) {
        // Refuse leave if in session
        const player = this.currentSession.players.find((p) => p.id === personId);
        if (player && !force) {
            throw new error_1.MTPError(`Can't leave room while in session`);
        }
        const person = this.people.find((p) => p.id === personId);
        if (!person) {
            throw new error_1.MTPError(`Can't leave room, player ${personId} not found`);
        }
        lodash_1.default.remove(this.people, (p) => p.id === personId);
        // Notify person that leaves
        this.notificationEngine.backendNotify(models_1.EPushNotificationType.PLAYER_EXIT, {
            nbPlayers: this.people.length,
        });
        // Notify person that she was removed
        this.notificationEngine.backendNotify(models_1.EPushNotificationType.PLAYER_REMOVED, {
            playerId: person.id,
        }, person.id);
    }
    /**
     * Empties a room
     */
    empty() {
        for (let i = this.people.length - 1; i >= 0; i--) {
            this.removePerson(this.people[i].id, true);
        }
    }
    /**
     * Restarts the room:
     * - re-get script and variants
     * - restart script
     * - empty session and people
     */
    restart() {
        // Clean and run
        this.people = [];
        this.close();
        this.run();
    }
    /**
     * Closes the room
     */
    close() {
        // clear all registered timers
        if (this.gameEngine) {
            Object.keys(this.gameEngine.timersMap).forEach((handle) => this.gameEngine.clearTimeout(handle));
        }
    }
    /**
     * run and retun sessionId
     */
    run() {
        // clear all registered timers
        if (this.gameEngine) {
            Object.keys(this.gameEngine.timersMap).forEach((handle) => this.gameEngine.clearTimeout(handle));
        }
        // Clean before run
        this.notificationEngine = new notificationEngine_1.NotificationEngine(this);
        this.gameEngine = new gameEngine_1.GameEngine(this);
        this.randomEngine = new randomEngine_1.RandomEngine(this);
        // Create VM
        this.vm = new vm.Script(this.game.content, {
            filename: `${this.game.gameVariantName}.js`,
            displayErrors: true,
        });
        // Run VM
        const context = {
            require: (s) => {
                // Instanciate engines, and pass them into the vm context
                // Each engines will have a ref to the room
                switch (s) {
                    case "game-engine":
                        return this.gameEngine;
                    case "random-engine":
                        return this.randomEngine;
                    case "notification-engine":
                        return this.notificationEngine;
                    case "logger":
                        return backutils_1.logger;
                    default:
                        throw new error_1.MTPError(`Unsupported require called from multipass script ${this.game.gameVariantName}`, 500);
                }
            },
        };
        if (this.debug) {
            context.console = console;
        }
        this.vm.runInNewContext(vm.createContext(context), { timeout: 99999999 });
        const peopleToRemove = lodash_1.default.filter(this.people, (p) => p.nbInactiveSession > (this.game.parameters.maxInactiveSession || 3));
        peopleToRemove.forEach((person) => {
            this.removePerson(person.id, true);
        });
        // Init the session and emit event "initialized" once the room is created, stroe session on game for history
        this.currentSession = new session_1.Session(this);
        this.game.sessions.push(this.currentSession);
        this.people.forEach((p) => {
            p.nbInactiveSession++; // increment number of inactive session
        });
        this.gameEngine.isLocked = true;
        this.gameEngine.emit("initialize", {
            type: "initialize",
            session: this.currentSession.getSessionForScript(),
        });
        this.notificationEngine.backendNotify(models_1.EPushNotificationType.SESSION_INITIALIZED, {
            session: this.currentSession.toJson(),
        });
        return this.currentSession.id;
    }
    /**
     * Returns the JSON data of the room
     */
    toJson() {
        return {
            roomId: this.id,
            gameSessionId: this.currentSession.id,
            serviceName: this.game.gameVariantName,
            nbPlayers: this.people.length,
            betLevelId: 0,
        };
    }
    get lockPolicy() {
        return this.game.declaration.gameSessionLockStrategy;
    }
}
exports.Room = Room;
//# sourceMappingURL=room.js.map