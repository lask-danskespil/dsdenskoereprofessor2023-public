"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Session = void 0;
const uuid_1 = require("uuid");
const _ = __importStar(require("lodash"));
const player_1 = require("./player");
const models_1 = require("./models");
const error_1 = require("./error");
class Session {
    /**
     * Constructor
     * @param room the room containing the session
     */
    constructor(room) {
        this.actions = [];
        this.room = room;
        this.id = (0, uuid_1.v4)();
        this.state = models_1.EGameState.PENDING;
        this.private = {};
        this.public = {};
        this.players = [];
        this.mocks = {
            playerMocks: {},
            sessionMocks: [],
        };
        Session.sessionsMap[this.id] = this;
    }
    /**
     * Returns th player which has the given id in the session
     * @param personId the id of the player to get
     */
    getPlayer(playerId) {
        const player = this.players.find((p) => p.id === playerId);
        if (!player) {
            throw new error_1.MTPError(`Cannot find player with id ${playerId}`);
        }
        return player;
    }
    /**
     * Adds the given person to the session"s players
     * @param person the person to add as a player to the session
     */
    addPlayer(person) {
        if (this.players.find((p) => p.id === person.id)) {
            throw new error_1.MTPError(`Can"t add player to session as it already exists`);
        }
        const player = new player_1.Player(person);
        this.players.push(player);
        person.nbInactiveSession = 0; // reset number of inactive session
        this.mocks.playerMocks[player.id] = [];
        return player;
    }
    /**
     * Removes the given player from the session
     * @param player the player to remove
     */
    removePlayer(player) {
        const removed = _.remove(this.players, (p) => p === player);
        if (!removed.length) {
            throw new error_1.MTPError(`Cannot remove player with id ${player.id}`);
        }
        delete this.mocks.playerMocks[player.id];
    }
    /**
     * Returns the session object used by the script
     * a proxy will lock this object for modification in case of a non locked action
     */
    getSessionForScript() {
        const session = {
            public: this.public,
            private: this.private,
            id: this.id,
        };
        if (!this.room.gameEngine.isLocked) {
            const handler = {
                set: (obj, prop, value) => {
                    throw new error_1.MTPError(`Tried to set "${prop}" on session, but can't modify session in a non locked action`);
                },
                get: (obj, prop) => {
                    const value = obj[prop];
                    return value instanceof Object ? new Proxy(value, handler) : value;
                },
            };
            return new Proxy(session, handler);
        }
        else {
            return session;
        }
    }
    /**
     * Returns the session"s data
     * @param playerId the id of the player to get full JSON instead of just public data
     */
    toJson(playerId) {
        const currentPlayer = this.players.find((p) => p.id === playerId);
        const currentPeople = this.room.people.find((p) => p.id === playerId);
        return {
            id: this.id,
            data: {
                time: Date.now(),
                gameSessionState: this.state,
                roomId: this.room.id,
                data: {
                    public: this.public,
                    currentPlayer: currentPlayer ? currentPlayer.toFullJson(playerId) : undefined,
                    players: this.players.map((p) => p.toFullJson(playerId)),
                },
                playerId,
                playerGameSessionId: "empty",
                lastGameSessionNotificationId: currentPeople
                    ? currentPeople.channel.broadcastCount
                    : undefined,
                lastPlayerNotificationId: currentPeople ? currentPeople.channel.privateCount : undefined,
                totalUserInRoom: this.room.people.length,
                totalActivePlayerInRoom: this.players.length,
            },
        };
    }
    /**
     * Returns the session"s data for history purpose
     */
    toHistory() {
        return {
            id: this.id,
            createdTime: 0,
            status: this.state,
            public: this.public,
            private: this.private,
            parameters: this.room.game.parameters,
            variantParameters: this.room.game.variantParameters,
            players: this.players.map((p) => p.toFullJson()),
        };
    }
}
exports.Session = Session;
// Static members
Session.sessionsMap = {};
//# sourceMappingURL=session.js.map