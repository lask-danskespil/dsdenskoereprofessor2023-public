"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RandomEngine = void 0;
const lodash_1 = __importDefault(require("lodash"));
class RandomEngine {
    /**
     * Constructor
     */
    constructor(room) {
        this._room = room;
    }
    /**
     * Get the weight of a weightedValue
     *
     * @param weightedValue
     * @return the weight of the weightedValue
     */
    weight(weightedValue) {
        return weightedValue.weight === undefined ? 1 : weightedValue.weight;
    }
    /**
     * Get the total weight of a weightedValues array
     *
     * @param weightedValues
     * @return the weight of the weightedValue
     */
    // private totalWeight(weightedValues: WeightedValue[]): number {
    // 	return _.sumBy(weightedValues, (v) => this.weight(v));
    // }
    /**
     * Get a random number between 0 and exclusive numberOfElements
     * If a mockValue is passed it will return this value
     *
     * @param numberOfElements
     * @param mockValue
     * @return a random integer between 0 and exclusive numberOfElements (overriden by mockValue if given)
     * It will eventually consume existing mocks if no mockValue is given
     */
    randIndex(numberOfElements, mockValue) {
        if (lodash_1.default.isUndefined(mockValue)) {
            const playerMocks = this._room.currentSession.mocks.playerMocks[this._room.gameEngine.currentPlayerId];
            if (playerMocks && playerMocks.length) {
                mockValue = playerMocks.shift();
            }
            else if (this._room.currentSession.mocks.sessionMocks.length) {
                mockValue = this._room.currentSession.mocks.sessionMocks.shift();
            }
        }
        if (mockValue !== undefined) {
            return mockValue;
        }
        return lodash_1.default.random(numberOfElements - 1);
    }
    /**
     * Range sampling from an interval
     *
     * @param from min value
     * @param to max value
     * @param sampledValues values already sampled. If empty, no values were already sampled ; or the sampling is made with replacement.
     * @return the sampled value
     */
    rangeSampling(from, to, sampledValues) {
        return this.weightSampling(lodash_1.default.range(from, to + 1).map((e) => ({ value: e })), (sampledValues || []).map((e) => ({ value: e })));
    }
    /**
     * Weight sampling from a list of weighted values.
     *
     * @param weightedValues (values, weights) to be sampled from
     * @param sampledValues (values, weights) already sampled. If empty, no values were already sampled ; or the sampling is made with replacement.
     * @return the sampled value
     */
    weightSampling(weightedValues, sampledValues) {
        sampledValues = sampledValues || [];
        const values = [];
        let totalWeight = 0;
        weightedValues.forEach((weightedValue) => {
            const valuesToRemove = lodash_1.default.remove(sampledValues, (sv) => sv.value === weightedValue.value);
            const elementWeight = (weightedValue.weight =
                this.weight(weightedValue) - lodash_1.default.sumBy(valuesToRemove, (v) => this.weight(v)));
            values.push({
                value: weightedValue.value,
                weight: elementWeight,
            });
            totalWeight += elementWeight;
        });
        let index = this.randIndex(totalWeight);
        if (index < 0 || index > totalWeight - 1) {
            throw { message: `wrong index when getting an element from an universe`, code: 500 };
        }
        for (const value of values) {
            index -= value.weight; // we know values have weights here
            if (index < 0) {
                return value.value;
            }
        }
        // unreachable code
        throw {
            message: `wrong index when getting an element from an universe, Should never occurs`,
            code: 500,
        };
    }
    /**
     * Shuffles an array of number
     * The method does not modify the array itself
     *
     * @param values
     * @return the shuffled array
     */
    shuffle(values) {
        return lodash_1.default.shuffle(values);
    }
}
exports.RandomEngine = RandomEngine;
//# sourceMappingURL=randomEngine.js.map