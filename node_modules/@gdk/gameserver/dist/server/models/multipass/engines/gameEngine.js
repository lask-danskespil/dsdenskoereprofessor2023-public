"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GameEngine = void 0;
const lodash_1 = __importDefault(require("lodash"));
const backutils_1 = require("@gdk/backutils");
const player_1 = require("../../player");
const models_1 = require("../models");
const error_1 = require("../error");
class GameEngine {
    /**
     * Constructor
     */
    constructor(room) {
        // Public members
        this.state = models_1.EGameState.PENDING;
        this.isLocked = false;
        this.currentAction = null;
        this.timersMap = {};
        this.listeners = {
            initialize: [],
            playerBet: [],
            playerJoining: [],
            playerLeaving: [],
            gameStarted: [],
            gameEvent: [],
            timerEvent: [],
            gameEnded: [],
        };
        this._room = room;
    }
    /**
     * Emit.
     * @param type
     * @param e
     */
    emit(type, e) {
        if (e.hasOwnProperty("playerId")) {
            this.currentPlayerId = e.playerId;
        }
        else {
            this.currentPlayerId = undefined;
        }
        // @TODO what for ?
        const params = lodash_1.default.cloneDeepWith(e, (value) => (value.private ? null : undefined));
        delete params.session;
        this.currentAction = {
            timestamp: this.getSessionAge(),
            type,
            params,
            notifications: [],
        };
        try {
            this.listeners[type].forEach((f) => {
                f(e);
            });
        }
        catch (e) {
            throw e;
        }
        finally {
            // Action completed, current action is null
            this._room.currentSession.actions.push(this.currentAction);
            this.currentAction = null;
        }
    }
    /**
     * Add an event listener
     * @param type     Event type
     * @param listener Listener
     */
    addEventListener(type, listener) {
        this.listeners[type].push(listener);
    }
    /**
     * Start the game, emits a gameStarted event
     */
    startGame() {
        if (!this.isLocked) {
            throw new error_1.MTPError(`Cannot call "startGame" for non-locked actions`);
        }
        // Change state and notify
        this._room.currentSession.state = this.state = models_1.EGameState.ONGOING;
        // Emit and notify game started
        this.emit("gameStarted", {
            type: "gameStarted",
            session: this._room.currentSession.getSessionForScript(),
        });
    }
    /**
     * End the game, emits a gameEnded event
     */
    endGame(winAmounts, _theoreticalWinAmount) {
        if (!this.isLocked) {
            throw new error_1.MTPError(`Cannot call "endGame" for non-locked actions`);
        }
        Object.keys(winAmounts).forEach((playerId) => {
            player_1.Player.getInstance(playerId).updatePurseWithWin(winAmounts[playerId]);
        });
        // Notify each player
        lodash_1.default.each(winAmounts, (value, playerId) => {
            this._room.notificationEngine.backendNotify(models_1.EPushNotificationType.PAYOUT, {
                amount: value,
            }, playerId);
        });
        this._room.currentSession.state = this.state = models_1.EGameState.FINISHED;
        this.emit("gameEnded", {
            type: "gameEnded",
            session: this._room.currentSession.getSessionForScript(),
        });
        /* store history in session */
        if (this._room.game.declaration.permanent) {
            this._room.run();
        }
        else {
            this._room.empty();
            this._room.close();
            this._room.game.close(this._room.id);
        }
    }
    /**
     * Cancel game session.
     * @param reason
     */
    cancelGameSession(reason) {
        if (!this.isLocked) {
            throw new error_1.MTPError(`Cannot call "cancelGameSession" for non-locked actions`);
        }
        // remove and recredit all players
        this._room.currentSession.players.forEach((p) => {
            // Re-give purse
            lodash_1.default.remove(this._room.currentSession.players, (player) => player.id === p.id);
            player_1.Player.getInstance(p.id).updatePurseWithWin(p.protected.bet);
        });
        // close the session
        this._room.currentSession.state = this.state = models_1.EGameState.FINISHED;
        // notify players
        this._room.notificationEngine.backendNotify(models_1.EPushNotificationType.SESSION_CANCELLED, {
            reason,
        });
        this._room.close();
        this._room.game.close(this._room.id);
    }
    /**
     * Get the game state
     * @return Game state
     */
    getGameState() {
        return this.state;
    }
    /**
     * Get server time
     * @return Server time
     */
    getSessionAge() {
        return Date.now();
    }
    /**
     * Set a timeout that will trigger an event after an duration in milliseconds
     * @param eventType Event type
     * @param id Time id (id being unique)
     * @param timeout   Timeout in milliseconds
     * @return Timer id
     */
    setTimeout(eventType, id, timeout) {
        // if timer with this id already exists clear it
        if (this.timersMap[id]) {
            this.clearTimeout(id);
        }
        const timer = setTimeout(() => {
            try {
                this.isLocked = true;
                this.emit("timerEvent", {
                    type: "timerEvent",
                    eventName: eventType,
                    session: this._room.currentSession.getSessionForScript(),
                });
            }
            catch (e) {
                backutils_1.logger.error("Restarting room...", {
                    errorMessage: e.message,
                    errorStack: e.stack,
                });
                this._room.restart();
                backutils_1.logger.info("Room restarted");
            }
        }, timeout);
        // store timer
        this.timersMap[id] = timer;
        return id;
    }
    /**
     * Clear the timeout
     * @param id id of the timer to clear
     */
    clearTimeout(id) {
        const timer = this.timersMap[id];
        if (timer) {
            clearTimeout(timer);
            delete this.timersMap[id];
        }
    }
    /**
     * Get the script and variant parameters of the current game session.
     * @return Parameters
     */
    getParameters() {
        return {
            minPlayers: this._room.game.minPlayers,
            maxPlayers: this._room.game.maxPlayers,
            scriptParameters: this._room.game.parameters.parameters,
            variantParameters: this._room.game.variantParameters.parameters,
        };
    }
    /**
     * Returns the number of observers in the room
     */
    getObserversCount() {
        return this._room.people.length - this._room.currentSession.players.length;
    }
    /**
     * Returns the number of players in the session
     */
    getNumberOfPlayers() {
        if (!this.isLocked) {
            throw new error_1.MTPError(`Cannot call "getNumberOfPlayers" for non-locked actions`);
        }
        return this._room.currentSession.players.length;
    }
    /**
     * Returns the player identified by the given id
     * @param id the id of the player to get
     */
    getPlayer(id) {
        return this._room.currentSession.players.find((p) => p.id === id);
    }
    /**
     * Returns all the players in the game session
     */
    getAllPlayers() {
        if (!this.isLocked) {
            throw new error_1.MTPError(`Cannot call "getAllPlayers" on non-locked actions`);
        }
        return this._room.currentSession.players;
    }
}
exports.GameEngine = GameEngine;
//# sourceMappingURL=gameEngine.js.map