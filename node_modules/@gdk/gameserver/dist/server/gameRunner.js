"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GameRunner = void 0;
const os = __importStar(require("os"));
const path = __importStar(require("path"));
const lodash_1 = __importDefault(require("lodash"));
const Hapi = __importStar(require("@hapi/hapi"));
const vision_1 = __importDefault(require("@hapi/vision"));
const inert_1 = __importDefault(require("@hapi/inert"));
const HapiSwagger = __importStar(require("hapi-swagger"));
const mustache_1 = __importDefault(require("mustache"));
const joi_1 = __importDefault(require("joi"));
const backutils_1 = require("@gdk/backutils");
const swagger_1 = require("./routes/swagger");
const gameSession_1 = require("./models/motors/gameSession");
const croupier_1 = __importDefault(require("./models/itg/croupier/croupier"));
const betManager_1 = require("./models/itg/betManager");
const multipassManager_1 = require("./models/multipass/multipassManager");
const common_1 = require("./routes/common");
const static_1 = require("./routes/static");
const itg_1 = require("./routes/itg");
const motors_1 = require("./routes/motors");
const gamif_1 = require("./routes/gamif");
const players_1 = require("./routes/players");
const jackpots_1 = require("./routes/jackpots");
const multipass_1 = require("./routes/multipass");
const motorsScript_1 = require("./models/motors/motorsScript");
const gamifSessionManager_1 = require("./models/gamif/gamifSessionManager");
const gameConfig_1 = require("./routes/gameConfig");
class GameRunner {
    /**
     * Initialize & start game server
     * @param port
     * @param options (lauched from command options will already be set with default values)
     */
    async execute(options = {}) {
        await this._configureServer(options.port || 1337);
        // to execute this command cli is started from the game directory
        this._gameDir = options.gameDirectory || process.cwd();
        // load and watch gameConfig
        this._gameConfig = new backutils_1.GameConfig(this._gameDir, options.gameConf || "game.conf.json");
        this._gameConfig.on("loaded", () => this._onGameConfigChanged());
        this._gameConfig.load({ watch: true });
        const routes = [
            ...(0, common_1.getRoutes)(),
            ...(0, static_1.getRoutes)(this._gameConfig, this._gameDir),
            ...new gameConfig_1.GameConfigRoutes(this._gameConfig).getRoutes(),
            ...(0, players_1.getRoutes)(),
        ];
        if (this._gameConfig.isJackpotEnabled) {
            this._jackpotsRoutes = new jackpots_1.JackpotsRoutes(this._gameConfig);
            routes.push(...this._jackpotsRoutes.getRoutes());
        }
        // instanciate managers
        this._betManager = new betManager_1.BetManager();
        this._motorsScriptsManager = new motorsScript_1.MotorsScriptsManager();
        this._gamifSessionManager = new gamifSessionManager_1.GamifSessionManager();
        this._gameSessionDB = new gameSession_1.GameSessionDB();
        this._multipassManager = new multipassManager_1.MultipassManager();
        // retrieve services
        const services = lodash_1.default.merge({}, this._gameConfig.services, options.services);
        // register services
        for (const serviceName of Object.keys(services)) {
            await this._registerService(serviceName, services[serviceName]);
        }
        // Add all routes
        routes.push(...(0, itg_1.getRoutes)(this._betManager), ...(0, motors_1.getRoutes)(this._gameSessionDB, this._motorsScriptsManager, this._gamifSessionManager), ...(0, gamif_1.getRoutes)(this._gamifSessionManager), ...(0, multipass_1.getRoutes)(this._multipassManager));
        this.server.route(routes);
        return await this.start();
    }
    /**
     * Start server.
     */
    async start() {
        // Start the server
        await this.server.start();
        const port = this.server.info.port;
        backutils_1.logger.warn(`Server is running :-)

To load the game, use one of the following url :
${this.ips.map((ip) => `  http://${ip}:${port}`).join("\n")}

Hit CTRL-C to stop the server`);
    }
    /**
     * Stop server.
     */
    async stop() {
        if (this._gameConfig) {
            this._gameConfig.close();
            this._gameConfig = undefined;
        }
        await this.server.stop({ timeout: 0 });
    }
    /**
     * Get ips listened by server.
     */
    get ips() {
        const interfaces = os.networkInterfaces();
        const ips = [];
        Object.keys(interfaces).forEach((name) => {
            interfaces[name].map((i) => {
                if (i.address.match(/[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/)) {
                    ips.push(i.address);
                }
            });
        });
        return ips;
    }
    async _configureServer(port) {
        const staticPath = path.join(__dirname, "../../static");
        this.server = new Hapi.Server({
            port,
            routes: {
                files: { relativeTo: staticPath },
            },
            // remove comment to have more info about error
            // debug: { request: ["error"] },
        });
        this.server.events.on("log", (event, tags) => {
            console.log("[LOG]", tags, event);
        });
        await this.server.register([
            { plugin: inert_1.default },
            { plugin: vision_1.default },
            {
                plugin: HapiSwagger,
                options: swagger_1.swaggerOptions,
            },
        ]);
        this.server.validator(joi_1.default);
        this.server.views({
            engines: {
                html: {
                    compile: (template) => {
                        mustache_1.default.parse(template);
                        return (context) => mustache_1.default.render(template, context);
                    },
                },
            },
            relativeTo: staticPath,
        });
    }
    _onGameConfigChanged() {
        var _a;
        // implement here what to do on conf changing
        (_a = this._jackpotsRoutes) === null || _a === void 0 ? void 0 : _a.setJackpots(this._gameConfig.jackpotConfig);
    }
    async _registerService(serviceName, servicePath) {
        // TODO
        // this method must handle the service registration without knowing wich type of service it is
        // TODO: handle tgz, git url, nexus url...
        switch (path.extname(servicePath)) {
            // croupier
            case ".json":
            case ".sql":
                const croupier = await croupier_1.default.get(servicePath, serviceName);
                this._betManager.addCroupier(croupier, serviceName);
                break;
            case ".mtr":
                this._motorsScriptsManager.add(serviceName, servicePath);
                break;
            case ".gamif": // TODO what's gamif file ?
                this._gamifSessionManager.add(serviceName.replace(/gamif$/, ""), servicePath);
                break;
            case ".mtp":
                await this._multipassManager.addConfiguration(servicePath);
                break;
            default:
                throw new Error(`"Can't handle service : ${serviceName}:${servicePath}`);
        }
    }
}
exports.GameRunner = GameRunner;
//# sourceMappingURL=gameRunner.js.map