"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRoutes = void 0;
const stream_1 = require("stream");
const lodash_1 = __importDefault(require("lodash"));
const helpers_1 = require("../helpers");
const player_1 = require("../models/player");
const error_1 = require("../models/multipass/error");
const models_1 = require("../models/multipass/models");
const player_2 = require("../models/multipass/player");
const swagger_1 = require("./swagger");
const HAPI_DEFAULT_OPTIONS = (extra200 = {}) => ({
    plugins: {
        "hapi-swagger": {
            responses: {
                200: Object.assign({ description: "Success" }, extra200),
                400: { description: "Bad Request", schema: swagger_1.Schema.mtp.error },
            },
        },
    },
    tags: [swagger_1.TAGS.API, swagger_1.TAGS.MTP],
});
const HAPI_HTML_OPTIONS = HAPI_DEFAULT_OPTIONS({ "content-type": "text/html" });
const HAPI_ROOM_OPTIONS = HAPI_DEFAULT_OPTIONS({ schema: swagger_1.Schema.mtp.rooms });
const HAPI_SESSION_OPTIONS = HAPI_DEFAULT_OPTIONS({ schema: swagger_1.Schema.mtp.session });
function getRoutes(multiplayerManager) {
    MultipassRouter.multipassManager = multiplayerManager;
    return [
        {
            method: "GET",
            path: "/mtp/games/{gameVariantName}/sessions",
            options: Object.assign(Object.assign({}, MultipassRouter.listSessionRoute), HAPI_DEFAULT_OPTIONS()),
        },
        {
            method: "GET",
            path: "/mtp/games/{gameVariantName}/sessions/{sessionId}/details",
            options: Object.assign(Object.assign({}, MultipassRouter.getSessionDetailsRoute), HAPI_DEFAULT_OPTIONS()),
        },
        {
            method: "GET",
            path: "/mtp/games/{gameVariantName}/history",
            options: Object.assign(Object.assign({}, MultipassRouter.listHistoriesRoute), HAPI_HTML_OPTIONS),
        },
        {
            method: "GET",
            path: "/mtp/games/{gameVariantName}/sessions/{sessionId}/history",
            options: Object.assign(Object.assign({}, MultipassRouter.showSessionHistoryRoute), HAPI_HTML_OPTIONS),
        },
        {
            method: "POST",
            path: "/mtp/games/{gameVariantName}/rooms/{roomId}/bet",
            options: Object.assign(Object.assign({}, MultipassRouter.createBetRoute), HAPI_DEFAULT_OPTIONS()),
        },
        {
            method: "PUT",
            path: "/mtp/games/{gameVariantName}/rooms/{roomId}/bet",
            options: Object.assign(Object.assign({}, MultipassRouter.updateBetRoute), HAPI_DEFAULT_OPTIONS()),
        },
        {
            method: "DELETE",
            path: "/mtp/games/{gameVariantName}/rooms/{roomId}/bet",
            options: Object.assign(Object.assign({}, MultipassRouter.cancelBetRoute), HAPI_DEFAULT_OPTIONS()),
        },
        {
            method: "GET",
            path: "/mtp/games/{gameVariantName}/params",
            options: Object.assign(Object.assign({}, MultipassRouter.getScriptVariantRoute), HAPI_DEFAULT_OPTIONS()),
        },
        {
            method: "PUT",
            path: "/mtp/games/mock/{gameSessionId}",
            options: Object.assign(Object.assign({}, MultipassRouter.putSessionMocksRoute), HAPI_DEFAULT_OPTIONS()),
        },
        {
            method: "PUT",
            path: "/mtp/games/mock/{gameSessionId}/{playerId}",
            options: Object.assign(Object.assign({}, MultipassRouter.putPlayerMocksRoute), HAPI_DEFAULT_OPTIONS()),
        },
        {
            method: "GET",
            path: "/mtp/games/mock/{gameSessionId}",
            options: Object.assign(Object.assign({}, MultipassRouter.getSessionMocksRoute), HAPI_DEFAULT_OPTIONS()),
        },
        {
            method: "GET",
            path: "/mtp/games/mock/{gameSessionId}/{playerId}",
            options: Object.assign(Object.assign({}, MultipassRouter.getPlayerMocksRoute), HAPI_DEFAULT_OPTIONS()),
        },
        {
            method: "DELETE",
            path: "/mtp/games/mock/{gameSessionId}",
            options: Object.assign(Object.assign({}, MultipassRouter.deleteSessionMocksRoute), HAPI_DEFAULT_OPTIONS()),
        },
        {
            method: "DELETE",
            path: "/mtp/games/mock/{gameSessionId}/{playerId}",
            options: Object.assign(Object.assign({}, MultipassRouter.deletePlayerMocksRoute), HAPI_DEFAULT_OPTIONS()),
        },
        {
            method: "GET",
            path: "/mtp/{roomId}",
            options: Object.assign(Object.assign({}, MultipassRouter.notificationConfigureRoute), HAPI_DEFAULT_OPTIONS()),
        },
        {
            method: "GET",
            path: "/mtp/games/{gameVariantName}/rooms",
            options: Object.assign(Object.assign({}, MultipassRouter.getRoomsRoute), HAPI_ROOM_OPTIONS),
        },
        {
            method: "GET",
            path: "/mtp/games/{gameVariantName}/rooms/{roomId}",
            options: Object.assign(Object.assign({}, MultipassRouter.getRoomRoute), HAPI_ROOM_OPTIONS),
        },
        {
            method: "POST",
            path: "/mtp/games/{gameVariantName}/rooms",
            options: Object.assign(Object.assign({}, MultipassRouter.createRoomRoute), HAPI_ROOM_OPTIONS),
        },
        {
            method: "POST",
            path: "/mtp/games/{gameVariantName}/restart",
            options: Object.assign(Object.assign({}, MultipassRouter.restartRoomsRoute), HAPI_DEFAULT_OPTIONS()),
        },
        {
            method: "POST",
            path: "/mtp/games/{gameVariantName}/rooms/{roomId}/restart",
            options: Object.assign(Object.assign({}, MultipassRouter.restartRoomRoute), HAPI_DEFAULT_OPTIONS()),
        },
        {
            method: "PUT",
            path: "/mtp/games/{gameVariantName}/rooms",
            options: Object.assign(Object.assign({}, MultipassRouter.enterRoomRoute), HAPI_ROOM_OPTIONS),
        },
        {
            method: "POST",
            path: "/mtp/games/{gameVariantName}/rooms/bet",
            options: Object.assign(Object.assign({}, MultipassRouter.enterRoomRouteAndBet), HAPI_ROOM_OPTIONS),
        },
        {
            method: "PUT",
            path: "/mtp/games/{gameVariantName}/rooms/{roomId}",
            options: Object.assign(Object.assign({}, MultipassRouter.enterRoomByIdRoute), HAPI_ROOM_OPTIONS),
        },
        {
            method: "DELETE",
            path: "/mtp/games/{gameVariantName}/rooms/{roomId}",
            options: Object.assign(Object.assign({}, MultipassRouter.deleteRoomRoute), HAPI_DEFAULT_OPTIONS()),
        },
        {
            method: "DELETE",
            path: "/mtp/games/{gameVariantName}/rooms/{roomId}/player",
            options: Object.assign(Object.assign({}, MultipassRouter.leaveRoomRoute), HAPI_DEFAULT_OPTIONS()),
        },
        {
            method: "GET",
            path: "/mtp/games/{gameVariantName}/rooms/{roomId}/session",
            options: Object.assign(Object.assign({}, MultipassRouter.getSessionRoute), HAPI_SESSION_OPTIONS),
        },
    ];
}
exports.getRoutes = getRoutes;
class MultipassRouter {
    /**
     * Get a list of sessions for a game
     */
    static async listSessionsHandler(request, h) {
        try {
            return h
                .response(await MultipassRouter.multipassManager.listSessions(request.params.gameVariantName))
                .code(200);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
    /**
     * Get details for a specific session of a game
     */
    static async getSessionDetailsHandler(request, h) {
        try {
            const sessionDetails = await MultipassRouter.multipassManager.getGameSessionDetails(request.params.gameVariantName, request.params.sessionId);
            return h.response(sessionDetails).code(200);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
    /**
     * Get sessions list
     */
    static async listHistoriesHandler(request, h) {
        try {
            const gameVariantName = request.params.gameVariantName;
            const list = (await MultipassRouter.multipassManager.listSessions(gameVariantName)).map((e) => {
                return `<li><a href="/mtp/games/${gameVariantName}/sessions/${e.id}/history">${e.id}</a> (${e.status}, ${e.players} players)</li>`;
            });
            return h.response(`<html><body><ul>${list.join("")}</ul></body></html>`).code(200);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
    /**
     * Get details for a specific session of a game
     */
    static async showSessionHistoryHandler(request, h) {
        try {
            const game = await MultipassRouter.multipassManager.get(request.params.gameVariantName);
            const sessionDetails = await MultipassRouter.multipassManager.getGameSessionDetails(request.params.gameVariantName, request.params.sessionId);
            return h
                .response(`<html><body><script>var sessionDetails = ${JSON.stringify(sessionDetails)}; ${game.historyScript}</script></body></html>`)
                .code(200);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
    /**
     * Make a bet
     */
    static async createBetHandler(request, h) {
        try {
            const game = await MultipassRouter.multipassManager.get(request.params.gameVariantName);
            const { amount, data } = request.payload;
            if (!amount) {
                throw new error_1.MTPError("Bet must be provided with at least an amount");
            }
            const playerId = player_2.Player.getPlayerId(request);
            const roomId = request.params.roomId;
            const room = game.getRoomById(roomId);
            const person = room.getPerson(playerId);
            person.bet({ amount, data });
            return h
                .response({
                applicationId: "MTP",
                serviceName: request.params.gameVariantName,
                serverMessage: [],
                data: {
                    playerGameSessionId: "empty",
                    gameSessionId: room.currentSession.id,
                    roomId: room.id,
                },
            })
                .code(200);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
    /**
     * Update a bet
     */
    static async updateBetHandler(request, h) {
        try {
            const playerId = player_2.Player.getPlayerId(request);
            const game = await MultipassRouter.multipassManager.get(request.params.gameVariantName);
            const room = game.getRoomById(request.params.roomId);
            const player = room.currentSession.getPlayer(playerId);
            const { eventName, data } = request.payload;
            if (!eventName) {
                throw new error_1.MTPError('Parameter "eventName" is mandatory');
            }
            player.execute(eventName, data);
            return h
                .response({
                applicationId: "MTP",
                serviceName: request.params.gameVariantName,
                serverMessage: [],
                data: {
                    playerGameSessionId: "empty",
                    gameSessionId: room.currentSession.id,
                    roomId: room.id,
                },
            })
                .code(200);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
    /**
     * Cancel a bet
     */
    static async cancelBetHandler(request, h) {
        try {
            const playerId = player_2.Player.getPlayerId(request);
            const game = await MultipassRouter.multipassManager.get(request.params.gameVariantName);
            const room = game.getRoomById(request.params.roomId);
            const player = room.currentSession.getPlayer(playerId);
            player.cancelBet();
            return h.response().code(204);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
    /**
     * Get a game variant params
     */
    static async getScriptVariantHandler(request, h) {
        try {
            const game = await MultipassRouter.multipassManager.get(request.params.gameVariantName);
            return h.response({ data: game.getScriptVariant() }).code(200);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
    /**
     * Add some mocks values to a given session
     */
    static putSessionMocksHandler(request, h) {
        try {
            const session = MultipassRouter.multipassManager.getSessionById(request.params.gameSessionId);
            session.mocks.sessionMocks.push(...request.payload);
            return h.response().code(204);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
    /**
     * Add some mocks values to a given player for a given session
     */
    static putPlayerMocksHandler(request, h) {
        try {
            const session = MultipassRouter.multipassManager.getSessionById(request.params.gameSessionId);
            const mocks = session.mocks.playerMocks[request.params.playerId];
            if (!mocks) {
                throw new error_1.MTPError(`Player ${request.params.playerId} not in session`);
            }
            mocks.push(...request.payload);
            return h.response().code(204);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
    /**
     * Get registered mocks values of a given session
     */
    static getSessionMocksHandler(request, h) {
        try {
            const session = MultipassRouter.multipassManager.getSessionById(request.params.gameSessionId);
            return h.response(session.mocks.sessionMocks).code(200);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
    /**
     * Get registered mock values of a given player for a given session
     */
    static getPlayerMocksHandler(request, h) {
        try {
            const session = MultipassRouter.multipassManager.getSessionById(request.params.gameSessionId);
            const mocks = session.mocks.playerMocks[request.params.playerId];
            if (!mocks) {
                throw new error_1.MTPError(`Player ${request.params.playerId} not in session`);
            }
            return h.response(mocks).code(200);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
    /**
     * Remvove registered mocks values of a given session (won't remove player mocks values for this session)
     */
    static deleteSessionMocksHandler(request, h) {
        try {
            const session = MultipassRouter.multipassManager.getSessionById(request.params.gameSessionId);
            session.mocks.sessionMocks = [];
            return h.response().code(204);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
    /**
     * Remvove registered mocks values of a given player for a given session
     */
    static deletePlayerMocksHandler(request, h) {
        try {
            const session = MultipassRouter.multipassManager.getSessionById(request.params.gameSessionId);
            if (!session.mocks.playerMocks[request.params.playerId]) {
                throw new error_1.MTPError(`Player ${request.params.playerId} not in session`);
            }
            session.mocks.playerMocks[request.params.playerId] = [];
            return h.response().code(204);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
    /**
     * Configures the route
     */
    static notificationConfigureHandler(request, h) {
        try {
            const playerId = player_2.Player.getPlayerId(request);
            const room = MultipassRouter.multipassManager.getRoomById(request.params.roomId);
            const person = room.getPerson(playerId);
            // Recreate stream even if the player previously has a
            // stream. Because connection was closed, the stream was outdated
            (0, helpers_1.clearStream)(person.channel.stream);
            person.channel.stream = new stream_1.PassThrough();
            // First notif to wake the client up !
            person.channel.push(models_1.EPushNotificationType.SCRIPT, {
                type: "gdk",
                $__: "gdk >> gravity",
            }, room.currentSession.id, true);
            request.events.once("disconnect", () => {
                (0, helpers_1.clearStream)(person.channel.stream);
                person.channel.stream = null;
            });
            // Response: return the channel (stream) directly
            return h
                .response(person.channel.stream)
                .code(200)
                .type("text/event-stream; charset=utf-8")
                .header("content-encoding", "none");
        }
        catch (e) {
            return h.response(e).code(403);
        }
    }
    /**
     * Get All player rooms for a gameVariantName
     */
    static async getRoomsHandler(request, h) {
        try {
            const game = await MultipassRouter.multipassManager.get(request.params.gameVariantName);
            const playerId = player_1.Player.getPlayerId(request);
            // Get rooms
            const rooms = MultipassRouter.multipassManager.filterByPlayerId(game.rooms, playerId);
            return h.response(rooms.map((r) => r.toJson())).code(200);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
    /**
     * Get A specific room with a roomId
     */
    static async getRoomHandler(request, h) {
        try {
            const roomId = request.params.roomId;
            const game = await MultipassRouter.multipassManager.get(request.params.gameVariantName);
            const room = game.getRoomById(roomId);
            return h.response(room.toJson()).code(200);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
    /**
     * Create a room for a gameVariantName and a betLevel
     */
    static async createRoomHandler(request, h) {
        try {
            const { betLevelId } = request.payload;
            if (lodash_1.default.isUndefined(betLevelId)) {
                throw new error_1.MTPError("Bet is required to create a room");
            }
            const game = await MultipassRouter.multipassManager.get(request.params.gameVariantName);
            const room = await game.createRoom(betLevelId);
            return h.response(room.toJson()).code(200);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
    /**
     * Restarts all the rooms by calling room.restart()
     * In other words: reload all scripts and clean observers + sessions
     */
    static async restartRoomsHandler(request, h) {
        try {
            const game = await MultipassRouter.multipassManager.get(request.params.gameVariantName);
            await game.load();
            game.rooms.forEach((r) => r.restart());
            return h.response().code(204);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
    /**
     * Restart a room by calling room.restart()
     * In other words: clean observers + sessions
     */
    static async restartRoomHandler(request, h) {
        try {
            const roomId = request.params.roomId;
            const game = await MultipassRouter.multipassManager.get(request.params.gameVariantName);
            const room = game.getRoomById(roomId);
            room.restart();
            return h.response().code(204);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
    /**
     * Enter a room matching a gameVariantName and a betLevel
     * Creates the room if it does not exists
     */
    static async enterRoomHandler(request, h) {
        try {
            const { betLevelId } = request.payload;
            const playerId = player_2.Player.getPlayerId(request);
            const gameVariantName = request.params.gameVariantName;
            // Create room if not exists
            const game = await MultipassRouter.multipassManager.get(gameVariantName);
            let room = null;
            try {
                room = game.getRoom(betLevelId, true);
                if (room.currentSession.state !== models_1.EGameState.PENDING) {
                    throw new Error();
                }
                room.addPerson(playerId);
            }
            catch (e) {
                room = await game.createRoom(betLevelId);
                room.addPerson(playerId);
            }
            return h.response(room.toJson()).code(200);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
    /**
     * Enter a room matching a gameVariantName and a betLevel
     * Creates the room if it does not exists
     */
    static async enterRoomAndBetHandler(request, h) {
        try {
            const { betLevelId, amount, data } = request.payload;
            const playerId = player_2.Player.getPlayerId(request);
            const gameVariantName = request.params.gameVariantName;
            if (!amount) {
                throw new error_1.MTPError("Bet must be provided with at least an amount");
            }
            // Create room if not exists
            const game = await MultipassRouter.multipassManager.get(gameVariantName);
            let room = null;
            try {
                room = game.getRoom(betLevelId, true);
                if (room.currentSession.state !== models_1.EGameState.PENDING) {
                    throw new Error();
                }
                room.addPerson(playerId);
            }
            catch (e) {
                room = await game.createRoom(betLevelId);
                room.addPerson(playerId);
            }
            try {
                const person = room.getPerson(playerId);
                person.bet({ amount, data });
            }
            catch (e) {
                room.removePerson(playerId, true);
                throw e;
            }
            return h
                .response({
                applicationId: "MTP",
                serviceName: request.params.gameVariantName,
                serverMessage: [],
                data: {
                    playerGameSessionId: "empty",
                    gameSessionId: room.currentSession.id,
                    roomId: room.id,
                },
            })
                .code(200);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
    /**
     * Enter a specific room
     * Creates the room if it does not exists
     */
    static async enterRoomByIdHandler(request, h) {
        try {
            const playerId = player_2.Player.getPlayerId(request);
            const gameVariantName = request.params.gameVariantName;
            const roomId = request.params.roomId;
            const game = await MultipassRouter.multipassManager.get(gameVariantName);
            const room = game.getRoomById(roomId);
            room.addPerson(playerId);
            return h.response(room.toJson()).code(200);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
    /**
     * Delete a room
     */
    static async deleteRoomHandler(request, h) {
        try {
            const gameVariantName = request.params.gameVariantName;
            const roomId = request.params.roomId;
            const game = await MultipassRouter.multipassManager.get(gameVariantName);
            game.close(roomId);
            return h.response().code(204);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
    /**
     * Leave a room
     */
    static async leaveRoomHandler(request, h) {
        try {
            const playerId = player_2.Player.getPlayerId(request);
            const gameVariantName = request.params.gameVariantName;
            const roomId = request.params.roomId;
            const game = await MultipassRouter.multipassManager.get(gameVariantName);
            const room = game.getRoomById(roomId);
            room.removePerson(playerId);
            return h.response().code(204);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
    /**
     * Get current session on a room
     * -> GET /mtp/games/{gameVariantName}/rooms/{roomId}/session
     */
    static async getSessionHandler(request, h) {
        try {
            const playerId = player_2.Player.getPlayerId(request);
            const game = await MultipassRouter.multipassManager.get(request.params.gameVariantName);
            const room = game.getRoomById(request.params.roomId);
            return h.response(room.currentSession.toJson(playerId)).code(200);
        }
        catch (e) {
            return h.response(e).code(400);
        }
    }
}
MultipassRouter.listSessionRoute = {
    handler: MultipassRouter.listSessionsHandler,
    description: "Get the list of all sessions of a game",
    notes: "Get the list of all sessions of a game",
    validate: {
        params: {
            gameVariantName: swagger_1.Schema.mtp.gameVariantName.required(),
        },
    },
};
MultipassRouter.getSessionDetailsRoute = {
    handler: MultipassRouter.getSessionDetailsHandler,
    description: "Get session details",
    notes: "Get data for session details",
    validate: {
        params: {
            gameVariantName: swagger_1.Schema.mtp.gameVariantName.required(),
            sessionId: swagger_1.Schema.mtp.sessionId.required(),
        },
    },
};
MultipassRouter.listHistoriesRoute = {
    handler: MultipassRouter.listHistoriesHandler,
    description: "Print sessions list",
    notes: "Print sessions list",
    validate: {
        params: {
            gameVariantName: swagger_1.Schema.mtp.gameVariantName.required(),
        },
    },
};
MultipassRouter.showSessionHistoryRoute = {
    handler: MultipassRouter.showSessionHistoryHandler,
    description: "Get session details",
    notes: "Get data for session details",
    validate: {
        params: {
            gameVariantName: swagger_1.Schema.mtp.gameVariantName.required(),
            sessionId: swagger_1.Schema.mtp.sessionId.required(),
        },
    },
};
MultipassRouter.createBetRoute = {
    handler: MultipassRouter.createBetHandler,
    description: "Place a bet on a multipass session",
    notes: "Place a bet on a multipass session.\nThe player that place the bet has to be in the room.\nTe bet amount has to be valid for the room.",
    validate: {
        params: {
            gameVariantName: swagger_1.Schema.mtp.gameVariantName.required(),
            roomId: swagger_1.Schema.mtp.roomId.required(),
        },
        payload: {
            amount: swagger_1.Schema.shared.amount.required(),
            data: swagger_1.Schema.mtp.betData.required(),
        },
    },
};
MultipassRouter.updateBetRoute = {
    handler: MultipassRouter.updateBetHandler,
    description: "Update a bet on a multipass session",
    notes: "Excecutes an action for a player that has already bet.",
    validate: {
        params: {
            gameVariantName: swagger_1.Schema.mtp.gameVariantName.required(),
            roomId: swagger_1.Schema.mtp.roomId.required(),
        },
        payload: {
            eventName: swagger_1.Schema.mtp.eventName.required(),
            data: swagger_1.Schema.mtp.betData.required(),
            playerGameSessionId: swagger_1.Schema.mtp.playerGameSessionId.required(),
        },
    },
};
MultipassRouter.cancelBetRoute = {
    handler: MultipassRouter.cancelBetHandler,
    description: "Cancel a bet on a multipass session",
    notes: "Cancel a bet on a multipass session.\nThe player has to be in the session (already bet) and the game has to allow the cancelBet feature",
    validate: {
        params: {
            gameVariantName: swagger_1.Schema.mtp.gameVariantName.required(),
            roomId: swagger_1.Schema.mtp.roomId.required(),
        },
    },
};
MultipassRouter.getScriptVariantRoute = {
    handler: MultipassRouter.getScriptVariantHandler,
    description: "Get parameters for a specific room",
    notes: "Get parameters set for a room. Including variant parameters.",
    validate: {
        params: {
            gameVariantName: swagger_1.Schema.mtp.gameVariantName.required(),
        },
    },
};
MultipassRouter.putSessionMocksRoute = {
    handler: MultipassRouter.putSessionMocksHandler,
    description: "Put session mocks",
    notes: "Add some mocks values to a given session",
    validate: {
        params: {
            gameSessionId: swagger_1.Schema.mtp.sessionId.required(),
        },
        payload: swagger_1.Schema.mtp.mocks,
    },
};
MultipassRouter.putPlayerMocksRoute = {
    handler: MultipassRouter.putPlayerMocksHandler,
    description: "Put player mocks",
    notes: "Add some mocks values to a given player for a given session",
    validate: {
        params: {
            gameSessionId: swagger_1.Schema.mtp.sessionId.required(),
            playerId: swagger_1.Schema.player.playerId.required(),
        },
        payload: swagger_1.Schema.mtp.mocks,
    },
};
MultipassRouter.getSessionMocksRoute = {
    handler: MultipassRouter.getSessionMocksHandler,
    description: "Get session mocks",
    notes: "Get registered mocks values of a given session",
    validate: {
        params: {
            gameSessionId: swagger_1.Schema.mtp.sessionId.required(),
        },
    },
};
MultipassRouter.getPlayerMocksRoute = {
    handler: MultipassRouter.getPlayerMocksHandler,
    description: "Get player mocks",
    notes: "Get registered mock values of a given player for a given session",
    validate: {
        params: {
            gameSessionId: swagger_1.Schema.mtp.sessionId.required(),
            playerId: swagger_1.Schema.player.playerId.required(),
        },
    },
};
MultipassRouter.deleteSessionMocksRoute = {
    handler: MultipassRouter.deleteSessionMocksHandler,
    description: "Remove session mocks",
    notes: "Remove registered mocks values of a given session (won't remove player mocks values for this session)",
    validate: {
        params: {
            gameSessionId: swagger_1.Schema.mtp.sessionId.required(),
        },
    },
};
MultipassRouter.deletePlayerMocksRoute = {
    handler: MultipassRouter.deletePlayerMocksHandler,
    description: "Remove player mocks",
    notes: "Remove registered mocks values of a given player for a given session",
    validate: {
        params: {
            gameSessionId: swagger_1.Schema.mtp.sessionId.required(),
            playerId: swagger_1.Schema.player.playerId.required(),
        },
    },
};
MultipassRouter.notificationConfigureRoute = {
    handler: MultipassRouter.notificationConfigureHandler,
    description: "Create sse communication channel",
    notes: `Initiates a sse communication channel from the gdk to the client. Returns the channel to be listened to by the client.
						The person requesting a communication channel need to be in the room.
						If a channel was already existing for this person/room, a new one is created and the old one is destroyed.`,
    validate: {
        params: {
            roomId: swagger_1.Schema.mtp.roomId.required(),
        },
    },
};
MultipassRouter.getRoomsRoute = {
    handler: MultipassRouter.getRoomsHandler,
    description: "Get player rooms",
    notes: `Get all active rooms for this variant name.
						If a bet amount is provided, returns only the rooms where this bet is allowed,
						If a playerId is given, it will return only the rooms this player is in`,
    validate: {
        params: {
            gameVariantName: swagger_1.Schema.mtp.gameVariantName.required(),
        },
    },
};
MultipassRouter.getRoomRoute = {
    handler: MultipassRouter.getRoomHandler,
    description: "Get a specific room",
    notes: "Retrieve a room by id",
    validate: {
        params: {
            gameVariantName: swagger_1.Schema.mtp.gameVariantName.required(),
            roomId: swagger_1.Schema.mtp.roomId.required(),
        },
    },
};
MultipassRouter.createRoomRoute = {
    handler: MultipassRouter.createRoomHandler,
    description: "Create a room",
    notes: "Creates a multipass room matching a specific bet level. Will return the newly created room",
    validate: {
        params: {
            gameVariantName: swagger_1.Schema.mtp.gameVariantName.required(),
        },
        payload: {
            betLevelId: swagger_1.Schema.mtp.betLevelId.required(),
        },
    },
};
MultipassRouter.restartRoomsRoute = {
    handler: MultipassRouter.restartRoomsHandler,
    description: "Restart all rooms",
    notes: "Restarts all rooms for a game variant. Restarting a room will also relod script and parameters.",
    validate: {
        params: {
            gameVariantName: swagger_1.Schema.mtp.gameVariantName.required(),
        },
    },
};
MultipassRouter.restartRoomRoute = {
    handler: MultipassRouter.restartRoomHandler,
    description: "restart a specific room",
    notes: "Restarts a specific room by id. Restarting a lonly room won't reload relod script and parameters.",
    validate: {
        params: {
            gameVariantName: swagger_1.Schema.mtp.gameVariantName.required(),
            roomId: swagger_1.Schema.mtp.roomId,
        },
    },
};
MultipassRouter.enterRoomRoute = {
    handler: MultipassRouter.enterRoomHandler,
    description: "Enter a room",
    notes: "Add someone in a room matching a bet level for this game variant. The matchmaking will automatically choose which room to enter. If no matching room exists, one will be created. This route return the room.",
    validate: {
        params: {
            gameVariantName: swagger_1.Schema.mtp.gameVariantName.required(),
        },
        payload: {
            betLevelId: swagger_1.Schema.mtp.betLevelId.required(),
        },
    },
};
MultipassRouter.enterRoomRouteAndBet = {
    handler: MultipassRouter.enterRoomAndBetHandler,
    description: "Enter a room and place a bet",
    notes: "Add someone in a room matching a bet level for this game variant and place the bet when entering. The matchmaking will automatically choose which room to enter. If no matching room exists, one will be created. This route return the room.",
    validate: {
        params: {
            gameVariantName: swagger_1.Schema.mtp.gameVariantName.required(),
        },
        payload: {
            betLevelId: swagger_1.Schema.mtp.betLevelId.required(),
            amount: swagger_1.Schema.shared.amount.required(),
            data: swagger_1.Schema.mtp.betData.required(),
        },
    },
};
MultipassRouter.enterRoomByIdRoute = {
    handler: MultipassRouter.enterRoomByIdHandler,
    description: "Enter a specific room",
    notes: "Enter a specific room by id. This route return the room.",
    validate: {
        params: {
            gameVariantName: swagger_1.Schema.mtp.gameVariantName.required(),
            roomId: swagger_1.Schema.mtp.roomId.required(),
        },
    },
};
MultipassRouter.deleteRoomRoute = {
    handler: MultipassRouter.deleteRoomHandler,
    description: "Close a specific room",
    notes: "Closes a room by id. The room will be deleted from the room list.",
    validate: {
        params: {
            gameVariantName: swagger_1.Schema.mtp.gameVariantName.required(),
            roomId: swagger_1.Schema.mtp.roomId,
        },
    },
};
MultipassRouter.leaveRoomRoute = {
    handler: MultipassRouter.leaveRoomHandler,
    description: "Leave a specific room",
    notes: "Removes someone from a room. If this someone is currently in the game session, this will throw an error.",
    validate: {
        params: {
            gameVariantName: swagger_1.Schema.mtp.gameVariantName.required(),
            roomId: swagger_1.Schema.mtp.roomId,
        },
    },
};
MultipassRouter.getSessionRoute = {
    handler: MultipassRouter.getSessionHandler,
    description: "Get current session for a specific room",
    notes: `Get session details for a specific room.
						This will return the running session of the room.
						The session object returned depends of the player who made the request.`,
    validate: {
        params: {
            gameVariantName: swagger_1.Schema.mtp.gameVariantName.required(),
            roomId: swagger_1.Schema.mtp.roomId.required(),
        },
    },
};
//# sourceMappingURL=multipass.js.map