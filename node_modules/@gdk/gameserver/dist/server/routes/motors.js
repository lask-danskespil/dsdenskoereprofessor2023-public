"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.responseError = exports.responseOK = exports.getRoutes = void 0;
const boom = __importStar(require("@hapi/boom"));
const server_1 = __importDefault(require("../models/server"));
const mocks_1 = __importDefault(require("../models/motors/tools/mocks"));
const gameModel_1 = __importDefault(require("../models/motors/tools/gameModel"));
const helpers_1 = require("../models/motors/helpers");
const histoRenderer_1 = __importDefault(require("../models/motors/tools/histoRenderer"));
const session_1 = require("../models/motors/session");
const swagger_1 = require("./swagger");
const prsContext_1 = __importDefault(require("../models/motors/tools/prsContext"));
const helpers_2 = require("../helpers");
const HISTO_PATH = "templates/histo-render.html";
const HAPI_DEFAULT_OPTIONS = (extra200 = {}) => ({
    plugins: {
        "hapi-swagger": {
            responses: {
                200: Object.assign({ description: "Success" }, extra200),
                400: { description: "Bad Request", schema: swagger_1.Schema.shared.error },
            },
        },
    },
    tags: [swagger_1.TAGS.API, swagger_1.TAGS.MTR],
});
function getRoutes(gameSessionDB, motorsScriptManager, gamifSessionManager) {
    MotorsRouter.scriptManager = motorsScriptManager;
    MotorsRouter.sessionDB = gameSessionDB;
    MotorsRouter.gamifManager = gamifSessionManager;
    return [
        { method: "GET", path: "/mtr/{serviceName}/model", options: MotorsRouter.getModelRoute },
        { method: "GET", path: "/mtr/{serviceName}/session", options: MotorsRouter.getSessionRoute },
        { method: "POST", path: "/mtr/{serviceName}/bet", options: MotorsRouter.betRoute },
        { method: "PUT", path: "/mtr/{serviceName}/bet", options: MotorsRouter.updateBetRoute },
        { method: "GET", path: "/mtr/admin/game", options: MotorsRouter.getGameRoute },
        {
            method: "GET",
            path: "/mtr/{serviceName}/ticket",
            options: MotorsRouter.getPrsTicketInfosRoute,
        },
        { method: "GET", path: "/mtr/admin/mock", options: MotorsRouter.getMockRoute },
        { method: "POST", path: "/mtr/admin/mock", options: MotorsRouter.addMockRoute },
        { method: "DELETE", path: "/mtr/admin/mock", options: MotorsRouter.resetMockRoute },
        { method: "GET", path: "/mtr/admin/sessions", options: MotorsRouter.getSessionsDevRoute },
        {
            method: "DELETE",
            path: "/mtr/admin/sessions",
            options: MotorsRouter.deleteAllSessionsDevRoute,
        },
        {
            method: "GET",
            path: "/mtr/admin/sessions/{sessionId}/histo",
            options: MotorsRouter.getSessionHistoRoute,
        },
        {
            method: "DELETE",
            path: "/mtr/admin/sessions/{sessionId}",
            options: MotorsRouter.deleteSessionDevRoute,
        },
    ];
}
exports.getRoutes = getRoutes;
class MotorsRouter {
    /**
     * Get MTR model.
     * @param r
     * @param h
     */
    static async getModel(r, h) {
        try {
            server_1.default.getInstance().assert();
            const serviceName = r.params.serviceName;
            const motorsData = MotorsRouter.scriptManager.get(serviceName);
            const gameModel = await gameModel_1.default.get(motorsData.manifestFilePath);
            return h
                .response({
                serviceName,
                applicationId: serviceName,
                data: {
                    gmid: parseInt(motorsData._id, 10),
                    gmn: gameModel.name,
                    mdl: gameModel.constants,
                },
            })
                .code(200);
        }
        catch (e) {
            return h.response(responseError(e)).code(400);
        }
    }
    /**
     * Get MTR session.
     * @param r
     * @param h
     */
    static async getSession(r, h) {
        try {
            server_1.default.getInstance().assert();
            const serviceName = r.params.serviceName;
            const query = r.query || {};
            const sessionId = query.gameSessionId || undefined;
            const gameDB = MotorsRouter.scriptManager.get(serviceName);
            const gameSession = sessionId !== undefined
                ? await (0, session_1.getSessionById)(MotorsRouter.sessionDB, MotorsRouter.scriptManager, serviceName, sessionId)
                : await (0, session_1.getSession)(MotorsRouter.sessionDB, MotorsRouter.scriptManager, serviceName);
            if (!gameSession) {
                return h.response(undefined).code(200);
            }
            if (sessionId && gameSession.state === "final") {
                return h
                    .response({
                    serviceName,
                    applicationId: serviceName,
                    id: gameSession._id,
                    message: [],
                    serverMessage: gameSession.messages,
                    betAmount: {
                        value: gameSession.bet,
                        currency: gameSession.amountCurrency,
                    },
                    wonAmount: gameSession.wonAmount,
                    data: {
                        state: gameSession.state === "final" ? "CMPL" : "INPR",
                        gmid: parseInt(gameDB._id, 10),
                        steps: gameSession.steps,
                    },
                })
                    .code(200);
            }
            else {
                return h
                    .response({
                    serviceName,
                    applicationId: serviceName,
                    id: gameSession._id,
                    message: [],
                    serverMessage: gameSession.messages,
                    betAmount: {
                        value: gameSession.bet,
                        currency: gameSession.amountCurrency,
                    },
                    data: {
                        state: gameSession.state === "final" ? "CMPL" : "INPR",
                        evr: {},
                        gmd: gameSession.data,
                        gmid: parseInt(gameDB._id, 10),
                        id: gameSession._id,
                        st: gameSession.state,
                        steps: gameSession.steps,
                    },
                })
                    .code(200);
            }
        }
        catch (e) {
            return h.response(responseError(e)).code(400);
        }
    }
    /**
     * MTR bet. Create session.
     * @param r
     * @param h
     */
    static async bet(r, h) {
        try {
            server_1.default.getInstance().assert();
            const stateMachineParams = Object.assign({}, r.payload, { results: {} });
            delete stateMachineParams.gameExtRef;
            const serviceName = r.params.serviceName;
            const query = r.query || {};
            const demoMode = query.demoMode === "true" || false;
            const token = getRequestToken(r);
            const data = {
                serviceName,
                bet: parseInt(r.payload.stake.value, 10),
                amountCurrency: r.payload.stake.currency,
                stateMachineParams,
                demoMode,
            };
            const gameSession = await (0, session_1.createSession)(MotorsRouter.sessionDB, MotorsRouter.scriptManager, MotorsRouter.gamifManager, data, token);
            const evr = Object.assign(data.stateMachineParams.results);
            return h
                .response({
                serviceName,
                applicationId: serviceName,
                receiptId: "0",
                platformBetId: "gdk-bet-id",
                demo: gameSession.demoMode,
                serverMessage: null,
                messages: [],
                id: gameSession._id,
                betAmount: {
                    value: gameSession.bet,
                    currency: gameSession.amountCurrency,
                },
                wonAmount: gameSession.wonAmount,
                data: {
                    res: "ok",
                    data: {
                        id: gameSession._id,
                        gmid: parseInt(gameSession.gameId, 10),
                        st: gameSession.state,
                        evr,
                    },
                },
            })
                .code(200);
        }
        catch (up) {
            return h.response(up.message).code(400);
        }
    }
    /**
     * Update bet. (Execute)
     * @param r
     * @param h
     */
    static async updateBet(r, h) {
        try {
            server_1.default.getInstance().assert();
            const params = Object.assign({}, r.payload, { results: {} });
            delete params.evn;
            delete params.sid;
            const event = {
                gameName: r.params.serviceName,
                sessionId: r.payload.sid.toString(),
                eventName: r.payload.evn,
                stateMachineParams: params,
            };
            const gameSession = await (0, session_1.onEvent)(event, MotorsRouter.gamifManager, MotorsRouter.sessionDB);
            return h
                .response({
                serviceName: event.gameName,
                applicationId: event.gameName,
                receiptId: "0",
                platformBetId: "gdk-bet-id",
                demo: gameSession.demoMode,
                serverMessage: null,
                messages: [],
                id: event.sessionId,
                betAmount: {
                    value: gameSession.bet,
                    currency: gameSession.amountCurrency,
                },
                wonAmount: gameSession.wonAmount,
                data: {
                    res: "ok",
                    data: {
                        id: event.sessionId,
                        gmid: parseInt(gameSession.gameId, 10),
                        st: gameSession.state,
                        evr: event.stateMachineParams.results,
                    },
                },
            })
                .code(200);
        }
        catch (up) {
            return h.response(responseError(up)).code(400);
        }
    }
    /**
     * Get game data.
     * @param r
     * @param h
     */
    static async getGame(r, h) {
        try {
            const query = r.query || {};
            const paging = query.pagingRequest || {};
            const pageNumber = paging.pageNumber || 0;
            const pageSize = paging.pageSize || 20;
            const games = (0, helpers_1.getGameData)(MotorsRouter.scriptManager, pageNumber, pageSize);
            return h.response(responseOK(games)).code(200);
        }
        catch (e) {
            return h.response(responseError(e)).code(400);
        }
    }
    /**
     * Get presto ticket infos.
     * @param r
     * @param h
     */
    static async getPrsTicketInfos(r, h) {
        try {
            server_1.default.getInstance().assert();
            const serviceName = r.params.serviceName;
            const motorsData = MotorsRouter.scriptManager.get(serviceName);
            const token = getRequestToken(r);
            const prsTicketInfos = await prsContext_1.default.get(motorsData.manifestFilePath, token);
            return h.response(prsTicketInfos).code(200);
        }
        catch (e) {
            return h.response(responseError(e)).code(400);
        }
    }
    /**
     * Get mock
     * @param r
     * @param h
     */
    static getMock(r, h) {
        try {
            server_1.default.getInstance().assert();
            const query = r.query;
            // No gameModelId => error
            if (!query.gameModelId) {
                throw new Error("missing mandatory gameModelId param");
            }
            return h.response(mocks_1.default.get().getMocks(query.gameModelId)).code(200);
        }
        catch (e) {
            return h.response(responseError(e)).code(400);
        }
    }
    /**
     * Add mock
     * @param r
     * @param h
     */
    static addMock(r, h) {
        try {
            server_1.default.getInstance().assert();
            const query = r.query;
            // No gameModelId => error
            if (!query.gameModelId) {
                throw new Error("missing mandatory gameModelId param");
            }
            let elements;
            if (query.elements === undefined) {
                // Handle no elements, (request.query as any).elements is undefined
                elements = [];
            }
            else if (!Array.isArray(query.elements)) {
                // Handle 1 elements case, (request.query as any).elements is a string
                elements = [query.elements];
            }
            else {
                // Handle multiple elements case, (request.query as any).elements is an array of string
                elements = query.elements;
            }
            mocks_1.default.get().addMocks(query.gameModelId, elements.map((e) => parseInt(e, 10)));
            return h.response(responseOK()).code(200);
        }
        catch (e) {
            return h.response(responseError(e)).code(400);
        }
    }
    /**
     * Reset mtr mock.
     * @param r
     * @param h
     */
    static resetMock(r, h) {
        try {
            server_1.default.getInstance().assert();
            // No gameModelId => error
            if (!r.query.gameModelId) {
                throw new Error("missing mandatory gameModelId param");
            }
            mocks_1.default.get().resetMocks(r.query.gameModelId);
            return h.response(responseOK()).code(200);
        }
        catch (e) {
            return h.response(responseError(e)).code(400);
        }
    }
    /**
     * Get all sessions. Debug route.
     * @param r
     * @param h
     */
    static async getSessionsDev(r, h) {
        const sessions = await MotorsRouter.sessionDB.list();
        const baseUrl = `${r.server.info.protocol}://${r.info.host}${r.path}`;
        const response = sessions
            .map((session) => ({ id: session._id, histoURL: `${baseUrl}/${session._id}/histo` }))
            .sort((session1, session2) => session2.id.localeCompare(session1.id));
        return h.response(response).code(200);
    }
    /**
     * Delete session. Debug route.
     * @param r
     * @param h
     */
    static deleteSessionDev(r, h) {
        MotorsRouter.sessionDB.remove(r.params.sessionId);
        return h.response().code(204);
    }
    /**
     * Delete all sessions. Debug route.
     * @param r
     * @param h
     */
    static deleteAllSessionsDev(r, h) {
        MotorsRouter.sessionDB.remove();
        return h.response().code(204);
    }
    /**
     * Get sessions histo. Debug route.
     * @param r
     * @param h
     */
    static async getSessionHisto(r, h) {
        const { sessionId } = r.params;
        const session = MotorsRouter.sessionDB.get((eachSession) => eachSession._id === sessionId);
        if (!session) {
            throw boom.notFound(`found no session with id ${sessionId}`);
        }
        try {
            const historic = await histoRenderer_1.default.render(session);
            return h.view(HISTO_PATH, { sessionId: session._id, historic });
        }
        catch (up) {
            return h.response(responseError(up)).code(400);
        }
    }
}
MotorsRouter.getModelRoute = Object.assign({ handler: MotorsRouter.getModel, description: "Get MTR game model", notes: "Retrieve the game model", validate: {
        params: {
            serviceName: swagger_1.Schema.shared.serviceName.required(),
        },
    } }, HAPI_DEFAULT_OPTIONS({ schema: swagger_1.Schema.mtr.model }));
MotorsRouter.getSessionRoute = Object.assign({ handler: MotorsRouter.getSession, description: "Get MTR session", notes: "Retrieve one player's opened session for the game", validate: {
        params: {
            serviceName: swagger_1.Schema.shared.serviceName.required(),
        },
    } }, HAPI_DEFAULT_OPTIONS({ schema: swagger_1.Schema.mtr.session }));
MotorsRouter.betRoute = Object.assign({ handler: MotorsRouter.bet, description: "MTR bet. (Create session)", notes: "MTR bet will create a MTR game session.", validate: {
        params: {
            serviceName: swagger_1.Schema.shared.serviceName.required(),
        },
        payload: swagger_1.Schema.mtr.betRequest.required(),
    } }, HAPI_DEFAULT_OPTIONS({ schema: swagger_1.Schema.mtr.betResponse }));
MotorsRouter.updateBetRoute = Object.assign({ handler: MotorsRouter.updateBet, description: "MTR update bet. (Execute).", notes: "MTR update bet. Execute.", validate: {
        params: {
            serviceName: swagger_1.Schema.shared.serviceName.required(),
        },
        payload: swagger_1.Schema.mtr.updateBetRequest.required(),
    } }, HAPI_DEFAULT_OPTIONS({ schema: swagger_1.Schema.mtr.betResponse }));
MotorsRouter.getGameRoute = Object.assign({ handler: MotorsRouter.getGame, description: "[ADMIN] MTR get game.", notes: "MTR get game.", validate: {
        query: swagger_1.Schema.mtr.getGameRequest,
    } }, HAPI_DEFAULT_OPTIONS());
MotorsRouter.getPrsTicketInfosRoute = Object.assign({ handler: MotorsRouter.getPrsTicketInfos, description: "PRS get ticket infos.", notes: "Retrieve a presto game ticket info an context", validate: {
        params: {
            serviceName: swagger_1.Schema.shared.serviceName.required(),
        },
    } }, HAPI_DEFAULT_OPTIONS({ schema: swagger_1.Schema.mtr.prestoTicketInfos }));
MotorsRouter.getMockRoute = Object.assign({ handler: MotorsRouter.getMock, description: "[ADMIN] Get MTR mocks.", notes: "Retrieve registered MTR mock values", validate: {
        query: {
            gameModelId: swagger_1.Schema.mtr.gameModelId.required(),
        },
    } }, HAPI_DEFAULT_OPTIONS({ schema: swagger_1.Schema.mtr.mocksValues }));
MotorsRouter.addMockRoute = Object.assign({ handler: MotorsRouter.addMock, description: "[ADMIN] Add MTR mocks.", notes: "MTR mocks are added for a specifi gmid and a specific player. Mocks are number values that will be later consumed by the RNG on each draw.", validate: {
        query: swagger_1.Schema.mtr.addMockRequest.required(),
    } }, HAPI_DEFAULT_OPTIONS());
MotorsRouter.resetMockRoute = Object.assign({ handler: MotorsRouter.resetMock, description: "[ADMIN] MTR reset mocks.", notes: "Delete all mocks for a gmid and a player.", validate: {
        query: {
            gameModelId: swagger_1.Schema.mtr.gameModelId.required(),
        },
    } }, HAPI_DEFAULT_OPTIONS());
MotorsRouter.getSessionsDevRoute = Object.assign({ handler: MotorsRouter.getSessionsDev, description: "[ADMIN] MTR get sessions.", notes: "List sessions history urls" }, HAPI_DEFAULT_OPTIONS());
MotorsRouter.deleteSessionDevRoute = Object.assign({ handler: MotorsRouter.deleteSessionDev, description: "[ADMIN] MTR delete session, debug route.", notes: "MTR delete session, debug route.", validate: {
        params: {
            sessionId: swagger_1.Schema.mtr.sessionId.required(),
        },
    } }, HAPI_DEFAULT_OPTIONS());
MotorsRouter.deleteAllSessionsDevRoute = Object.assign({ handler: MotorsRouter.deleteAllSessionsDev, description: "[ADMIN] MTR delete all sessions, debug route.", notes: "MTR delete all sessions, debug route." }, HAPI_DEFAULT_OPTIONS());
MotorsRouter.getSessionHistoRoute = Object.assign({ handler: MotorsRouter.getSessionHisto, description: "[ADMIN] MTR get session histo, debug route.", notes: "MTR get session histo, debug route.", validate: {
        params: {
            sessionId: swagger_1.Schema.mtr.sessionId.required(),
        },
    } }, HAPI_DEFAULT_OPTIONS());
function responseOK(data, messages, id) {
    const response = {
        res: "ok",
        message: messages ? messages : [],
    };
    if (data) {
        response.data = data;
    }
    if (id) {
        response.id = id;
    }
    return response;
}
exports.responseOK = responseOK;
function responseError(exception) {
    if ("getMotorsError" in exception) {
        return exception.getMotorsError();
    }
    return exception.message;
}
exports.responseError = responseError;
/**
 * Returns the playerId from an HAPI request
 * playerId can be set as a query param of the URL of the caller, or from cookies
 * @param request: the Hapi.request
 */
function getRequestToken(request) {
    if (request && request.headers && request.headers.token !== undefined) {
        return request.headers.token;
    }
    else if (request && request.headers && request.headers.referer) {
        return (0, helpers_2.getRefererParameters)(request.headers.referer).token || "default-token";
    }
    return "default-token";
}
//# sourceMappingURL=motors.js.map