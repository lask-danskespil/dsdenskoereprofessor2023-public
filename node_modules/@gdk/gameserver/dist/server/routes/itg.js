"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ITGRoutes = exports.getRoutes = void 0;
const helpers_1 = require("../helpers");
const errors = __importStar(require("../models/errors"));
const player_1 = require("../models/player");
const swagger_1 = require("./swagger");
const apiError_1 = require("./apiError");
const ACCEPTED_CONTENT_TYPES = [
    "application/vnd.lotsys.xs.itg.bet.list-1+json",
    "application/json",
];
const CONTENT_TYPE = "application/vnd.lotsys.xs.itg.bet.result.list-1+json; charset=utf-8";
function getRoutes(betManager) {
    return [
        ITGRoutes.getModel(betManager),
        // player services
        ITGRoutes.getTicketById(betManager),
        ITGRoutes.getTickets(betManager),
        ITGRoutes.createBet(betManager),
        ITGRoutes.updateBet(betManager),
        // admin services
        ITGRoutes.getTicketByIdAdmin(betManager),
        ITGRoutes.getTicketsAdmin(betManager),
        ITGRoutes.removeTicketByIdAdmin(betManager),
        // mock services
        ITGRoutes.mockAdd(betManager),
        ITGRoutes.mockGet(betManager),
        ITGRoutes.mockReset(betManager),
        // deprecated
        ITGRoutes.createDeprecatedBet(betManager), // deprecated bet
    ];
}
exports.getRoutes = getRoutes;
class ITGRoutes {
    /**
     * Retrieve game model
     * @param betManager
     */
    static getModel(betManager) {
        // TODO: implement
        return {
            method: "GET",
            path: `/itg/{serviceName}/model`,
            options: {
                handler: async (request, h) => {
                    try {
                        const model = betManager.getModel(request.params.serviceName);
                        return h.response(model).code(200);
                    }
                    catch (e) {
                        return h.response(e).code(400);
                    }
                },
                description: "Get ITG model",
                notes: `ITG Model for a given serviceName`,
                plugins: {
                    "hapi-swagger": {
                        responses: {
                            200: {
                                description: "Success",
                                schema: swagger_1.Schema.itg.model,
                            },
                            400: {
                                description: "Bad Request",
                                schema: swagger_1.Schema.shared.error,
                            },
                        },
                    },
                },
                validate: {
                    params: {
                        serviceName: swagger_1.Schema.shared.serviceName.required(),
                    },
                },
                tags: [swagger_1.TAGS.API, swagger_1.TAGS.ITG],
            },
        };
    }
    /**
     * Retrieve tickets
     * @param betManager
     */
    static getTickets(betManager) {
        return {
            method: "GET",
            path: `/itg/tickets`,
            options: {
                handler: async (request, h) => {
                    try {
                        const player = player_1.Player.getPlayer(request);
                        const tickets = betManager.getTickets(request.query, player);
                        return h.response(tickets).code(200);
                    }
                    catch (e) {
                        return h.response(e).code(400);
                    }
                },
                description: "Get ITG tickets for the current player",
                notes: `If a serviceName is provided it will only return tickets for this serviceName, if a status is provided it will also filter on status`,
                plugins: {
                    "hapi-swagger": {
                        responses: {
                            200: {
                                description: "Success",
                                schema: swagger_1.Schema.itg.tickets,
                            },
                            400: {
                                description: "Bad Request",
                                schema: swagger_1.Schema.shared.error,
                            },
                        },
                    },
                },
                validate: {
                    headers: swagger_1.Schema.playerHeaders,
                    query: swagger_1.Schema.itg.ticketFilters.append({
                        demoMode: swagger_1.Schema.itg.demoMode,
                    }),
                },
                tags: [swagger_1.TAGS.API, swagger_1.TAGS.ITG],
            },
        };
    }
    /**
     * get ticket by id
     * @param betManager
     */
    static getTicketById(betManager) {
        return {
            method: "GET",
            path: `/itg/tickets/{id}`,
            options: {
                handler: async (request, h) => {
                    try {
                        const player = player_1.Player.getPlayer(request);
                        const ticket = betManager.getTicketById(parseInt(request.params.id, 10), player);
                        return h.response(ticket ? [ticket] : undefined).code(200);
                    }
                    catch (e) {
                        return h.response(e).code(400);
                    }
                },
                description: "Get ITG a specific ticket (only for current player)",
                notes: `Get a ticket for a specific ticketId (either opened or claimed).
				Note that it won't return another player ticket.`,
                plugins: {
                    "hapi-swagger": {
                        responses: {
                            200: {
                                description: "Success",
                                schema: swagger_1.Schema.itg.ticket,
                            },
                            400: {
                                description: "Bad Request",
                                schema: swagger_1.Schema.shared.error,
                            },
                        },
                    },
                },
                validate: {
                    headers: swagger_1.Schema.playerHeaders,
                    params: {
                        id: swagger_1.Schema.itg.ticketId.required(),
                    },
                },
                tags: [swagger_1.TAGS.API, swagger_1.TAGS.ITG],
            },
        };
    }
    /**
     * Create a bet
     * @param betManager
     */
    static createBet(betManager) {
        return {
            method: "POST",
            path: `/itg/{serviceName}/tickets`,
            options: {
                handler: async (request, h) => {
                    var _a;
                    try {
                        const player = player_1.Player.getPlayer(request);
                        player.assert();
                        const ticket = await betManager.handleBetRequest({
                            amount: request.payload.stake,
                            gameName: request.params.serviceName,
                            demo: ((_a = request.query.demoMode) !== null && _a !== void 0 ? _a : "false").toString() === "true",
                            betMode: request.payload.mediaType,
                        }, player);
                        const data = request.payload.data;
                        Object.assign(ticket.data, data);
                        return h.response(ticket).code(200);
                    }
                    catch (e) {
                        return h.response(apiError_1.ApiError.t(e)).code(400);
                    }
                },
                description: "Create an ITG bet on a specific serviceName",
                notes: `The ticket will remained open until claimed`,
                plugins: {
                    "hapi-swagger": {
                        responses: {
                            200: {
                                description: "Success",
                                schema: swagger_1.Schema.itg.betResponse,
                            },
                            400: {
                                description: "Bad Request",
                                schema: swagger_1.Schema.shared.error,
                            },
                        },
                    },
                },
                validate: {
                    headers: swagger_1.Schema.playerHeaders,
                    query: {
                        demoMode: swagger_1.Schema.itg.demoMode.optional(),
                    },
                    params: {
                        serviceName: swagger_1.Schema.shared.serviceName.required(),
                    },
                    payload: swagger_1.Schema.itg.betRequest.required(),
                },
                tags: [swagger_1.TAGS.API, swagger_1.TAGS.ITG],
            },
        };
    }
    /**
     * Update a bet
     * @param betManager
     */
    static updateBet(betManager) {
        return {
            method: "PUT",
            path: `/itg/{serviceName}/tickets/{id}`,
            options: {
                handler: async (request, h) => {
                    try {
                        const player = player_1.Player.getPlayer(request);
                        const data = request.payload.data;
                        const ticket = betManager.updateTicket(parseInt(request.params.id, 10), data, player);
                        return h.response(ticket).code(200);
                    }
                    catch (e) {
                        return h.response(e).code(400);
                    }
                },
                description: "Update an opened ticket",
                notes: `Either to update ticket data or to claim the prize`,
                plugins: {
                    "hapi-swagger": {
                        responses: {
                            200: {
                                description: "Success",
                                schema: swagger_1.Schema.itg.betResponse,
                            },
                            400: {
                                description: "Bad Request",
                                schema: swagger_1.Schema.shared.error,
                            },
                        },
                    },
                },
                validate: {
                    headers: swagger_1.Schema.playerHeaders,
                    params: {
                        serviceName: swagger_1.Schema.shared.serviceName.required(),
                        id: swagger_1.Schema.itg.ticketId.required(),
                    },
                    query: {
                        demoMode: swagger_1.Schema.itg.demoMode,
                    },
                    payload: swagger_1.Schema.itg.betRequest,
                },
                tags: [swagger_1.TAGS.API, swagger_1.TAGS.ITG],
            },
        };
    }
    /**
     * Add some mocks for future bet
     * @param betManager
     */
    static mockAdd(betManager) {
        return {
            method: "POST",
            path: `/itg/admin/mock/{serviceName}`,
            options: {
                handler: async (request, h) => {
                    try {
                        const player = player_1.Player.getPlayer(request);
                        const data = request.payload;
                        betManager.addMocks(request.params.serviceName, player, data);
                        return h.response().code(204);
                    }
                    catch (e) {
                        return h.response(e).code(400);
                    }
                },
                description: "Add some mock data for a given player and a given service",
                notes: `Mocks will be appended to existing ones, these will control the result of the next createBet`,
                plugins: {
                    "hapi-swagger": {
                        responses: {
                            204: {
                                description: "Success",
                            },
                            400: {
                                description: "Bad Request",
                                schema: swagger_1.Schema.shared.error,
                            },
                        },
                    },
                },
                validate: {
                    headers: swagger_1.Schema.playerHeaders,
                    params: {
                        serviceName: swagger_1.Schema.shared.serviceName.required(),
                    },
                    payload: swagger_1.Schema.itg.mocks,
                },
                tags: [swagger_1.TAGS.API, swagger_1.TAGS.ITG],
            },
        };
    }
    /**
     * Get mocks values
     * @param betManager
     */
    static mockGet(betManager) {
        return {
            method: "GET",
            path: `/itg/admin/mock/{serviceName}`,
            options: {
                handler: async (request, h) => {
                    try {
                        const player = player_1.Player.getPlayer(request);
                        return h
                            .response(h.response(betManager.getMocks(request.params.serviceName, player)))
                            .code(200);
                    }
                    catch (e) {
                        return h.response(e).code(400);
                    }
                },
                description: "Retrive the list of registered mocks for a given player (and a given service)",
                notes: `Delete it without claiming, used as admin`,
                plugins: {
                    "hapi-swagger": {
                        responses: {
                            200: {
                                description: "Success",
                            },
                            400: {
                                description: "Bad Request",
                                schema: swagger_1.Schema.shared.error,
                            },
                        },
                    },
                },
                validate: {
                    headers: swagger_1.Schema.playerHeaders,
                    params: {
                        serviceName: swagger_1.Schema.shared.serviceName.required(),
                    },
                },
                tags: [swagger_1.TAGS.API, swagger_1.TAGS.ITG],
            },
        };
    }
    /**
     * Delete mocks values
     * @param betManager
     */
    static mockReset(betManager) {
        return {
            method: "DELETE",
            path: `/itg/admin/mock/{serviceName}`,
            options: {
                handler: async (request, h) => {
                    try {
                        const player = player_1.Player.getPlayer(request);
                        betManager.removeMocks(request.params.serviceName, player);
                        return h.response(h.response()).code(204);
                    }
                    catch (e) {
                        return h.response(e).code(400);
                    }
                },
                description: "Removes mocks for a given player (and a given service)",
                notes: `Delete all registered mocks`,
                plugins: {
                    "hapi-swagger": {
                        responses: {
                            204: {
                                description: "Success",
                            },
                            400: {
                                description: "Bad Request",
                                schema: swagger_1.Schema.shared.error,
                            },
                        },
                    },
                },
                validate: {
                    headers: swagger_1.Schema.playerHeaders,
                    params: {
                        serviceName: swagger_1.Schema.shared.serviceName.required(),
                    },
                },
                tags: [swagger_1.TAGS.API, swagger_1.TAGS.ITG],
            },
        };
    }
    /**
     * Delete ticket by ticketId
     * @param betManager
     */
    static removeTicketByIdAdmin(betManager) {
        return {
            method: "DELETE",
            path: `/itg/admin/tickets/{id}`,
            options: {
                handler: async (request, h) => {
                    try {
                        betManager.removeTicketById(Number.parseInt(request.params.id, 10));
                        return h.response().code(204);
                    }
                    catch (e) {
                        return h.response(e).code(400);
                    }
                },
                description: "[ADMIN] Removes a specific ticket",
                notes: `Delete it without claiming, used as admin`,
                plugins: {
                    "hapi-swagger": {
                        responses: {
                            200: {
                                description: "Success",
                            },
                            400: {
                                description: "Bad Request",
                                schema: swagger_1.Schema.shared.error,
                            },
                        },
                    },
                },
                validate: {
                    params: {
                        id: swagger_1.Schema.itg.ticketId.required(),
                    },
                },
                tags: [swagger_1.TAGS.API, swagger_1.TAGS.ITG],
            },
        };
    }
    /**
     * Get a specific ticket
     * @param betManager
     */
    static getTicketByIdAdmin(betManager) {
        return {
            method: "GET",
            path: `/itg/admin/tickets/{id}`,
            options: {
                handler: async (request, h) => {
                    try {
                        const ticket = betManager.getTicketById(Number.parseInt(request.params.id, 10));
                        return h.response(ticket).code(200);
                    }
                    catch (e) {
                        return h.response(e).code(400);
                    }
                },
                description: "[ADMIN] Get a specific ticket",
                notes: `used as admin`,
                plugins: {
                    "hapi-swagger": {
                        responses: {
                            200: {
                                description: "Success",
                                schema: swagger_1.Schema.itg.ticket,
                            },
                            400: {
                                description: "Bad Request",
                                schema: swagger_1.Schema.shared.error,
                            },
                        },
                    },
                },
                validate: {
                    params: {
                        id: swagger_1.Schema.itg.ticketId.required(),
                    },
                },
                tags: [swagger_1.TAGS.API, swagger_1.TAGS.ITG],
            },
        };
    }
    /**
     * Get a specific player tickets
     * @param betManager
     */
    static getTicketsAdmin(betManager) {
        return {
            method: "GET",
            path: `/itg/admin/tickets`,
            options: {
                handler: async (request, h) => {
                    try {
                        const player = request.query.playerId
                            ? player_1.Player.getPlayerFromId(request.query.playerId)
                            : undefined;
                        const tickets = betManager.getTickets(request.query, player);
                        return h.response(tickets).code(200);
                    }
                    catch (e) {
                        return h.response(e).code(400);
                    }
                },
                description: "[ADMIN] Get tickets",
                notes: `Allows different filters`,
                plugins: {
                    "hapi-swagger": {
                        responses: {
                            200: {
                                description: "Success",
                                schema: swagger_1.Schema.itg.tickets,
                            },
                            400: {
                                description: "Bad Request",
                                schema: swagger_1.Schema.shared.error,
                            },
                        },
                    },
                },
                validate: {
                    query: swagger_1.Schema.itg.ticketFilters.append({
                        playerId: swagger_1.Schema.player.playerId,
                        demoMode: swagger_1.Schema.itg.demoMode,
                    }),
                },
                tags: [swagger_1.TAGS.API, swagger_1.TAGS.ITG],
            },
        };
    }
    /**
     * Legacy bet
     * @param betManager
     */
    static createDeprecatedBet(betManager) {
        return {
            method: "POST",
            path: "/games/itg/bet",
            options: {
                handler: async (r, h) => {
                    let response;
                    const player = player_1.Player.getPlayer(r);
                    try {
                        const payload = JSON.parse(r.payload);
                        const responseObject = await betManager.handleBetRequests(payload, player);
                        response = h.response(responseObject);
                    }
                    catch (err) {
                        (0, helpers_1.stderr)(err);
                        response = h.response(errors.UNEXPECTED_ERROR.itg).code(500);
                    }
                    return response.header("Content-Type", CONTENT_TYPE);
                },
                payload: {
                    parse: false,
                    allow: ACCEPTED_CONTENT_TYPES,
                },
                description: "Deprecated ITG bet",
                notes: `Creates ITG bet the old way (not bet&claim)`,
                plugins: {
                    "hapi-swagger": {
                        responses: {
                            200: {
                                description: "Success",
                                schema: swagger_1.Schema.itg.deprecatedTicket,
                            },
                            400: {
                                description: "Bad Request",
                                schema: swagger_1.Schema.shared.error,
                            },
                        },
                    },
                },
                tags: [swagger_1.TAGS.API, swagger_1.TAGS.DEPRECATED],
            },
        };
    }
}
exports.ITGRoutes = ITGRoutes;
//# sourceMappingURL=itg.js.map