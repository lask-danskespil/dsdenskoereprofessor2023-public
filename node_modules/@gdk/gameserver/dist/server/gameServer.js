"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = void 0;
const commander_1 = __importDefault(require("commander"));
const inquirer_1 = __importDefault(require("inquirer"));
const fs_extra_1 = require("fs-extra");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const backutils_1 = require("@gdk/backutils");
const gameRunner_1 = require("./gameRunner");
function run() {
    const { version } = (0, fs_extra_1.readJSONSync)(path_1.default.resolve(__dirname, "../../package.json"));
    new commander_1.default.Command()
        .version(version)
        .usage("gameServer [game] [options]")
        .arguments("[game]") // either gameConf file or game name from game package.json
        .action(action)
        .option("-p, --port <value>", "Port to use, default 1337", (v) => parseInt(v, 10), 1337)
        .option("-d, --gameDirectory <value>", "Directory of the game to run, defaultly current directory.", process.cwd())
        .option("-l, --logLevel <level>", `Log level to use for logger, default:info`, /^(error|warn|info|http|verbose|debug|silly)$/, "info")
        .option("-s, --services <commaSeparatedList>", `A list of backend scripts. Exemple: "serviceName:/path/to/the/croupier,anotherOne:/path/to/the/other"`, parseScripts, null)
        .parse(process.argv);
}
exports.run = run;
function parseScripts(val) {
    return val.split(",").reduce((result, each) => {
        const [serviceName, pathToService] = each.split(":");
        if (!serviceName || !pathToService) {
            throw new Error(`Could not parse scripts list. It should match the pattern "serviceName:/some/path,anotherService:/another/path".`);
        }
        result[serviceName] = pathToService;
        return result;
    }, {});
}
async function action(gameToRun, command) {
    // Configure logger
    backutils_1.logger.level = command.logLevel;
    // exit nice on signal
    (0, backutils_1.watchProcess)();
    const gamePackageJson = require(path_1.default.resolve(command.gameDirectory, "package.json"));
    const games = gamePackageJson.games;
    const keys = Object.keys(games);
    if (!gameToRun) {
        if (keys.length === 1) {
            gameToRun = keys[0];
        }
        else {
            gameToRun = (await inquirer_1.default.prompt([
                {
                    name: "question",
                    message: "Which game do you want to run ?",
                    type: "list",
                    choices: keys.map((key) => {
                        return {
                            value: games[key],
                            name: key,
                        };
                    }),
                },
            ])).question;
        }
    }
    const confFile = games[gameToRun] || gameToRun;
    if (!fs_1.default.existsSync(path_1.default.resolve(command.gameDirectory, confFile))) {
        backutils_1.logger.error(`Unable to find something to run for entry : ${gameToRun}`);
        process.exit();
    }
    else {
        // Launch server
        const runner = new gameRunner_1.GameRunner();
        await runner.execute({
            port: command.port,
            gameDirectory: command.gameDirectory,
            gameConf: confFile,
            services: command.services,
        });
    }
}
//# sourceMappingURL=gameServer.js.map