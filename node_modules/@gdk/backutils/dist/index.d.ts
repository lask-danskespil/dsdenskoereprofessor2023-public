declare module "@gdk/backutils" {
	export * from "@gdk/backutils/gameConfig";
	export * from "@gdk/backutils/jsonValidator";
	export * from "@gdk/backutils/logger";
	export * from "@gdk/backutils/processManager";
	export * from "@gdk/backutils/croupierJson";
}

declare module "@gdk/backutils/gameConfig" {
	type EVENTS = "loaded";
	export enum EEngine {
	    ITG = "ITG",
	    MTR = "MTR",
	    MTP = "MTP"
	}
	export enum EProvider {
	    FDJ = "FDJ",
	    DKS = "DKS",
	    NKT = "NKT",
	    VKS = "VKS",
	    SVS = "SVS",
	    LOR = "LOR"
	}
	export enum EGameProvider {
	    FDJ = "FDJ",
	    DKS = "DKS",
	    NKT = "NKT",
	    VKS = "VKS",
	    SVS = "SVS",
	    LOR = "LOR"
	}
	export enum EBetMode {
	    AUTO = "BET_AUTO_CLAIM",
	    MANUAL = "BET_MANUAL_CLAIM"
	}
	export enum EJackpotProgressionType {
	    Progressive = "PROGRESSIVE",
	    Fixed = "FIXED"
	}
	export interface IAmount {
	    value: number;
	    currency: string;
	    scale?: number;
	}
	export interface INumberOfStakes {
	    min: number;
	    max?: number;
	}
	export interface IAssets {
	    themes: Record<string, string>;
	    i18n: Record<string, string>;
	    behaviours: Record<string, string>;
	    services: Record<string, string>;
	}
	export interface IGameDescription {
	    numberOfStakes: INumberOfStakes;
	    isJackpot?: boolean;
	    isConversion?: boolean;
	    jackpotCompatible?: boolean;
	    demoCompatible?: boolean;
	    replayCompatible?: boolean;
	    supportedBetModes?: EBetMode[];
	    assets: IAssets;
	}
	export interface IJackpotParticipation {
	    /**
	     * full bet amount (ex: 2€)
	     */
	    gameBetAmount: IAmount;
	    /**
	     * part of the amount used for the jackpot (ex: 0,02€)
	     */
	    jackpotBetAmount: IAmount;
	    /**
	     * number of participations that is bought when using this game bet amount.
	     * (ex: 1 participation for 1€ and 2 participations for 2€)
	     */
	    participationCount: number;
	}
	export interface IJackpotsConfiguration {
	    configurationName: string;
	    jackpots: IJackpotDetails[];
	    participations: IJackpotParticipation[];
	}
	export interface IJackpotDetails {
	    jackpotExternalId: string;
	    progressionType: EJackpotProgressionType;
	    initialAmount: IAmount;
	}
	export interface IJackpotsLotteryConfiguration {
	    amount: IAmount;
	}
	export interface IDemo {
	    enabled: boolean;
	    forceAuthentication: boolean;
	}
	export interface IGameConfiguration {
	    schemaVersion: number;
	    masterGameCode: string;
	    masterGameLabel: string;
	    masterGameDescription?: string;
	    version: string;
	    engine: EEngine;
	    gameProvider: EGameProvider;
	    engineProvider: EProvider;
	    gdkVersion: string;
	    bridgeVersion: string;
	    gameDescription: IGameDescription;
	    lotteryCode: string;
	    lotteryGameCode: string;
	    lotteryGameLabel: string;
	    lotteryGameDescription: string;
	    stakes: IAmount[];
	    jackpots: IJackpotsConfiguration;
	    demo: IDemo;
	    selectedBetMode?: EBetMode;
	    selectedTheme: string;
	    selectedLocale: string;
	    selectedBehaviour: string;
	    modules: any;
	    loader: any;
	    gameParameters: any;
	    behaviourParameters: any;
	    defaultStakeIndex?: number;
	    main: string;
	}
	export interface IGameAttrs {
	    gameType: string;
	    currency: string;
	    locale: string;
	    theme: string;
	}
	/**
	 * Manag systemJS configuration
	 */
	export class GameConfig {
	    private gameDir;
	    private gameConf;
	    private config;
	    private systemJsConfig;
	    private watcher;
	    private eventEmitter;
	    private validator;
	    constructor(gameDir: string, gameConf: string);
	    /**
	     * Stop watching configuration.
	     */
	    close(): void;
	    /**
	     * Get raw configuration object.
	     */
	    getConfig(): IGameConfiguration;
	    /**
	     * Get masterGameCode.
	     */
	    get masterGameCode(): string;
	    /**
	     * Get lottery game code
	     */
	    get lotteryGameCode(): string;
	    /**
	     * Get list of services.
	     */
	    get services(): {
	        [index: string]: string;
	    };
	    /**
	     * Returns a SystemJS config based on modules section of game.config.json.
	     */
	    getSystemJsConfig(): object;
	    /**
	     * Get game engine.
	     */
	    get engine(): string;
	    /**
	     * Get provider.
	     */
	    get provider(): string;
	    /**
	     * Returns true if jackpot is enabled.
	     */
	    get isJackpotEnabled(): boolean;
	    get jackpotConfig(): IJackpotsConfiguration;
	    /**
	     * Load game.config.json file & watch it.
	     */
	    load(options: {
	        watch: boolean;
	    }): void;
	    private loadConfig;
	    /**
	     * as watch works in "background" we log error in the method
	     */
	    private watch;
	    private unwatch;
	    /**
	     * Listen events.
	     */
	    on(event: EVENTS, listener: () => void): void;
	    private emit;
	    /**
	     * Get current locale value.
	     */
	    get locale(): string;
	    /**
	     * Set current locale value.
	     */
	    set locale(locale: string);
	    /**
	     * Get currency code
	     */
	    get currency(): string;
	    /**
	     * Returns available locales code base on config file assets/i18n configuration
	     */
	    getAvailableLocales(): string[];
	    /**
	     * Returns locale file path for a given locale name
	     * @locale string
	     */
	    getLocalePath(locale: string): string;
	    /**
	     * Returns avaialble themes in config file assets/themes if defined.
	     */
	    getAvailableThemes(): string[];
	    /**
	     * Returns theme folder path for a themeName
	     * @themeName string
	     */
	    getThemePath(themeName: string): string;
	    /**
	     * Get theme.
	     */
	    get theme(): string;
	    /**
	     * Get main path.
	     */
	    get main(): string;
	    /**
	     * Get modules.
	     */
	    get modules(): {
	        paths: {
	            [key: string]: string;
	        };
	    };
	    /**
	     * Build custom config for injection in the game loader.
	     */
	    get attrs(): IGameAttrs;
	    private get configFileName();
	    private get gdkConfigFileName();
	}
	export {};
}

declare module "@gdk/backutils/jsonValidator" {
	export class JsonValidator {
	    /**
	     * Instantiates JsonValidator with schema defined by path.
	     * @param path of the schema.
	     */
	    static fromSchemaFile(path: string): Promise<JsonValidator>;
	    private validator;
	    /**
	     * Builds JsonValidor
	     * @param schema to use.
	     */
	    constructor(schema: any);
	    /**
	     * Throws an Error if json does not match schema
	     */
	    assert(json: any): any;
	    /**
	     * Loads a given file and validate file content. If the content match json schema,
	     * file content is returned as a Json object, otherwise an Error() is thrown.
	     */
	    readJsonFile<T>(fileName: string): Promise<T>;
	    private getErrorsMessage;
	    private formattedErrorsMessage;
	}
}

declare module "@gdk/backutils/logger" {
	import * as winston from "winston";
	/**
	 * Use with logger.{level}(message)
	 * error:0
	 * warn:1
	 * info:2
	 * http:3
	 * verbose:4
	 * debug:5
	 * silly:6
	 */
	export const logger: winston.Logger;
}

declare module "@gdk/backutils/processManager" {
	export const watchProcess: () => void;
}

declare module "@gdk/backutils/croupierJson" {
	/**
	 * Id as a positive integer used to easily identify an object (rank, ticket)
	 */
	export type Id = number;
	/**
	 * Quantity
	 */
	export type Quantity = number;
	/**
	 * Name use to internally identify the product
	 */
	export type ProductName = string;
	/**
	 * Name of the master game the dealer is intended for
	 */
	export type MasterGameCode = string;
	/**
	 * Name of the engine game
	 */
	export type Code = string;
	/**
	 * Text used to describe the current product
	 */
	export type Description = string;
	/**
	 * Semver versionning of the croupier model
	 */
	export type ProductVersion = string;
	/**
	 * Smaller stake threshold. Any stake value multiple of this value will be accepted.
	 */
	export type BaseStake = number;
	/**
	 * A new pool will be added when tickets quantity in the pool is less or equal to the croupier renewal.
	 */
	export type CroupierRenewal = number;
	/**
	 * Text used to describe the rank
	 */
	export type RankLabel = string;
	/**
	 * Type of prizes of the rank (ex: PERIODIC_WINNING)
	 */
	export type PrizeType = string;
	/**
	 * Description of the prizes of the rank (ex: 1st Prize - 30kr.)
	 */
	export type PrizeDescription = string;
	/**
	 * String that encode the game data for the ticket
	 */
	export type StringSymbol = string;
	/**
	 * A new pool will be added when the rank tickets quantity is less or equal to the rank renewal.
	 */
	export type RankRenewal = number;
	/**
	 * Description of a revelation
	 * It can be either a json or a string
	 */
	export type SymbolDescription = string | any;
	/**
	 * Shape description
	 * It can be either a json or a string
	 * The Ticket class will receive it as parameter
	 */
	export type ShapeDescription = string | any;
	/**
	 * Shape used in config as a parameter for the ticket
	 */
	export type ShapeValue = string;
	/**
	 * Text used to describe the rank
	 */
	export type ShapeLabel = string;
	/**
	 * Primitive type
	 */
	export type PrimitiveType = string | number | boolean;
	/**
	 * Composed of a numerator and a denominator it represent the win factor for a rank given the formula win = stake*factor.num/factor.den.
	 * Be carefull that win must always be an integer.
	 */
	export interface IWinFactor {
	    /**
	     * Win factor numerator
	     */
	    numerator: number;
	    /**
	     * Win factor denominator
	     */
	    denominator: number;
	}
	/**
	 * Win factor of a rank
	 */
	export interface IRankWinFactor {
	    numerator: number;
	    denominator: number;
	}
	export interface ITicket {
	    id: number;
	    symbol: SymbolDescription;
	    quantity: number;
	    metadatas: ITicketMetaDatas;
	    customdatas?: any;
	    bonus?: boolean;
	    tv?: boolean;
	    extra?: boolean;
	}
	export interface ICroupierUsrInfos {
	    bicCode: number;
	    serviceName: string;
	    serviceCode: string;
	    type: string;
	    engineCode?: string;
	    description?: string;
	}
	export interface ITicketMetaDatas {
	    [index: string]: PrimitiveType;
	}
	export interface IRankMetaDatas {
	    [index: string]: PrimitiveType;
	}
	/**
	 * Shape for the generator to iterate on to create tickets
	 */
	export interface IShape {
	    quantity: Quantity;
	    value: ShapeValue;
	    dbRecordQuantity: Quantity;
	    label?: ShapeLabel;
	    bonus?: boolean;
	    tv?: boolean;
	    extra?: boolean;
	}
	/**
	 * Rank in croupier
	 */
	export interface IRank {
	    id: Id;
	    label?: RankLabel;
	    renewal?: RankRenewal;
	    factor: IWinFactor;
	    tickets?: ITicket[];
	    prizeType?: PrizeType;
	    prizeDescription?: PrizeDescription;
	}
	/**
	 * Rank in config
	 */
	export interface IRankConfig extends IRank {
	    id: Id;
	    label?: RankLabel;
	    renewal?: RankRenewal;
	    factor: IWinFactor;
	    tickets?: ITicket[];
	    shapes?: IShape[];
	    prizeType?: PrizeType;
	    prizeDescription?: PrizeDescription;
	}
	/**
	 * Croupier config
	 */
	export interface ICroupierConfig {
	    masterGameCode: MasterGameCode;
	    code: Code;
	    description?: Description;
	    renewal?: CroupierRenewal;
	    baseStake: number;
	    ranks: IRankConfig[];
	    parameters?: any;
	    infos?: ICroupierUsrInfos;
	    seed: string;
	    [k: string]: any;
	}
	/**
	 * Full JSON croupier
	 */
	export interface ICroupier {
	    productVersion: ProductVersion;
	    schemaVersion: number;
	    version: number;
	    date: number;
	    masterGameCode: MasterGameCode;
	    code: Code;
	    baseStake: BaseStake;
	    description: Description;
	    renewal: CroupierRenewal;
	    ranks: IRank[];
	    seed: string;
	    [k: string]: any;
	}
	export abstract class ATicketClass {
	    protected readonly conf: ICroupierConfig;
	    protected readonly rank: IRank;
	    protected readonly shape: IShape;
	    beforeAll?: (conf: ICroupierConfig) => void;
	    afterAll?: (conf: ICroupierConfig, croupier: ICroupier) => void;
	    bonus: boolean;
	    tv: boolean;
	    extra: boolean;
	    constructor(conf: ICroupierConfig, rank: IRank, shape: IShape);
	    /**
	     * Generates the string or json that describe the symbol
	     */
	    abstract toSymbol(): SymbolDescription;
	    /**
	     * Generates metadatas from Ticket
	     */
	    toMetadatas(): ITicketMetaDatas;
	}
}
