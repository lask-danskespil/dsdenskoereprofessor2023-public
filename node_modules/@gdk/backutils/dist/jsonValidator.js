"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonValidator = void 0;
const Ajv = require("ajv");
class JsonValidator {
    /**
     * Instantiates JsonValidator with schema defined by path.
     * @param path of the schema.
     */
    static async fromSchemaFile(path) {
        const schema = await require(path);
        return new JsonValidator(schema);
    }
    /**
     * Builds JsonValidor
     * @param schema to use.
     */
    constructor(schema) {
        const ajv = new Ajv({ allErrors: true });
        this.validator = ajv.compile(schema);
    }
    /**
     * Throws an Error if json does not match schema
     */
    assert(json) {
        const validation = this.validator(json);
        if (!validation) {
            throw new Error(this.formattedErrorsMessage());
        }
        return json;
    }
    /**
     * Loads a given file and validate file content. If the content match json schema,
     * file content is returned as a Json object, otherwise an Error() is thrown.
     */
    async readJsonFile(fileName) {
        const json = require(fileName);
        try {
            this.assert(json);
            return json;
        }
        catch (err) {
            throw new Error(`${fileName} is unvalid: ${err.message}`);
        }
    }
    getErrorsMessage() {
        return this.validator.errors.map((error) => {
            const extra = error.params ? JSON.stringify(error.params) : "";
            return `${error.dataPath} ${error.message} ${extra}`.trim();
        });
    }
    formattedErrorsMessage() {
        const separator = "\n\t- ";
        const errorMsg = this.getErrorsMessage().join(separator);
        return `${separator}${errorMsg}`;
    }
}
exports.JsonValidator = JsonValidator;
//# sourceMappingURL=jsonValidator.js.map