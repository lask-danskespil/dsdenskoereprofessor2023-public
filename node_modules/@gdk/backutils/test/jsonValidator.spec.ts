import "jest";

jest.mock("path", () => ({
	resolve: jest.fn(),
}));
const ajvInstance = {
	compile: jest.fn(),
};
jest.mock("ajv", () => {
	return function ajv() {
		return ajvInstance;
	};
});

import { resolve } from "path";
import { JsonValidator } from "../src/jsonValidator";

describe("jsonValidator", () => {
	beforeEach(() => {
		jest.resetAllMocks();
		jest.resetModules();
	});

	describe("static .fromSchemaFile & constructor", () => {
		test("should do something", async () => {
			jest.mock("./sample.json", () => "someSchema");
			ajvInstance.compile.mockReturnValue("someValidator");

			const instance = await JsonValidator.fromSchemaFile("../test/sample.json");

			expect(ajvInstance.compile).toHaveBeenCalledWith("someSchema");
			expect(instance).toHaveProperty("validator", "someValidator");
		});
	});

	describe(".assert", () => {
		let mockedInstance;
		beforeEach(() => {
			mockedInstance = {
				validator: jest.fn().mockReturnValue(true),
				formattedErrorsMessage: jest.fn().mockReturnValue("someError"),
			};
		});

		test("should forward to validator", () => {
			JsonValidator.prototype.assert.call(mockedInstance, "someJSON");

			expect(mockedInstance.validator).toHaveBeenCalledWith("someJSON");
			expect(mockedInstance.formattedErrorsMessage).not.toHaveBeenCalled();
		});

		test("should throw if validator returns false", () => {
			(mockedInstance.validator as jest.Mock).mockReturnValue(false);

			expect(JsonValidator.prototype.assert.bind(mockedInstance, "someJSON")).toThrowError(
				new Error("someError")
			);
			expect(mockedInstance.validator).toHaveBeenCalledWith("someJSON");
			expect(mockedInstance.formattedErrorsMessage).toHaveBeenCalled();
		});
	});

	describe(".readJsonFile", () => {
		let mockedInstance;

		beforeEach(() => {
			mockedInstance = {
				assert: jest.fn(),
			};
			jest.mock("./sample.json", () => "someSchema");
		});

		test("should get the file and assert it", async () => {
			const json = await JsonValidator.prototype.readJsonFile.call(
				mockedInstance,
				"../test/sample.json"
			);

			expect(mockedInstance.assert).toHaveBeenCalledWith("someSchema");
			expect(json).toEqual("someSchema");
		});

		test("should throw an error if assert throw", async () => {
			(mockedInstance.assert as jest.Mock).mockImplementation(() => {
				throw new Error("fooError");
			});

			await expect(
				JsonValidator.prototype.readJsonFile.call(mockedInstance, "../test/sample.json")
			).rejects.toThrowError(new Error("../test/sample.json is unvalid: fooError"));
		});
	});

	describe(".getErrorsMessage", () => {
		test("should generate errors messages", () => {
			const mockedInstance = {
				validator: {
					errors: [
						{
							params: { foo: "someParams" },
							dataPath: "path1",
							message: "message1",
						},
						{
							dataPath: "path2",
							message: "message2",
						},
					],
				},
			};

			const result = (JsonValidator.prototype as any).getErrorsMessage.call(mockedInstance);
			expect(result).toEqual([`path1 message1 {"foo":"someParams"}`, "path2 message2"]);
		});
	});

	describe(".formattedErrorsMessage", () => {
		test("should get errors message and merge them", () => {
			const mockedInstance = {
				getErrorsMessage: jest.fn().mockReturnValue(["error1", "error2"]),
			};

			const result = (JsonValidator.prototype as any).formattedErrorsMessage.call(mockedInstance);
			expect(result).toEqual("\n\t- error1\n\t- error2");
		});
	});
});
