import "jest";

jest.mock("fs-extra", () => ({
	existsSync: jest.fn(),
	readFileSync: jest.fn(),
}));
jest.mock("../src/jsonValidator", () => ({
	JsonValidator: jest.fn(),
}));
jest.mock("events", () => ({
	EventEmitter: jest.fn(),
}));
jest.mock("../src/data/gameConfig.json", () => "someSchema");

import { readFileSync, existsSync } from "fs-extra";
import { EventEmitter } from "events";
import { JsonValidator } from "../src/jsonValidator";
import { GameConfig } from "../src/gameConfig";

function getMockedGameConfig(mockedConfiguration: any): GameConfig {
	const mockedValidator = { assert: jest.fn().mockReturnValue(mockedConfiguration) };
	(JsonValidator as unknown as jest.Mock).mockImplementation(() => mockedValidator);
	const config = new GameConfig("", "");
	config.load({ watch: false });
	return config;
}

describe("gameConfig", () => {
	const mockedEventEmitter = { emit: jest.fn() };

	beforeEach(() => {
		jest.resetAllMocks();
		jest.resetModules();

		(readFileSync as jest.Mock).mockReturnValue("{}");
		(existsSync as jest.Mock).mockReturnValue(false);
		(EventEmitter as unknown as jest.Mock).mockImplementation(() => mockedEventEmitter);
	});

	describe(".constructor", () => {
		test("should instantiate a JsonValidator", () => {
			const gameConfiguration = new GameConfig("someDir", "confFile");

			expect(JsonValidator).toHaveBeenCalledWith("someSchema");
			expect(gameConfiguration).toHaveProperty("validator", {});
			expect(gameConfiguration).toHaveProperty("gameDir", "someDir");
			expect(gameConfiguration).toHaveProperty("gameConf", "confFile");
		});
	});

	describe(".close", () => {
		test("should call unwatch", () => {
			const mockedInstance = {
				unwatch: jest.fn(),
			};

			GameConfig.prototype.close.call(mockedInstance);

			expect(mockedInstance.unwatch).toHaveBeenCalled();
		});
	});

	describe(".getConfig", () => {
		test("should return raw config", () => {
			expect(GameConfig.prototype.getConfig.call({ config: "someConfig" })).toEqual("someConfig");
		});
	});

	describe("get masterGameCode", () => {
		test("should return raw masterGameCode", () => {
			const { get } = Object.getOwnPropertyDescriptor(GameConfig.prototype, "masterGameCode");
			expect(get.call({ config: { masterGameCode: "someName" } })).toEqual("someName");
		});
	});

	describe(".get services", () => {
		test("should return raw raw services name", () => {
			const { get } = Object.getOwnPropertyDescriptor(GameConfig.prototype, "services");
			expect(
				get.call({ config: { gameDescription: { assets: { services: "services" } } } })
			).toEqual("services");
		});
	});

	describe(".getSystemJsConfig", () => {
		test("should return raw systemjs config", () => {
			expect(GameConfig.prototype.getSystemJsConfig.call({ systemJsConfig: "someConfig" })).toEqual(
				"someConfig"
			);
		});
	});

	describe("get engine", () => {
		test("should return raw game engine", () => {
			const { get } = Object.getOwnPropertyDescriptor(GameConfig.prototype, "engine");
			expect(get.call({ config: { engine: "someName" } })).toEqual("someName");
		});
	});

	describe("get provider", () => {
		test("should return raw provider", () => {
			const { get } = Object.getOwnPropertyDescriptor(GameConfig.prototype, "provider");
			expect(get.call({ config: { gameProvider: "someName" } })).toEqual("someName");
		});
	});

	describe(".load", () => {
		test("should load config", () => {
			const rawConfiguration = { foo: "bar", modules: { a: "b" } };
			const mockedValidator = { assert: jest.fn().mockReturnValue(rawConfiguration) };
			(JsonValidator as unknown as jest.Mock).mockImplementation(() => mockedValidator);

			const config = new GameConfig("", "");

			config.load({ watch: false });

			expect(readFileSync).toHaveBeenCalled();
			expect(mockedValidator.assert).toHaveBeenCalled();
			expect((config as any).config).toHaveProperty("foo", "bar");
			expect((config as any).systemJsConfig).toEqual({ baseURL: "/game/local", a: "b" });
			expect(mockedEventEmitter.emit).toHaveBeenCalledWith("loaded");
		});
	});

	describe(".on", () => {
		test("should forward to eventEmitter", () => {
			const mockedInstance = {
				eventEmitter: { on: jest.fn() },
			};
			const mockedCallback = jest.fn();
			GameConfig.prototype.on.call(mockedInstance, "someEvent", mockedCallback);
			expect(mockedInstance.eventEmitter.on).toHaveBeenCalledWith("someEvent", mockedCallback);
		});
	});

	describe(".emit", () => {
		test("should forward to eventEmitter", () => {
			const mockedInstance = {
				eventEmitter: { emit: jest.fn() },
			};
			(GameConfig.prototype as any).emit.call(mockedInstance, "someEvent");
			expect(mockedInstance.eventEmitter.emit).toHaveBeenCalledWith("someEvent");
		});
	});

	describe("get locale", () => {
		test("should return locale current", () => {
			const config = getMockedGameConfig({
				selectedLocale: "someLocale",
			});
			expect(config.locale).toEqual("someLocale");
		});
	});

	describe("set locale", () => {
		test("should set locale current", () => {
			const config = getMockedGameConfig({
				locale: undefined,
			});

			config.locale = "someLocale";
			expect((config as any).config.selectedLocale).toEqual("someLocale");
		});
	});

	describe(".getAvailableLocales", () => {
		test("should get i18n assets keys", () => {
			const config = getMockedGameConfig({
				gameDescription: { assets: { i18n: { "fr-FR": "path/to/fr", "en-US": "path/to/us" } } },
			});
			expect(config.getAvailableLocales()).toEqual(["fr-FR", "en-US"]);
		});
	});

	describe(".getAvailableThemes", () => {
		test("should get themes assets keys", () => {
			const config = getMockedGameConfig({
				gameDescription: {
					assets: { themes: { noel: "path/to/theme/noel", summer: "path/to/theme/summer" } },
				},
			});
			expect(config.getAvailableThemes()).toEqual(["noel", "summer"]);
		});

		test("should return [] if no themes assets", () => {
			const config = getMockedGameConfig({
				gameDescription: { assets: { themes: {} } },
			});
			expect(config.getAvailableThemes()).toEqual([]);
		});
	});

	describe(".getLocalePath", () => {
		test("should get path to requested i18n", () => {
			const path = GameConfig.prototype.getLocalePath.call(
				{
					config: {
						gameDescription: {
							assets: {
								i18n: {
									a: "path/to/a",
									b: "path/to/b",
								},
							},
						},
					},
				},
				"b"
			);

			expect(path).toEqual("path/to/b");
		});
	});

	describe("get currency", () => {
		test("should return currency", () => {
			const config = getMockedGameConfig({
				stakes: [
					{
						value: 100,
						currency: "EUR",
					},
				],
			});
			expect(config.currency).toEqual("EUR");
		});
	});

	describe("get main", () => {
		test("should return main path", () => {
			const { get } = Object.getOwnPropertyDescriptor(GameConfig.prototype, "main");
			expect(get.call({ config: { main: "somePath" } })).toEqual("somePath");
		});
	});

	describe("get modules", () => {
		test("should return modules path", () => {
			const { get } = Object.getOwnPropertyDescriptor(GameConfig.prototype, "modules");
			expect(get.call({ config: { modules: "somePath" } })).toEqual("somePath");
		});
	});
});
