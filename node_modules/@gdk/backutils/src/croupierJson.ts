/**
 * Id as a positive integer used to easily identify an object (rank, ticket)
 */
export type Id = number;

/**
 * Quantity
 */
export type Quantity = number;

/**
 * Name use to internally identify the product
 */
export type ProductName = string;

/**
 * Name of the master game the dealer is intended for
 */
export type MasterGameCode = string;

/**
 * Name of the engine game
 */
export type Code = string;

/**
 * Text used to describe the current product
 */
export type Description = string;

/**
 * Semver versionning of the croupier model
 */
export type ProductVersion = string;

/**
 * Smaller stake threshold. Any stake value multiple of this value will be accepted.
 */
export type BaseStake = number;

/**
 * A new pool will be added when tickets quantity in the pool is less or equal to the croupier renewal.
 */
export type CroupierRenewal = number;

/**
 * Text used to describe the rank
 */
export type RankLabel = string;

/**
 * Type of prizes of the rank (ex: PERIODIC_WINNING)
 */
export type PrizeType = string;

/**
 * Description of the prizes of the rank (ex: 1st Prize - 30kr.)
 */
export type PrizeDescription = string;

/**
 * String that encode the game data for the ticket
 */
export type StringSymbol = string;

/**
 * A new pool will be added when the rank tickets quantity is less or equal to the rank renewal.
 */
export type RankRenewal = number;

/**
 * Description of a revelation
 * It can be either a json or a string
 */
export type SymbolDescription = string | any;

/**
 * Shape description
 * It can be either a json or a string
 * The Ticket class will receive it as parameter
 */
export type ShapeDescription = string | any;

/**
 * Shape used in config as a parameter for the ticket
 */
export type ShapeValue = string;

/**
 * Text used to describe the rank
 */
export type ShapeLabel = string;

/**
 * Primitive type
 */
export type PrimitiveType = string | number | boolean;

/**
 * Composed of a numerator and a denominator it represent the win factor for a rank given the formula win = stake*factor.num/factor.den.
 * Be carefull that win must always be an integer.
 */
export interface IWinFactor {
	/**
	 * Win factor numerator
	 */
	numerator: number;
	/**
	 * Win factor denominator
	 */
	denominator: number;
}

/**
 * Win factor of a rank
 */
export interface IRankWinFactor {
	numerator: number;
	denominator: number;
}

export interface ITicket {
	id: number;
	symbol: SymbolDescription;
	quantity: number;
	metadatas: ITicketMetaDatas;
	customdatas?: any;
	bonus?: boolean;
	tv?: boolean;
	extra?: boolean;
}

export interface ICroupierUsrInfos {
	bicCode: number;
	serviceName: string;
	serviceCode: string;
	type: string;
	engineCode?: string;
	description?: string;
}

export interface ITicketMetaDatas {
	[index: string]: PrimitiveType;
}

export interface IRankMetaDatas {
	[index: string]: PrimitiveType;
}

/**
 * Shape for the generator to iterate on to create tickets
 */
export interface IShape {
	quantity: Quantity;
	value: ShapeValue;
	dbRecordQuantity: Quantity;
	label?: ShapeLabel;
	bonus?: boolean;
	tv?: boolean;
	extra?: boolean;
}

/**
 * Rank in croupier
 */
export interface IRank {
	id: Id;
	label?: RankLabel;
	renewal?: RankRenewal;
	factor: IWinFactor;
	tickets?: ITicket[];
	prizeType?: PrizeType;
	prizeDescription?: PrizeDescription;
}

/**
 * Rank in config
 */
export interface IRankConfig extends IRank {
	id: Id;
	label?: RankLabel;
	renewal?: RankRenewal;
	factor: IWinFactor;
	tickets?: ITicket[];
	shapes?: IShape[];
	prizeType?: PrizeType;
	prizeDescription?: PrizeDescription;
}

/**
 * Croupier config
 */
export interface ICroupierConfig {
	masterGameCode: MasterGameCode;
	code: Code;
	description?: Description;
	renewal?: CroupierRenewal;
	baseStake: number;
	ranks: IRankConfig[];
	parameters?: any;
	infos?: ICroupierUsrInfos;
	seed: string;
	[k: string]: any;
}

/**
 * Full JSON croupier
 */
export interface ICroupier {
	productVersion: ProductVersion;
	schemaVersion: number;
	version: number;
	date: number;
	masterGameCode: MasterGameCode;
	code: Code;
	baseStake: BaseStake;
	description: Description;
	renewal: CroupierRenewal;
	ranks: IRank[];
	seed: string;
	[k: string]: any;
}

export abstract class ATicketClass {
	public beforeAll?: (conf: ICroupierConfig) => void;
	public afterAll?: (conf: ICroupierConfig, croupier: ICroupier) => void;

	public bonus: boolean;
	public tv: boolean;
	public extra: boolean;

	public constructor(
		protected readonly conf: ICroupierConfig,
		protected readonly rank: IRank,
		protected readonly shape: IShape
	) {
		this.tv = shape.tv;
		this.bonus = shape.bonus;
		this.extra = shape.extra;
	}

	/**
	 * Generates the string or json that describe the symbol
	 */
	public abstract toSymbol(): SymbolDescription;

	/**
	 * Generates metadatas from Ticket
	 */
	public toMetadatas(): ITicketMetaDatas {
		return { shape: this.shape.value };
	}
}
