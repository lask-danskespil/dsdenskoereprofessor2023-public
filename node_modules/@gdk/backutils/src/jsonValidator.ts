import * as Ajv from "ajv";

export class JsonValidator {
	/**
	 * Instantiates JsonValidator with schema defined by path.
	 * @param path of the schema.
	 */
	public static async fromSchemaFile(path: string): Promise<JsonValidator> {
		const schema = await require(path);
		return new JsonValidator(schema);
	}

	private validator: Ajv.ValidateFunction;

	/**
	 * Builds JsonValidor
	 * @param schema to use.
	 */
	public constructor(schema: any) {
		const ajv = new Ajv({ allErrors: true });
		this.validator = ajv.compile(schema);
	}

	/**
	 * Throws an Error if json does not match schema
	 */
	public assert(json: any): any {
		const validation = this.validator(json);
		if (!validation) {
			throw new Error(this.formattedErrorsMessage());
		}
		return json;
	}

	/**
	 * Loads a given file and validate file content. If the content match json schema,
	 * file content is returned as a Json object, otherwise an Error() is thrown.
	 */
	public async readJsonFile<T>(fileName: string): Promise<T> {
		const json = require(fileName);
		try {
			this.assert(json);
			return json;
		} catch (err) {
			throw new Error(`${fileName} is unvalid: ${err.message}`);
		}
	}

	private getErrorsMessage(): string[] {
		return this.validator.errors.map((error) => {
			const extra = error.params ? JSON.stringify(error.params) : "";
			return `${error.dataPath} ${error.message} ${extra}`.trim();
		});
	}

	private formattedErrorsMessage(): string {
		const separator = "\n\t- ";
		const errorMsg = this.getErrorsMessage().join(separator);
		return `${separator}${errorMsg}`;
	}
}
