import * as fs from "fs-extra";
import { join, basename } from "path";
import { EventEmitter } from "events";
import * as _ from "lodash";

import { logger } from "./logger";
import { JsonValidator } from "./jsonValidator";
import * as GAME_CONFIG_SCHEMA from "./data/gameConfig.json";

type EVENTS = "loaded";

export enum EEngine {
	ITG = "ITG",
	MTR = "MTR",
	MTP = "MTP",
}

export enum EProvider {
	FDJ = "FDJ",
	DKS = "DKS",
	NKT = "NKT",
	VKS = "VKS",
	SVS = "SVS",
	LOR = "LOR",
}

export enum EGameProvider {
	FDJ = "FDJ",
	DKS = "DKS",
	NKT = "NKT",
	VKS = "VKS",
	SVS = "SVS",
	LOR = "LOR",
}

export enum EBetMode {
	AUTO = "BET_AUTO_CLAIM",
	MANUAL = "BET_MANUAL_CLAIM",
}

export enum EJackpotProgressionType {
	Progressive = "PROGRESSIVE",
	Fixed = "FIXED",
}

export interface IAmount {
	value: number;
	currency: string;
	scale?: number;
}

export interface INumberOfStakes {
	min: number;
	max?: number;
}

export interface IAssets {
	themes: Record<string, string>;
	i18n: Record<string, string>;
	behaviours: Record<string, string>;
	services: Record<string, string>;
}

export interface IGameDescription {
	numberOfStakes: INumberOfStakes;
	isJackpot?: boolean;
	isConversion?: boolean;
	jackpotCompatible?: boolean;
	demoCompatible?: boolean;
	replayCompatible?: boolean;
	supportedBetModes?: EBetMode[];
	assets: IAssets;
}

export interface IJackpotParticipation {
	/**
	 * full bet amount (ex: 2€)
	 */
	gameBetAmount: IAmount;
	/**
	 * part of the amount used for the jackpot (ex: 0,02€)
	 */
	jackpotBetAmount: IAmount;
	/**
	 * number of participations that is bought when using this game bet amount.
	 * (ex: 1 participation for 1€ and 2 participations for 2€)
	 */
	participationCount: number;
}

export interface IJackpotsConfiguration {
	configurationName: string;
	jackpots: IJackpotDetails[];
	participations: IJackpotParticipation[];
}

export interface IJackpotDetails {
	jackpotExternalId: string;
	progressionType: EJackpotProgressionType;
	initialAmount: IAmount;
}

export interface IJackpotsLotteryConfiguration {
	amount: IAmount;
}

export interface IDemo {
	enabled: boolean;
	forceAuthentication: boolean;
}

export interface IGameConfiguration {
	schemaVersion: number;
	masterGameCode: string;
	masterGameLabel: string;
	masterGameDescription?: string;
	version: string;
	engine: EEngine;
	gameProvider: EGameProvider;
	engineProvider: EProvider;
	gdkVersion: string;
	bridgeVersion: string;
	gameDescription: IGameDescription;
	lotteryCode: string;
	lotteryGameCode: string;
	lotteryGameLabel: string;
	lotteryGameDescription: string;
	stakes: IAmount[];
	jackpots: IJackpotsConfiguration;
	demo: IDemo;
	selectedBetMode?: EBetMode;
	selectedTheme: string;
	selectedLocale: string;
	selectedBehaviour: string;
	modules: any;
	loader: any;
	gameParameters: any;
	behaviourParameters: any;
	defaultStakeIndex?: number;
	main: string;
}

export interface IGameAttrs {
	gameType: string;
	currency: string;
	locale: string;
	theme: string;
}

/**
 * Manag systemJS configuration
 */
export class GameConfig {
	private config: IGameConfiguration;
	private systemJsConfig: object;
	private watcher: fs.FSWatcher;
	private eventEmitter: EventEmitter = new EventEmitter();

	private validator: JsonValidator;

	public constructor(private gameDir: string, private gameConf: string) {
		this.validator = new JsonValidator(GAME_CONFIG_SCHEMA);
	}

	/**
	 * Stop watching configuration.
	 */
	public close(): void {
		this.unwatch();
	}

	/**
	 * Get raw configuration object.
	 */
	public getConfig(): IGameConfiguration {
		return this.config;
	}

	/**
	 * Get masterGameCode.
	 */
	public get masterGameCode(): string {
		return this.config.masterGameCode;
	}

	/**
	 * Get lottery game code
	 */
	public get lotteryGameCode(): string {
		return this.config.lotteryGameCode;
	}

	/**
	 * Get list of services.
	 */
	public get services(): { [index: string]: string } {
		return this.config.gameDescription.assets.services || {};
	}

	/**
	 * Returns a SystemJS config based on modules section of game.config.json.
	 */
	public getSystemJsConfig(): object {
		return this.systemJsConfig;
	}

	/**
	 * Get game engine.
	 */
	public get engine(): string {
		return this.config.engine;
	}

	/**
	 * Get provider.
	 */
	public get provider(): string {
		return this.config.gameProvider;
	}

	/**
	 * Returns true if jackpot is enabled.
	 */
	public get isJackpotEnabled(): boolean {
		return this.config.jackpots && this.config.jackpots.configurationName !== undefined;
	}

	public get jackpotConfig(): IJackpotsConfiguration {
		if (!this.config.jackpots) {
			return null;
		}

		// if no jackpots where set in the conf, set default jackpots
		if (!this.config.jackpots.jackpots || this.config.jackpots.jackpots.length === 0) {
			this.config.jackpots.jackpots = [
				{
					jackpotExternalId: "progressive",
					progressionType: EJackpotProgressionType.Progressive,
					initialAmount: {
						currency: "EUR",
						value: 5000000,
						scale: 2,
					},
				},
				{
					jackpotExternalId: "fixed",
					progressionType: EJackpotProgressionType.Fixed,
					initialAmount: {
						currency: "EUR",
						value: 5000,
						scale: 2,
					},
				},
			];
		}

		const participations = this.config.jackpots.participations ?? [];
		const stakes = this.config.stakes;

		for (const stake of stakes) {
			if (
				participations.every(
					(participation) =>
						participation.gameBetAmount.value !== stake.value ||
						participation.gameBetAmount.currency !== stake.currency
				)
			) {
				participations.push({
					gameBetAmount: stake,
					jackpotBetAmount: { ...stake, value: 1 },
					participationCount: 1,
				});
			}
		}

		this.config.jackpots.participations = participations;

		return this.config.jackpots;
	}

	/**
	 * Load game.config.json file & watch it.
	 */
	public load(options: { watch: boolean }): void {
		this.loadConfig();
		if (options.watch) {
			logger.verbose(`Watching for gameConfig`);
			this.watch();
		}
	}

	private loadConfig(): void {
		try {
			logger.verbose(`Loading gameConfig`);

			let gdkConf = {};
			if (fs.existsSync(this.gdkConfigFileName)) {
				gdkConf = JSON.parse(fs.readFileSync(this.gdkConfigFileName, { encoding: "utf8" }));
			}
			const conf = JSON.parse(fs.readFileSync(this.configFileName, { encoding: "utf8" }));

			this.config = this.validator.assert(_.merge({}, gdkConf, conf));

			const rawModuleConfig = this.config.modules;
			this.systemJsConfig = Object.assign(
				{
					baseURL: "/game/local",
				},
				rawModuleConfig
			);

			this.emit("loaded");
			logger.info(`gameConfig loaded`);
		} catch (err) {
			logger.error(err.message);
		}
	}

	/**
	 * as watch works in "background" we log error in the method
	 */
	private watch(): void {
		this.watcher = fs.watch(this.gameDir, (eventType, filename) => {
			if (
				basename(filename) === basename(this.gdkConfigFileName) ||
				basename(filename) === basename(this.configFileName)
			) {
				// reload config if any of the gameConf files where modified/rename/deleted/created
				this.loadConfig();
			}
		});
	}

	private unwatch(): void {
		if (this.watcher) {
			this.watcher.close();
			this.watcher = undefined;
		}
	}

	/**
	 * Listen events.
	 */
	public on(event: EVENTS, listener: () => void): void {
		this.eventEmitter.on(event, listener);
	}

	private emit(event: EVENTS): void {
		this.eventEmitter.emit(event);
	}

	/**
	 * Get current locale value.
	 */
	public get locale(): string {
		return this.config.selectedLocale;
	}

	/**
	 * Set current locale value.
	 */
	public set locale(locale: string) {
		this.config.selectedLocale = locale;
	}

	/**
	 * Get currency code
	 */
	public get currency(): string {
		return this.config.stakes[0].currency;
	}

	/**
	 * Returns available locales code base on config file assets/i18n configuration
	 */
	public getAvailableLocales(): string[] {
		const i18n = this.config.gameDescription.assets.i18n;
		return Object.keys(i18n);
	}

	/**
	 * Returns locale file path for a given locale name
	 * @locale string
	 */
	public getLocalePath(locale: string): string {
		return this.config.gameDescription.assets.i18n[locale];
	}

	/**
	 * Returns avaialble themes in config file assets/themes if defined.
	 */
	public getAvailableThemes(): string[] {
		const themes = this.config.gameDescription.assets.themes;
		return Object.keys(themes);
	}

	/**
	 * Returns theme folder path for a themeName
	 * @themeName string
	 */
	public getThemePath(themeName: string): string {
		return this.config.gameDescription.assets.themes[themeName];
	}

	/**
	 * Get theme.
	 */
	public get theme(): string {
		return this.config.selectedTheme;
	}

	/**
	 * Get main path.
	 */
	public get main(): string {
		return this.config.main;
	}

	/**
	 * Get modules.
	 */
	public get modules(): { paths: { [key: string]: string } } {
		return this.config.modules;
	}

	/**
	 * Build custom config for injection in the game loader.
	 */
	public get attrs(): IGameAttrs {
		return {
			gameType: this.engine,
			currency: this.currency,
			locale: this.locale,
			theme: this.theme,
		};
	}

	private get configFileName(): string {
		return join(this.gameDir, this.gameConf);
	}

	private get gdkConfigFileName(): string {
		return join(this.gameDir, "gdk.conf.json");
	}
}
