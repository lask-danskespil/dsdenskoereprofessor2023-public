declare module "@gdk/gamekit" {
	export * from "@gdk/gamekit/com/index";
	export * from "@gdk/gamekit/game/index";
	export * from "@gdk/gamekit/loading/index";
	export * from "@gdk/gamekit/adaptativeVisualIdentity/index";
	export * from "@gdk/gamekit/ds/index";
	export const VERSION: string;
}

declare module "@gdk/gamekit/com/index" {
	import { Com, ITrigger } from "@gdk/gamekit/com/com";
	import { Popin, IPopinDefinition, IPopinButton, IPopinLink, EPopinLevel, PopinButtonAction, PopinLinkTarget } from "@gdk/gamekit/com/popin/index";
	import { EMessageType, IMessage, MessageManager } from "@gdk/gamekit/com/messageManager/index";
	export { Com, ITrigger, Popin, IPopinDefinition, IPopinButton, IPopinLink, EPopinLevel, PopinButtonAction, PopinLinkTarget, EMessageType, IMessage, MessageManager, };
}

declare module "@gdk/gamekit/com/com" {
	import { Bridge } from "@falcon/bridge";
	import type { IPrsTicketInfos } from "@falcon/bridge/typings/prs";
	import type { IAmount } from "@gdk/core";
	import type { ICurrencyPurse, IMtrReplaySession, IBetRequest, IItgBetRequest, IItgBetResult, IItgTicket, EGameMode, IUserInformation, IOpenGameParameters, IService, IMtpRoomParamsResult, IMtpRoom, IMtpEnterRoomRequest, IMtpBetRequest, IMtpBetResult, IMtpSession, IPushSettings, IPlayerInformation, IMtrModel, IMtrSession, IMtrBetRequest, IMtrBetResult, IMtrBetUpdateRequest } from "@falcon/bridge";
	import type { PushChannel } from "@falcon/push-client";
	import type { AbstractGame } from "@gdk/gamekit/game/index";
	import { MessageManager } from "@gdk/gamekit/com/messageManager/index";
	export interface ITrigger {
	    /**
	     * Trigger action on bridge
	     * @param action the action's name
	     * @param params parameters to send to the action
	     */
	    trigger(action: string, params?: any): void;
	}
	export interface IProxyConf {
	    locale: string;
	    theme: string;
	    currency: string;
	}
	export interface IAlert {
	    id: string;
	}
	export interface IOptions {
	    applicationId?: "ITG" | "MTR" | string;
	    serviceName?: string;
	    roomId?: string;
	    framework?: string;
	    dimension?: {
	        width: number;
	        height: number;
	    };
	    guest?: any;
	}
	export class Com implements ITrigger {
	    /**
	     * It initiates the communication between the host and the game using the
	     * proxy channel and load the file that load the game.
	     *
	     * In prod it is used like this: `<body onload="falcon.game.bridge.initialize()">`.
	     */
	    static initialize(): Promise<void>;
	    /**
	     * Bridge reference used to communicate with the host and request platforms.
	     */
	    bridge: Bridge;
	    /**
	     * Array of notifications populated once a request has been finished.
	     */
	    notifications: IAlert[];
	    /**
	     * The active language used by the game.
	     */
	    activeLanguage: string;
	    /**
	     * Message manager
	     */
	    messageManager: MessageManager;
	    /**
	     * User information object got in the .init function to keep user's informations.
	     */
	    userInformation: IUserInformation;
	    /**
	     * game instance this Com is bound to.
	     */
	    readonly game: AbstractGame;
	    constructor(game: AbstractGame);
	    /**
	     * After being load the game should get a BridgeImpl instance that merge `platform` and
	     * `channel` implementation (ie: createBet, ..., getLocaleInformations, ...)
	     */
	    init(): Promise<void>;
	    /**
	     * Inits the com (bridge) locales containing the server errors etc.
	     */
	    initI18n(): Promise<void>;
	    /**
	     * Returns the current player's purse.
	     */
	    getPurse(): Promise<IAmount>;
	    /**
	     * Get avatar url for id
	     * @param id
	     */
	    getAvatarUrl(id: string): string;
	    /**
	     * Get player currency
	     * @param currencyCode
	     * @param playerId
	     * @param serviceName
	     */
	    getPlayerCurrency(currencyCode: string, playerId: string, serviceName?: IService): Promise<ICurrencyPurse[]>;
	    /**
	     * Returns the current player's information.
	     * null if the player is not authenticated
	     */
	    getUserInformation(): Promise<IUserInformation>;
	    /**
	     * Has to be called before buying a ticket in real money
	     * @returns promise
	     * The lottery must resolve whenever it wants the player to continuer with his bet
	     * The lottery must reject if ever it wants to cancel the player's bet process
	     */
	    preBet(betRequest: IBetRequest): Promise<void>;
	    /**
	     * Request a new game mode
	     *  - if current game mode is already the one, it will do nothing
	     *  - otherwise creates the dedicated IF session
	     * Resolves when done, with the new current GameMode
	     * @param mode: one of the two EGameMode
	     */
	    updateGameMode(mode: EGameMode): Promise<string>;
	    /**
	     * Return the current game mode
	     * Resolves when done, with the new current GameMode
	     */
	    getGameMode(): Promise<EGameMode>;
	    /**
	     * Retrieve open game parameters
	     */
	    getOpenGameParameters(): IOpenGameParameters;
	    /**
	     * Retrieve ticket for replay if any
	     */
	    getTicketToReplay(demo?: boolean): Promise<IItgTicket>;
	    /**
	     * Creates an ITG bet request.
	     * @param options the options object to send in the ITG bet request.
	     */
	    createItgBet(options: IItgBetRequest): Promise<IItgBetResult>;
	    /**
	     * Gets all the available tickets from the current user.
	     * @param serviceName the service name associated to the ticket.
	     */
	    getItgTickets(serviceName: string, demo?: boolean): Promise<IItgTicket[]>;
	    /**
	     * Gets the existing ticket identified by the given ticket id.
	     * @param ticketId the id the opened ticket to get.
	     */
	    getItgTicket(ticketId: number): Promise<IItgTicket>;
	    /**
	     * Updates the existing ticket according to the given bet request.
	     * @param options the options object to send in the ITG bet request.
	     * @param ticketId the id of the ticket to update
	     * @param showError display an error message on request failure
	     */
	    updateItgTicket(options: IItgBetRequest, ticketId: number, showError?: boolean): Promise<IItgBetResult>;
	    /**
	     * Claims an ITG ticket.
	     * @param options the options object to send in the ITG claim request
	     * @param ticketId the id of the ticket to claim.
	     */
	    claimItgBet(options: IItgBetRequest, ticketId: number): Promise<IItgBetResult>;
	    /**
	     * Creates a MOTORS bet request (start).
	     * @param options the options object to send in the MOTORS bet request.
	     */
	    createMtrBet<TEventResponse, TEventParameters>(options: IMtrBetRequest<TEventParameters>): Promise<IMtrBetResult<TEventResponse>>;
	    /**
	     * Returns the gamif context associated to the given service name.
	     * @param serviceName the service name to request.
	     */
	    getContext<T>(serviceName: string): Promise<any>;
	    /**
	     * Get model of the given Motors game informations (service name and application Id)
	     * @param options
	     */
	    getModel<TModel>(options: IService, demoMode?: boolean): Promise<IMtrModel<TModel>>;
	    /**
	     * Get information about presto ticket
	     */
	    getPrsTicketInfos<TModel>(): Promise<IPrsTicketInfos>;
	    /**
	     * Retrieve ticket for replay if any
	     */
	    getMtrSessionToReplay<TEventResponse, TEventParameters>(service: IService, demoMode?: boolean): Promise<IMtrReplaySession<TEventResponse, TEventParameters> | undefined>;
	    /**
	     * Get active sessions for the given service name and application Id.
	     * @template TGameData Response game data.
	     * @param service
	     * @param _showError
	     * @param demoMode
	     */
	    getMtrSession<TGameData, TEventParameters, TEventResponse>(service: IService, _showError?: boolean, demoMode?: boolean): Promise<IMtrSession<TGameData, TEventParameters, TEventResponse> | undefined>;
	    /**
	     * Perform an execute request (update bet).
	     * @template TEventResponse Response event response
	     * @template TEventParameters Event parameters
	     * @param updateBetRequest the request options (service name, application id)
	     * @param showError determines if the com module should show a popin when the response is an error or failed
	     */
	    updateMtrBet<TEventResponse, TEventParameters>(updateBetRequest: IMtrBetUpdateRequest<TEventParameters>, showError?: boolean): Promise<IMtrBetResult<TEventResponse>>;
	    /**
	     *  Gets the current variant settings of the given MTP game (service name).
	     * @param options the options containing the applicationId and the service name.
	     */
	    getMtpParameters<T>(options: IService): Promise<IMtpRoomParamsResult<T>>;
	    /**
	     * Gets the current list of active rooms for the player according to the given service name.
	     * @param options the options containing the applicationId and the serivce name.
	     */
	    getMtpRooms(options: IService): Promise<IMtpRoom[]>;
	    /**
	     * Enters to a room and bets according to the given bet informations.
	     * @param options the options containing the room informations to enter and the bet informations.
	     */
	    enterMtpRoomAndBet(options: IMtpEnterRoomRequest & IMtpBetRequest): Promise<IMtpBetResult>;
	    /**
	     * Creates a MTP bet on the user entered the room.
	     * @param options the options containing the bet informations.
	     */
	    createMtpBet(options: IMtpBetRequest): Promise<IMtpBetResult>;
	    /**
	     * Gets the current session object of the given MTP game at the given roomId.
	     * @param options the options containing the service name.
	     * @param roomId the id of the room containing the session to retrieve.
	     */
	    getMtpSession<T>(options: IService, roomId: string): Promise<IMtpSession<T>>;
	    /**
	     * Updates the MTP bet request (typically a new choice by the player in the game).
	     * @param options the informations containing the data to update for the given MTP game.
	     */
	    updateMtpBet(options: IMtpBetRequest): Promise<IMtpBetResult>;
	    /**
	     * Creates and returns an initialized channel for SSE or WebSocket connection
	     * @param settings the push settings (host, port, etc.)
	     */
	    getNotificationsChannel(settings: IPushSettings): Promise<PushChannel>;
	    /**
	     * Enter to a room identified in the options parameter.
	     * @param options the request parameters (service name, variant etc.)
	     */
	    enterMtpRoom(options: IMtpEnterRoomRequest): Promise<IMtpRoom>;
	    /**
	     * Returns the informations (avatar, pseudo, etc.) of the current player
	     */
	    getCurrentPlayerInformations(): Promise<IPlayerInformation>;
	    /**
	     * Returns the informations (avatar, pseudo, etc.) of the given players identified by their Ids.
	     * @param playersIds the ids of the player to retrieve the informations.
	     */
	    getPlayersInformations(playersIds: string[]): Promise<IPlayerInformation[]>;
	    /**
	     * Trigger action on bridge
	     * @param action the action's name
	     * @param params parameters to send to the action
	     */
	    trigger(action: string, params?: any): void;
	    /**
	     * Helper to access getLocalizedString
	     * @param key in the bridge configuration
	     * @param scope of the key it may be server, error or ui
	     */
	    t(key: string, scope: "server" | "error" | "ui" | "multiplayer"): string;
	    /**
	     * Shows the notifications from server
	     * For example: AUTOWITHDRAWAL or SUSPENSION_TRIGGERED
	     */
	    showNotification(callback?: () => void): Promise<void>;
	    /**
	     * Send the sounds status through the channel
	     * @param soundStatus
	     */
	    sendSoundStatus(soundStatus: boolean): void;
	    /**
	     * Show and track error message.
	     * @param error Error catch when promise is rejected.
	     */
	    onError(error: any): void;
	    /**
	     * populate Notifications.
	     * @param response the response containing the notifications to draw later
	     */
	    populateNotifications(response: any): void;
	}
}

declare module "@gdk/gamekit/game/index" {
	export { AbstractGame } from "@gdk/gamekit/game/abstractGame";
	export { EGameEvents } from "@gdk/gamekit/game/gameEvents";
	export { Express } from "@gdk/gamekit/game/express/express";
	export { Ticket, ETicketMode, ETicketStatus, EBetResponseAction } from "@gdk/gamekit/game/express/ticket";
	export { Action } from "@gdk/gamekit/game/action/action";
	export { MotorsModel } from "@gdk/gamekit/game/action/model";
	export { MotorsSession, ESessionMode } from "@gdk/gamekit/game/action/session";
	export { Multipass } from "@gdk/gamekit/game/multipass/multipass";
	export { MultipassSession } from "@gdk/gamekit/game/multipass/session";
	export { MultipassNotifications, IMultipassNotification, EMultipassGameState, EMultipassNotificationType, } from "@gdk/gamekit/game/multipass/notifications";
	export { TweenUtils } from "@gdk/gamekit/game/tweenUtils";
	export * from "@gdk/gamekit/game/ui/index";
	export * from "@gdk/gamekit/game/wizz/index";
	export * from "@gdk/gamekit/game/inactivity";
	export * from "@gdk/gamekit/game/carousel";
}

declare module "@gdk/gamekit/game/abstractGame" {
	import { GamePixi } from "@gdk/core-pixi";
	import { utils } from "pixi.js";
	import type { IGamePixiOptions } from "@gdk/core-pixi";
	import type { IAmount, IGameConf } from "@gdk/core";
	import type { EGameMode, IOpenGameParameters } from "@falcon/bridge";
	import { AdaptativeVisualIdentity } from "@gdk/gamekit/adaptativeVisualIdentity/index";
	import { Com } from "@gdk/gamekit/com/index";
	/**
	 * Strings used as identifier for reasons to pause the game. They are stored in
	 * the AbstractGame "pauseReasons" instance property, and used to know if the game
	 * should be paused or not. Each reason should be dedidated to exactly one use case,
	 * and not shared, otherwise shared reasons could conflict and unpause the game when
	 * it shouldn't be.
	 */
	type PauseReason = "lockscreen" | "blur" | "settings" | "rules" | "messagemanager" | `notifier_${string}`;
	export class AbstractGame extends GamePixi {
	    com: Com;
	    vi: AdaptativeVisualIdentity;
	    gameConfig: IGameConf;
	    skin: any;
	    rulesVisible: boolean;
	    events: utils.EventEmitter;
	    private _muted;
	    private _disableInteractivityOverlay;
	    /**
	     * List of unique reasons this game was paused for.
	     * This set is empty means: the game is not paused. Better use `paused` getter
	     * to know if the game is paused.
	     *
	     * This set is updated by methods `pause` and `unpause`.
	     */
	    protected pauseReasons: Set<PauseReason>;
	    /**
	     * Constructor
	     * @param gameConfig: the game configuration (game.conf.json)
	     * @param width: the canvas width
	     * @param height: the canvas height
	     * @param noWebGL: enable/disable WebGL (to force Canvas)
	     * @param options: the Pixi.js applicaiton options
	     */
	    constructor(gameConfig: IGameConf, width: number, height: number, noWebGL: boolean, options: IGamePixiOptions);
	    /**
	     * Return true if the game is paused for one of the given reasons.
	     * If no reason passed, this method simply returns true if the game is paused.
	     */
	    isPaused(...reasons: PauseReason[]): boolean;
	    /**
	     * Add a reason to pause the game. The game is actually paused if it wasn't yet.
	     */
	    pause(reason: PauseReason): void;
	    /**
	     * Unregister given reason from the list of reasons to pause and resume the game
	     * is necessary.
	     *
	     * @returns boolean: was the game resumed ?
	     *     true if this call did actually unpause the game,
	     *     false otherwise
	     */
	    unpause(reason: PauseReason): boolean;
	    /**
	     * Pause tween animations
	     */
	    onRulesOpen(): void;
	    /**
	     * Resume tween animations
	     */
	    onRulesQuit(): void;
	    /**
	     * Returns if the game sound is active (helper)
	     */
	    get soundStatus(): boolean;
	    /**
	     * Returns if the game is super jackpotized
	     * (default: false)
	     */
	    get hasSuperJackpot(): boolean;
	    /**
	     * Updates the purse
	     * @param updateVi if should update the VI purse
	     */
	    getPurse(updateVi: boolean): Promise<IAmount>;
	    /**
	     * Initializes all game's components:
	     * - Com
	     * - i18n
	     * - getGameConfiguration
	     * @param done called once initialization is done (com, i18n, etc.)
	     */
	    init(done: () => void): Promise<void>;
	    /**
	     * Starts the game.
	     * @param view Specifies the first view to make appear.
	     * @param done Optionnal callback called once start is done.
	     * @returns A promise resolved when the game is loaded and started or void for backward compatibility.
	     */
	    start(state: string, done?: () => void): Promise<void> | void;
	    private _start;
	    protected verifySymbolSpriteSignatures(): void;
	    protected displayErrorPopin(text: string): void;
	    private _startVI;
	    /**
	     * Mute / demute all sounds in game. If sound state was already in the right state,
	     * does nothing. If asked to unmute (muted == false) and sound was deactivated
	     * from settings (this.vi.soundEnabled == false), does nothing (excepted if force == true).
	     * If sound is actually changed, returns true, notifies com, and emit event
	     * EVisualIdentityEvent.SoundStatusChanged
	     *
	     * @param value desired mute state
	     * @param force: boolean: if true, force vi sound state to synchronized with given state
	     * @return boolean: true is sound status changed
	     */
	    mute(muted: boolean, force?: boolean): boolean;
	    /**
	     * Tries to disable/enable the sound in the applet. If the applet is already forced to be
	     * muted, then nothing changes.
	     * @param disabled defines wether or not the sound should be disabled.
	     * @returns boolean: true if sound status was changed, false otherwise
	     */
	    tryToMute(muted: boolean): boolean;
	    /**
	     * Puts an interactive overlay over the game so all interaction are catched
	     */
	    showInteractivityOverlay(): void;
	    /**
	     * Removes the interactive overlay
	     */
	    removeInteractivityOverlay(): void;
	    /**
	     * will return current game sounds state (muted or not)
	     * @return true if the sound is muted.
	     */
	    get muted(): boolean;
	    /**
	     * Returns the path of the assets folder according to the current theme in GameConf.
	     */
	    getThemePath(): string;
	    /**
	     * Return the game's infos. Should be overidden to add
	     * more informations to log
	     */
	    protected getInfos(): Promise<any>;
	    /**
	     * Get open game parameters
	     */
	    getOpenGameParameters(): IOpenGameParameters;
	    /**
	     * Resolves when done, with the current GameMode
	     */
	    getGameMode(): Promise<EGameMode>;
	    /**
	     * Loads the game assets
	     * @param startCallback callback when starting the game once assets loaded
	     * @param done callback when everything has been loaded and created
	     */
	    private _loadAssets;
	    private _createOverlay;
	}
	export {};
}

declare module "@gdk/gamekit/adaptativeVisualIdentity/index" {
	export * from "@gdk/gamekit/adaptativeVisualIdentity/adaptativeVisualIdentity";
	export * from "@gdk/gamekit/adaptativeVisualIdentity/events";
	export * from "@gdk/gamekit/adaptativeVisualIdentity/identity";
	export * from "@gdk/gamekit/adaptativeVisualIdentity/identities/fgs/components/messagePopin";
}

declare module "@gdk/gamekit/adaptativeVisualIdentity/adaptativeVisualIdentity" {
	import { utils, Graphics } from "pixi.js";
	import { GameCore } from "@gdk/core";
	import type { LoadedView, ContainerView } from "@gdk/core-pixi";
	import type { Sprite } from "pixi.js";
	import { EVisualIdentityAction } from "@gdk/gamekit/adaptativeVisualIdentity/events";
	import type { AbstractGame } from "@gdk/gamekit/game/abstractGame";
	import type { IIdentity, IAdaptativeLoadingView, IAdaptativeIntroductionView, IAdaptativeInGameView, IAdaptativeLockedView } from "@gdk/gamekit/adaptativeVisualIdentity/identity";
	/**
	 * Optionnal boolean parameters used by the adaptative visual identity.
	 */
	export interface IAdaptativeIdentityParameters {
	    rulesEnabled?: boolean;
	    soundButtonEnabled?: boolean;
	    skipIntroduction?: boolean;
	    backgroundRulesClickable?: boolean;
	    [key: string]: any;
	}
	export interface IAdaptativeIdentityConfig {
	    /**
	     * The lottery id to load identity
	     */
	    lottery: string;
	    /**
	     * The theme of the lottery identity
	     */
	    theme: string;
	    /**
	     * Parameters feeded to the identity
	     */
	    parameters?: IAdaptativeIdentityParameters;
	}
	export class AdaptativeVisualIdentity extends GameCore {
	    /**
	     * Defines the main emitter listened by the views
	     */
	    emitter: utils.EventEmitter;
	    /**
	     * Defines the background used as an overlay when player shows the settings.
	     * Anyway it can be used for other needs. The background is added into the stage
	     * and has a Cover resize method.
	     */
	    background: Sprite | Graphics;
	    /**
	     * Defines the loading view instance created after importing the lottery identity
	     */
	    loadingView: (LoadedView | ContainerView) & IAdaptativeLoadingView;
	    /**
	     * Defines the introduction view instance created after importing the lottery identity
	     */
	    introductionView: (LoadedView | ContainerView) & IAdaptativeIntroductionView;
	    /**
	     * Defines the in-game view instance created after importing the lottery identity
	     */
	    inGameView: (LoadedView | ContainerView) & IAdaptativeInGameView;
	    /**
	     * Defines the lock view instance created after importing the lottery identity
	     */
	    lockView: (LoadedView | ContainerView) & IAdaptativeLockedView;
	    /**
	     * Defines the skin of the overall loaded identity
	     */
	    skin: any;
	    /**
	     * Called once the VI has been initialized
	     */
	    onInitialized: () => void;
	    /**
	     * For backward compatibility, keep show rules callback
	     * @deprecated
	     */
	    onShowRules: () => void;
	    /**
	     * For backward compatibility, keep show main rules callback
	     * @deprecated
	     */
	    onShowMainRules: () => void;
	    /**
	     * Reference of the game using the Adaptative Visual Identity
	     */
	    game: AbstractGame;
	    /**
	     * Reference of the parameters used by the Adaptative Visual Identity
	     */
	    parameters: IAdaptativeIdentityParameters;
	    private _config;
	    private _files;
	    protected _soundEnabled: boolean;
	    /**
	     * Constructor
	     * @param game the game reference containing the VI
	     */
	    constructor(game: AbstractGame, config: IAdaptativeIdentityConfig);
	    /**
	     * Loads the given lottery identity exposing the required views
	     * @param lottery the lottery identifier to know what identity to load
	     */
	    getIdentity(lottery: string): Promise<IIdentity>;
	    /**
	     * Inits the VI by loading the assets and creating the state
	     */
	    init(done?: () => void): Promise<void>;
	    /**
	     * Shows the loading view
	     */
	    showLoadingView(): void;
	    /**
	     * Shows the introduction
	     * @param done callback once the animation is done
	     */
	    showIntroduction(done?: () => void): Promise<void>;
	    /**
	     * Shows the VI in game (logo, settings, purse etc.)
	     */
	    showInGame(): void;
	    /**
	     * Hides the visual identity views
	     */
	    hide(): void;
	    /**
	     * Emit a VisualIdentity action event
	     * @param event the action type to emit to intentities
	     * @param parameters the parameters to send to the identity on the given action
	     */
	    emit<T>(event: EVisualIdentityAction | string, parameters?: T): boolean;
	    private _fillBackground;
	    private _bindEvents;
	    /**
	     * For backward compatibility, keep setter to know if settings are enabled
	     * @deprecated
	     */
	    set settingsEnabled(enabled: boolean);
	    /**
	     * Enabled / disable sound
	     * @param enabled: boolean
	     */
	    set soundEnabled(enabled: boolean);
	    /**
	     * Return true if sound is enabled in VI, false otherwise.
	     * @returns boolean
	     */
	    get soundEnabled(): boolean;
	}
}

declare module "@gdk/gamekit/adaptativeVisualIdentity/events" {
	export enum EVisualIdentityEvent {
	    /**
	     * Event sent by the VI once the introduction has been shown
	     */
	    IntroductionShown = "introductionShown",
	    /**
	     * Event sent by the VI once the introduction finished
	     */
	    IntroductionComplete = "introductionComplete",
	    /**
	     * Event sent by the VI on the user wants to see the settings
	     */
	    ShowSettings = "showsettings",
	    /**
	     * Event sent by the VI on the user wants to hide the settings
	     */
	    HideSettings = "hidesettings",
	    /**
	     * Event sent by the VI on the user wants to see the rules
	     */
	    ShowRules = "showrules",
	    /**
	     * Event sent by the VI on the user wants to hide the rules
	     * (from Norsk Tipping)
	     */
	    HideRules = "hiderules",
	    /**
	     * Event sent by the VI on the user wants to see the main rules
	     */
	    ShowMainRules = "showmainrules",
	    /**
	     * Event sent by the VI on the sound status changed
	     */
	    SoundStatusChanged = "soundstatuschanged",
	    /**
	     * Event sent by the VI on the user wants to quit the game
	     */
	    QuitGame = "quitgame",
	    /**
	     * Event sent by the VI on the user wanted to quit the game and the confirm popup is appearing
	     */
	    ConfirmQuitGame = "confirmQuitGame",
	    /**
	     * Event sent by the VI on the user wants to see the winning table
	     * (from Danske Spil)
	     */
	    ShowWinningTable = "showwinningtable",
	    /**
	     * Event sent by the VI on the user wants to see the informations about the current game
	     * (from Danske Spil)
	     */
	    AboutGame = "aboutGame",
	    /**
	     * Event sent by the VI to notify that scratch configuration has to be modified
	     * Sent with params as {pointer:CustomPointer, emitterDatas:any}
	     */
	    SetScratchConfiguration = "setscratchconfiguration",
	    /**
	     * Event sent by the VI on the user wanted to go to the game tutorial
	     * (from FDJ)
	     */
	    Tutorial = "tutorial",
	    /**
	     * Event sent by the VI when the user want to switch game mode between normal and demo
	     */
	    SwitchGameMode = "switchgamemode",
	    /**
	     * Event sent when the webpage lose focus and become blurred
	     */
	    GameBlurred = "gameblurred",
	    /**
	     * Event sent when the webpage regain focus
	     */
	    GameFocused = "gamefocused",
	    /**
	     * Event sent by the LORO VI when a user use the built in auto button
	     */
	    AutoButton = "autobutton"
	}
	export enum EVisualIdentityAction {
	    /**
	     * Action that sets if the settings are enabled or not
	     * @example vi.emitter.emit(EVisualIdentityAction.SettingsEnabled, true); // To enable settings
	     * @example vi.emitter.emit(EVisualIdentityAction.SettingsEnabled, false); // To disable settings
	     */
	    SettingsEnabled = "settingsEnabled",
	    /**
	     * Action that sets the new purse to display
	     * @example vi.emitter.emit(EVisualIdentityAction.SetPurse, new Amount(0)); // Set a purse of 0â‚¬ for example
	     */
	    SetPurse = "setPurse",
	    /**
	     * Action that sets if the rules are enabled or not
	     * @example vi.emitter.emit(EVisualIdentityAction.RulesEnabled, true); // To enable rules
	     * @example vi.emitter.emit(EVisualIdentityAction.RulesEnabled, false); // To disable rules
	     */
	    RulesEnabled = "rulesEnabled",
	    /**
	     * Action that sets that the game is ready so the Visual Identity can perform
	     * some actions that require the game to be ready
	     */
	    SetGameReady = "setGameReady",
	    /**
	     * Action that sets the scratch settings component visible
	     * @example vi.emitter.emit(EVisualIdentityAction.ShowScratchSettings, true); // To show scratch settings
	     * @example vi.emitter.emit(EVisualIdentityAction.ShowScratchSettings, false); // To hide scratch settings
	     */
	    ShowScratchSettings = "showScratchSettings",
	    /**
	     * Tells the Visual Identity to update its design according to the newly loaded assets in the game
	     * @example vi.emitter.emit(EVisualIdentityAction.UpadteDesign); // Tells to update the design
	     */
	    UpdateDesign = "updateDesign",
	    /**
	     * Tells the VI to add the given buttons to the controls buton
	     */
	    AddControlButton = "addControlButton",
	    /**
	     * Give the WIZZ VI the rules to add
	     * @example vi.emitter.emit(EVisualIdentityAction.WizzSetRules, [ContainerRules1, ContainerRules2]); // To add two rules slide
	     */
	    WizzSetRules = "wizzSetRules",
	    /**
	     * Set wizz game specific textures
	     * @example vi.emitter.emit(EVisualIdentityAction.WizzSetConfig, {
	     * 		bottom?: {
	     * 			title?: Texture,
	     * 			background?: Texture,
	     * 		},
	     * 		bet?: {
	     * 			idle?: Texture,
	     * 			over?: Texture,
	     * 			click?: Texture,
	     * 			disabled?: Texture,
	     * 		},
	     * 		onBet: () => Promise<void>,
	     * 		onReconnect: () => Promise<void>,
	     * 		amount: Amount,
	     * 	});
	     */
	    WizzSetConfig = "wizzSetConfig",
	    /**
	     * Wizz get purse containers
	     * @example vi.emitter.emit(EVisualIdentityAction.WizzGetPursesContainers, (containers) => {
	     * 		containers.gift // promo token
	     * 		containers.token // token
	     * 		containers.gameWin // game win
	     * 		containers.standard // real purse
	     * });
	     */
	    WizzGetPursesContainers = "wizzGetPursesContainer",
	    /**
	     * Wizz get bottom container
	     * @example vi.emitter.emit(EVisualIdentityAction.WizzGetBottomContainer, (container) => {
	     * 		container
	     * });
	     */
	    WizzGetBottomContainer = "wizzGetBottomContainer",
	    /**
	     * Wizz get waiting container
	     * @example vi.emitter.emit(EVisualIdentityAction.WizzGetWaitingContainer, (container) => {
	     * 		container
	     * });
	     */
	    WizzGetWaitingContainer = "wizzGetWaitingContainer",
	    /**
	     * Wizz open canceled popup
	     * @example vi.emitter.emit(EVisualIdentityAction.WizzOpenCanceled);
	     */
	    WizzOpenCanceled = "wizzOpenCanceled",
	    /**
	     * Wizz open canceled popup
	     * @example vi.emitter.emit(EVisualIdentityAction.WizzOpenStopped);
	     */
	    WizzOpenStopped = "wizzOpenStopped",
	    /**
	     * Wizz open reconnection popup
	     * @example vi.emitter.emit(EVisualIdentityAction.WizzOpenReconnection);
	     */
	    WizzOpenReconnection = "wizzOpenReconnection",
	    /**
	     * Wizz close reconnection popup
	     * @example vi.emitter.emit(EVisualIdentityAction.WizzCloseReconnection);
	     */
	    WizzCloseReconnection = "wizzCloseReconnection",
	    /**
	     * Wizz open bet popup
	     * @example vi.emitter.emit(EVisualIdentityAction.WizzOpenBet);
	     */
	    WizzOpenBet = "wizzOpenBet",
	    /**
	     * Wizz open waiting room
	     * @example vi.emitter.emit(EVisualIdentityAction.WizzOpenWaitingRoom);
	     */
	    WizzOpenWaitingRoom = "wizzOpenWaitingRoom",
	    /**
	     * Wizz close waiting room
	     * @example vi.emitter.emit(EVisualIdentityAction.WizzCloseWaitingRoom);
	     */
	    WizzCloseWaitingRoom = "wizzCloseWaitingRoom",
	    /**
	     * Wizz close reconnection popup
	     * @example vi.emitter.emit(EVisualIdentityAction.WizzCloseReconnection);
	     */
	    WizzCloseAllPopups = "wizzCloseAllPopups",
	    /**
	     * Wizz update token purses
	     * @example vi.emitter.emit(EVisualIdentityAction.WizzUpdatePurse);
	     */
	    WizzUpdatePurse = "wizzUpdatePurse",
	    /**
	     * Wizz update game gain
	     * @example vi.emitter.emit(EVisualIdentityAction.WizzUpdateGain, amount);
	     */
	    WizzUpdateGain = "wizzUpdateGain",
	    /**
	     * @deprecated  use wizzGetAvatarslots instead
	     * Wizz get Avatars from avatar ids
	     * @example vi.emitter.emit(EVisualIdentityAction.WizzUpdateGain, ids, (avatars) => void);
	     */
	    WizzGetAvatars = "wizzGetAvatars",
	    /**
	     * Wizz Add VI Player
	     * @example vi.emitter.emit(EVisualIdentityAction.WizzAddLobbyPlayer, AvatarSlot, isClientPlayer);
	     */
	    WizzAddLobbyPlayer = "wizzAddLobbyPlayer",
	    /**
	     * get the avatar with truncated pseudo and positioning
	     * @example	this.game.vi.emitter.emit(EVisualIdentityAction.WizzGetAvatarSlots, playerInfo, this.clientPlayerID, (avatarSlots: IAvatarSlot[]) => {clback here});
	     */
	    WizzGetAvatarSlots = "wizzGetAvatarSlots",
	    /**
	     * Hide or show tutorial button
	     * @example vi.emitter.emit(EVisualIdentityAction.TutorialVisible, true, true)
	     */
	    TutorialVisible = "tutorialVisible",
	    /**
	     * Enable or disable the sound
	     * @example vi.emitter.emit(EVisualIdentityAction.SoundEnabled, true)
	     */
	    SoundEnabled = "soundEnabled",
	    /**
	     * Enable or disable the auto button on the VI
	     * @exemple vi.emmiter.emit(EVisualIdentityAction.AutoEnabled, true)
	     */
	    AutoEnabled = "autoEnabled"
	}
}

declare module "@gdk/gamekit/adaptativeVisualIdentity/identity" {
	import type { Container } from "pixi.js";
	import type { EOrientation } from "@gdk/core";
	import type { ContainerView, LoadedView, IStyles } from "@gdk/core-pixi";
	import type { AdaptativeVisualIdentity } from "@gdk/gamekit/adaptativeVisualIdentity/adaptativeVisualIdentity";
	export interface IAdaptativeLoadingView {
	    /**
	     * Defines the function called each time a file is loaded
	     * @param percentage the percentage of files already loaded
	     */
	    onProgress(percentage: number): void;
	}
	export interface IAdaptativeIntroductionView {
	    /**
	     * Starts the introduction animation
	     * @param done callback once the animation is done
	     */
	    animate(done: () => void): void;
	    /**
	     * Defines if the view must skip the introduction
	     */
	    skipIntro?: boolean;
	}
	export interface IAdaptativeInGameView {
	    /**
	     * Defines the settings component used to draw the settings window, buttons etc.
	     */
	    settingsComponent?: Container & {
	        rulesEnabled?: boolean;
	    };
	}
	export interface IAdaptativeLockedView {
	    /**
	     * Defines the orientation needed to draw the locked view
	     */
	    orientation: EOrientation;
	}
	/**
	 * Defines the constructor signature of an identity view
	 */
	export type IdentityViewConstructor = new (vi?: AdaptativeVisualIdentity) => ContainerView | LoadedView;
	/**
	 * Defines the exported object when loading a lottery identity
	 */
	export interface IIdentity {
	    /**
	     * Constructor reference of the loading view
	     */
	    LoadingView: IdentityViewConstructor;
	    /**
	     * Constructor reference of the introduction view
	     */
	    IntroductionView?: IdentityViewConstructor;
	    /**
	     * Constructor of the in-game view
	     */
	    InGameView?: IdentityViewConstructor;
	    /**
	     * Constructor of the locked view
	     */
	    LockView?: IdentityViewConstructor;
	}
	/**
	 * Defines the data sent while emitting the action EVisualIdentityAction.UpdateDesign.
	 */
	export interface IVisualIdentityDesign {
	    /**
	     * Defines the styles of all buttons texts in the visual identity.
	     * Will typically change the fontName, fill.
	     */
	    buttonsStyles?: IStyles;
	    /**
	     * Defines the styles of all popups titles in the visual identity.
	     * Will typically change the fontName, fill.
	     */
	    titleStyles?: IStyles;
	    /**
	     * Defines the styles of all popups contents texts in the visual identity.
	     * Will typically change the fontName, fill.
	     */
	    contentStyles?: IStyles;
	}
}

declare module "@gdk/gamekit/adaptativeVisualIdentity/identities/fgs/components/messagePopin" {
	import { Container, Rectangle, Point } from "pixi.js";
	import i18next from "i18next";
	import type { Button } from "@gdk/core-pixi";
	/**
	 * the popin buttons options
	 */
	export interface IMessagePopinButtonOptions {
	    name: string;
	    label: string;
	    value: unknown;
	    type: string;
	    exit?: boolean;
	}
	/**
	 * the Popin required options
	 */
	export interface IMessagePopinOptions {
	    name: string;
	    title: string;
	    body: string;
	    buttons: IMessagePopinButtonOptions[];
	}
	/**
	 * the result returned by the Promise
	 */
	export interface IMessagePopinResult {
	    result?: unknown;
	    error?: unknown;
	}
	interface IButton {
	    [name: string]: Button;
	}
	export class MessagePopin extends Container {
	    static ERROR_NO_POPIN: string;
	    /**
	     * the padding (rectangle) between popin borders and it's content
	     */
	    padding: Rectangle;
	    /**
	     * the spacing (Point) between popin contents
	     */
	    spacing: Point;
	    private background;
	    private title;
	    private body;
	    private overlay;
	    private _hidden;
	    private _buttonsStack;
	    private _buttons;
	    private _buttonsByName;
	    private _buttonsStackMinSize;
	    private _pending;
	    private _pendingResolve;
	    private _pendingReject;
	    private _primary;
	    private _secondary;
	    private _cancel;
	    private _close;
	    /**
	     * called once when loaded, init editor components
	     */
	    onLoaded(): void;
	    /**
	     * will open a popin based on i18n object
	     * @param key the i18n key
	     */
	    openFromi18n(key: string, options?: i18next.TranslationOptions<object>): Promise<IMessagePopinResult>;
	    /**
	     * open a message popin (text + optionnal buttons)
	     * will get the popin settings based on an object from i18n
	     * @param key the object key in i18n
	     * @param options i18n options like replacement properties.
	     */
	    getFromi18n(key: string, options?: i18next.TranslationOptions<object>): any;
	    /**
	     * open a message popin (text + optionnal buttons)
	     * will get the popin settings based on an object
	     * @param options the popin options
	     */
	    open(options: IMessagePopinOptions): Promise<IMessagePopinResult>;
	    /**
	     * will show the popin
	     * @param duration the transition duration
	     */
	    show(duration?: number): Promise<void>;
	    /**
	     * will hide the popin
	     * @param duration the transition duration
	     */
	    hide(duration?: number): Promise<void>;
	    /**
	     * give read only access to the popin buttons list (just in case)
	     */
	    get buttons(): IButton[];
	    private _resizeBackground;
	    private addOverlay;
	    private removeOverlay;
	    private buttonsSetEnabled;
	    private buttonsSetInteractive;
	    private removeButtons;
	}
	export {};
}

declare module "@gdk/gamekit/game/gameEvents" {
	export enum EGameEvents {
	    GameStart = "gamestart",
	    GameEnd = "gameend",
	    RulesOpen = "rulesopen",
	    RulesQuit = "rulesquit",
	    GamePaused = "gamepaused",
	    GameMuted = "gamemuted"
	}
}

declare module "@gdk/gamekit/game/express/express" {
	import type { IItgBetRequest, IItgTicket, IBetRequest, EGameMode, IUserInformation } from "@falcon/bridge";
	import type { IAmount, IGameConf } from "@gdk/core";
	import type { ApplicationOptions } from "pixi.js";
	import { AbstractGame } from "@gdk/gamekit/game/abstractGame";
	export class Express extends AbstractGame {
	    selectedStake: IAmount;
	    /**
	     * Constructor
	     * @param gameConfig: the game configuration (game.conf.json)
	     * @param width: the canvas width
	     * @param height: the canvas height
	     * @param noWebGL: enable/disable WebGL (to force Canvas)
	     * @param options: the Pixi.js applicaiton options
	     */
	    constructor(gameConfig: IGameConf, width: number, height: number, noWebGL: boolean, options: ApplicationOptions);
	    /**
	     * Creates an ITG bet request.
	     * @param betRequest: the bet request parameters.
	     */
	    bet(betRequest: IItgBetRequest): Promise<IItgTicket>;
	    /**
	     * Shows the continue game popup
	     */
	    showResumeGamePopup(): Promise<void>;
	    /**
	     * Shows the continue game popup
	     */
	    showReplayStartPopup(): Promise<void>;
	    /**
	     * Returns the current player's information.
	     * null if the player is not authenticated
	     */
	    getUserInformation(): Promise<IUserInformation>;
	    /**
	     * Has to be called before buying a ticket
	     * The event will be sent only if `handlePreBet` parameter is set to true in the behaviourParameters set of the gameConfig
	     * @returns promise
	     * The lottery must resolve whenever it wants the player to continue with his bet
	     * The lottery must reject if ever it wants to cancel the player's bet process
	     */
	    preBet(betRequest: IBetRequest): Promise<void>;
	    /**
	     * This hook can be called at the end of the revelation (after the result)
	     * The event will be sent only if `gameEndHook` parameter is set to true in the behaviourParameters set of the gameConfig
	     * It notifies the lottery that the game revelation has ended.
	     * Allows the lottery to present the player a custom message asking him if he wants to replay.
	     * The lottery has the ability to launch directly a new bet with a given stake and mode or to go back to the home view of the game.
	     * @returns promise
	     * The lottery must resolve with a stake and a demoMode whenever it wants the game to automatically buy a new game
	     * The lottery must resolve with undefined otherwise
	     */
	    gameEndHook(ticket: IItgTicket): Promise<undefined | {
	        stake: IAmount;
	        demoMode: boolean;
	    }>;
	    /**
	     * Notifies the lottery that there is an existing opened ticket to resume.
	     * The event will be sent only if `resumeHook` parameter is set to true in the behaviourParameters set of the gameConfig
	     * The lottery has the ability to present the player with the info and to wether accept or refuse the resuming.
	     * Resfusing the resuming of the ticket can return to home or close the game for example, depending on the lottery guidelines.
	     * @returns promise
	     * The lottery must resolve `true`to go on with resuming the ticket
	     * The lottery must resolve `false` otherwise.
	     */
	    resumeHook(ticket: IItgTicket): Promise<boolean>;
	    /**
	     * Request a new game mode
	     *  @param options : one of the two EGameMode
	     *  - if current game mode is already the one, it will do nothing
	     *  - otherwise creates the dedicated IF session
	     * Resolves when done, with the new current GameMode
	     */
	    updateGameMode(mode: EGameMode): Promise<string>;
	    /**
	     * Returns the first existing ticket that haven't been claimed by the user.
	     * @param serviceName the service name associated to the ticket.
	     */
	    getExistingTicket(serviceName: string, demo: boolean): Promise<IItgTicket>;
	    /**
	     * Retrieve ticket to replay if any
	     * returns null if no ticket to replay.
	     */
	    getTicketToReplay(demo: boolean): Promise<IItgTicket>;
	    /**
	     * Updates the given ticket
	     * @param betRequest: the bet request parameters.
	     * @param ticketId the id of the ticket to update.
	     * @param showError display an error on failed request
	     */
	    updateTicket(betRequest: IItgBetRequest, ticketId: number, showError?: boolean): Promise<IItgTicket>;
	    /**
	     * Claims an ITG ticket
	     * @param betRequest: the bet request parameters.
	     * @param ticketId the id of the ticket to claim.
	     */
	    claim(betRequest: IItgBetRequest, ticketId: number): Promise<IItgTicket>;
	    private _betResponseToTicketData;
	    get betMode(): "BET_AUTO_CLAIM" | "BET_MANUAL_CLAIM";
	}
}

declare module "@gdk/gamekit/game/express/ticket" {
	import { Amount } from "@gdk/core";
	import type { IItgTicket, IItgPrize } from "@falcon/bridge";
	import type { Express } from "@gdk/gamekit/game/express/express";
	export enum ETicketStatus {
	    CLAIMED = "CLAIMED",
	    OPENED = "OPENED"
	}
	export enum ETicketMode {
	    DEFAULT = 0,
	    RESUME = 1,
	    REPLAY = 2
	}
	export enum EBetResponseAction {
	    NO_ACTION = "NO_ACTION",
	    SUSPENSION_TRIGGERED = "SUSPENSION_TRIGGERED",
	    AUTOWITHDRAWAL_TRIGGERED = "AUTOWITHDRAWAL_TRIGGERED"
	}
	export abstract class Ticket<T = {}, U extends Express = Express> {
	    protected _game: U;
	    readonly demo: boolean;
	    readonly stake: Amount;
	    readonly symbol: string;
	    readonly receiptId: string;
	    readonly ticketId: number;
	    readonly mode: ETicketMode;
	    readonly serviceName: string;
	    readonly platformBetId: string;
	    status: ETicketStatus;
	    wonAmount: Amount;
	    /**
	     * Flag from the lottery as SUSPENSION_TRIGGERED, AUTOWITHDRAWAL_TRIGGERED...
	     */
	    action: EBetResponseAction;
	    /**
	     * RevelationData, has to be set to last data before updating the ticket
	     */
	    revelationData: T;
	    /**
	     * The bet response object keeped reference.
	     */
	    readonly ticket: IItgTicket;
	    private _updateInProgress;
	    private _updatePromise;
	    /**
	     * Constructor
	     * @param ticket an IItgTicket
	     * @param demo wether or not the ticket is in demo mode.
	     */
	    constructor(ticket: IItgTicket, mode: ETicketMode, _game: U);
	    /**
	     * Claim ITG ticket
	     */
	    claim(): Promise<IItgTicket>;
	    /**
	     * Update ticket by sending revelation data to the server
	     * @param showError display an error message on request failure (default: true)
	     */
	    update(showError?: boolean): Promise<void>;
	    private _updateTicketNow;
	    /**
	     * Check revalationData validity
	     * Must be implemented in Ticket class in the game
	     * Must return true if revelationData format is valid and handled, must return false otherwise
	     * Parsed symbol data are available at this time
	     * If not implemented in the game it will return false hence revelation data will be skipped
	     * @param revelationData
	     */
	    protected abstract areRevelationDataValid(revelationData: T): boolean;
	    /**
	     * Parse symbol
	     * To be implemented in the game Ticket class
	     */
	    protected abstract parse(): void;
	    /**
	     * Return the prize object of the ticket
	     */
	    get prize(): IItgPrize;
	}
}

declare module "@gdk/gamekit/game/action/action" {
	import type { IPrsTicketInfos } from "@falcon/bridge/typings/prs";
	import type { IMtrModel, IMtrSession, IMtrBetRequest, IMtrBetResult, IService, IMtrReplaySession, IBetRequest } from "@falcon/bridge";
	import type { IAmount, IGameConf } from "@gdk/core";
	import type { ApplicationOptions } from "pixi.js";
	import { AbstractGame } from "@gdk/gamekit/game/abstractGame";
	import type { MotorsModel } from "@gdk/gamekit/game/action/model";
	import type { MotorsSession } from "@gdk/gamekit/game/action/session";
	/**
	 * Action game.
	 * @template TModel Model typings.
	 * @template TGameData Session typings.
	 * @template TEventResponse "evr" typings.
	 * @template TEventParameters Event parameters.
	 * @template TMotorsSession override session typings.
	 */
	export class Action<TModel, TGameData, TEventResponse, TEventParameters, TMotorsSession extends MotorsSession<TGameData, TEventParameters, TEventResponse, TModel> = MotorsSession<TGameData, TEventParameters, TEventResponse, TModel>> extends AbstractGame {
	    model: MotorsModel<TModel>;
	    session: TMotorsSession;
	    selectedStake: IAmount;
	    /**
	     * Constructor
	     * @param gameConfig: the game configuration (game.conf.json)
	     * @param width: the canvas width
	     * @param height: the canvas height
	     * @param noWebGL: enable/disable WebGL (to force Canvas)
	     * @param options: the Pixi.js applicaiton options
	     */
	    constructor(gameConfig: IGameConf, width: number, height: number, noWebGL: boolean, options: ApplicationOptions);
	    /**
	     * Returns the Motors model of the given service name (optional, default is taken from game config).
	     * @param parameters: the request parameters (applicationId and service name)
	     */
	    getModel(parameters?: IService, demoMode?: boolean): Promise<IMtrModel<TModel>>;
	    /**
	     * Returns the Presto ticket information for the current player (token dependant).
	     */
	    getPrsTicketInfos(): Promise<IPrsTicketInfos>;
	    /**
	     * Returns the Motors available sessions
	     * @param parameters: the request parameters (applicationId and service name)
	     */
	    getSession(parameters?: IService, demoMode?: boolean): Promise<IMtrSession<TGameData, TEventParameters, TEventResponse>>;
	    /**
	     * Looks for session from bet it.
	     * Returns a IMtrReplaySession if existing or undefined otherwise.
	     * @param parameters
	     */
	    getSessionFromBetId(parameters?: IService): Promise<IMtrReplaySession<TEventResponse, TEventParameters>>;
	    /**
	     * Starts a Motors session (bet)
	     * @param parameters: the start session parameters
	     */
	    bet(parameters: IMtrBetRequest<TEventParameters>): Promise<IMtrBetResult<TEventResponse>>;
	    /**
	     * Has to be called before buying a ticket in real money
	     * @returns promise
	     * The lottery must resolve whenever it wants the player to continuer with his bet
	     * The lottery must reject if ever it wants to cancel the player's bet process
	     */
	    preBet(betRequest: IBetRequest): Promise<void>;
	    /**
	     * Shows the continue game popup
	     * @param done callback once the user closes the popup
	     */
	    showResumeGamePopup(): Promise<void>;
	    /**
	     * Execute get context
	     * @param parameters
	     * @todo support gamif :)
	     */
	    getContext(parameters: any): Promise<any>;
	}
}

declare module "@gdk/gamekit/game/action/model" {
	export class MotorsModel<TModel> {
	    gameModelId: string;
	    gameName: string;
	    data: TModel;
	    /**
	     * Constructor
	     * @param response: the response of the motors model request
	     */
	    constructor(response: any);
	}
}

declare module "@gdk/gamekit/game/action/session" {
	import type { IMtrBetResult, IMtrSession, IMtrReplaySession } from "@falcon/bridge";
	import type { IAmount } from "@gdk/core";
	import type { Action } from "@gdk/gamekit/game/action/action";
	export enum ESessionMode {
	    Default = "default",
	    Resume = "resume",
	    Replay = "replay"
	}
	/**
	 * Motors Session.
	 * @template TGameData Session typings.
	 * @template TEventParameters "prm" typings.
	 * @template TEventResponse "evr" typings.
	 * @template TModel model definition.
	 */
	export class MotorsSession<TGameData, TEventParameters, TEventResponse, TModel> {
	    /**
	     * Demo mode.
	     */
	    demo?: boolean;
	    /**
	     * Session id.
	     */
	    id?: string;
	    /**
	     * Current session state.
	     */
	    state?: string;
	    /**
	     * Session game data. Must be used ONLY for resuming game.
	     * It will be undefined in replay mode.
	     */
	    sessionData?: TGameData;
	    /**
	     * Bet amount.
	     */
	    betAmount?: IAmount;
	    /**
	     * Won amount, defined only when the game is done or in replay mode.
	     */
	    wonAmount?: IAmount;
	    /**
	     * Last bet/updatebet EVR.
	     */
	    lastResponse?: TEventResponse;
	    /**
	     * Mtr session mode.
	     */
	    mode?: ESessionMode;
	    /**
	     * Game model id.
	     */
	    gmid?: number;
	    /**
	     *  Service name
	     */
	    serviceName?: string;
	    /**
	     * Application id
	     */
	    applicationId: string;
	    private _game;
	    /**
	     * In case of a replay/resume, steps of the session.
	     */
	    private _steps?;
	    /**
	     * In case of a replay/resume, parameters of the bet.
	     */
	    private _initialStepParameters?;
	    /**
	     * Constructor.
	     * @param payload mtrSession or mtrBetResult
	     */
	    constructor(game: Action<TModel, TGameData, TEventResponse, TEventParameters, MotorsSession<TGameData, TEventParameters, TEventResponse, TModel>>, payload: IMtrSession<TGameData, TEventParameters, TEventResponse> | IMtrBetResult<TEventResponse> | IMtrReplaySession<TEventResponse, TEventParameters>);
	    /**
	     * Executes a Motors action and update the session with the response.
	     * @param event name of the event to trigger.
	     * @param parameters parameters for the event.
	     */
	    updateBet(event: string, parameters?: TEventParameters): Promise<void>;
	    /**
	     * Check if session has replay steps.
	     */
	    hasReplaySteps(): boolean;
	    /**
	     * Usable on replay mode.
	     * Returns next replay step as a betResult.
	     */
	    private _getReplayStepAsBetResult;
	    /**
	     * Usable on replay mode.
	     * Reurns initial action parameters.
	     */
	    getInitialReplayParameters(): TEventParameters;
	    /**
	     * Usable on replay mode.
	     * Returns next action parameters.
	     */
	    getNextReplayStepParameters(): TEventParameters;
	    /**
	     * Update state, last response and eventually wonAmount from BetResult.
	     * @param betResult
	     */
	    protected _updateFromBetResponse(betResult: IMtrBetResult<TEventResponse>): void;
	    /**
	     * Init session data from BetResult.
	     * @param betResult
	     */
	    private _initFromBetRespone;
	    /**
	     * Init session data from IMtrSession.
	     * This method must be used ONLY for resuming game.
	     * @param session
	     */
	    private _initFromSession;
	    /**
	     * Init session data from IMtrReplaySession.
	     * This method must be used ONLY for replaying or resuming a game.
	     * @param session
	     */
	    private _initFromReplaySession;
	    private _initFromSessionOrReplaySession;
	}
}

declare module "@gdk/gamekit/game/multipass/multipass" {
	import { Graphics } from "pixi.js";
	import type { IService, IMtpRoomParamsResult, IMtpRoom, IMtpBetResult, IMtpEnterRoomRequest, IMtpBetRequest, IMtpSession } from "@falcon/bridge";
	import type { IGameConf } from "@gdk/core";
	import type { ApplicationOptions } from "pixi.js";
	import { AbstractGame } from "@gdk/gamekit/game/abstractGame";
	import type { MultipassSession } from "@gdk/gamekit/game/multipass/session";
	import type { MultipassNotifications } from "@gdk/gamekit/game/multipass/notifications";
	export class Multipass extends AbstractGame {
	    room: IMtpRoom;
	    session: MultipassSession<any>;
	    notifications: MultipassNotifications;
	    protected wasHiddenOverlay: Graphics;
	    protected wasHidden: boolean;
	    /**
	     * Constructor
	     * @param gameConfig: the game configuration (game.conf.json)
	     * @param width: the canvas width
	     * @param height: the canvas height
	     * @param noWebGL: enable/disable WebGL (to force Canvas)
	     * @param options: the Pixi.js applicaiton options
	     */
	    constructor(gameConfig: IGameConf, width: number, height: number, noWebGL: boolean, options: ApplicationOptions);
	    /**
	     * To be implemented by the game: it asks to update the game session. This can be called automatically
	     * by notifications when a notification has been lost so the game has to be re-synchronized
	     * by calling "updateSession"
	     */
	    updateSession(): void;
	    /**
	     * Return the player's rooms
	     * @param parameters: the get rooms parameters (values to send to multipass)
	     * @param done: callback containing the player's rooms
	     */
	    getRooms(parameters?: IService): Promise<IMtpRoom[]>;
	    /**
	     * Enters the given room identified by its id
	     * @param parameters: the enter room parameters (values to send to multipass
	     * @param done: callback once the player entered the room
	     */
	    enterRoom(parameters: IMtpEnterRoomRequest): Promise<IMtpRoom>;
	    /**
	     * Gets the current session object of the given MTP game at the given roomId.
	     * @param parameters: the parameters containing the service name.
	     * @param roomId the id of the room containing the session to retrieve.
	     */
	    getSession<T>(parameters: IService, roomId: string): Promise<IMtpSession<T>>;
	    /**
	     * Retrieve room parameters (min/max players, variant parameters etc.)
	     * @param parameters: the request parameters (applicationId and service name with room id)
	     * @param done: callback once request done
	     */
	    getParameters<T>(parameters?: IService): Promise<IMtpRoomParamsResult<T>>;
	    /**
	     * Creates a bet
	     * @param parameters: the bet request parameters
	     * @param done: the callback when bet is done givng the bet response
	     */
	    bet(parameters: IMtpBetRequest): Promise<IMtpBetResult>;
	    /**
	     * Enters to a room and bets according to the given bet informations.
	     * @param options the options containing the room informations to enter and the bet informations.
	     */
	    enterAndBet(parameters: IMtpEnterRoomRequest & IMtpBetRequest): Promise<IMtpBetResult>;
	    /**
	     * Excutes an action
	     * @param parameters the execute parameters
	     * @param done callback once request is done
	     */
	    execute(parameters: IMtpBetRequest): Promise<IMtpBetResult>;
	}
}

declare module "@gdk/gamekit/game/multipass/session" {
	import type { IMtpSession } from "@falcon/bridge";
	import type { IMtpPlayer } from "@falcon/bridge/typings/platform";
	export class MultipassSession<T> {
	    id: string;
	    roomId: string;
	    playerId: string;
	    playerGameSessionId: string;
	    lastPlayerNotificationId: number;
	    lastGameSessionNotificationId: number;
	    totalUserInRoom: number;
	    totalActivePlayerInRoom: number;
	    players: IMtpPlayer[];
	    data: T;
	    publicData: any;
	    protectedData: any;
	    gameSessionState: string;
	    timestamp: number;
	    isInSession: boolean;
	    /**
	     * Constructor
	     * @param response the "getSession" response JSON object.
	     */
	    constructor(response?: any);
	    /**
	     * Update the session from the given response
	     * @param response the "getSession" response
	     */
	    updateFrom(response: IMtpSession<T>): void;
	}
}

declare module "@gdk/gamekit/game/multipass/notifications" {
	import type { PushChannel } from "@falcon/push-client";
	import type { Multipass } from "@gdk/gamekit/game/multipass/multipass";
	export enum EMultipassGameState {
	    PENDING = "PENDING",
	    ONGOING = "ONGOING",
	    FINISHED = "FINISHED"
	}
	export enum EMultipassNotificationType {
	    SESSION_INITIALIZED = "SESSION_INITIALIZED",
	    PLAYER_ENTER = "PLAYER_ENTER",
	    PAYOUT = "PAYOUT",
	    PLAYER_EXIT = "PLAYER_EXIT",
	    SCRIPT = "SCRIPT",
	    SESSION_CANCELLED = "SESSION_CANCELLED",
	    SESSION_STOPPED = "SESSION_STOPPED",
	    PLAYER_REMOVED = "PLAYER_REMOVED",
	    TRANSACTION_EVENT = "FALCON_TRANSACTION_EVENT"
	}
	export interface IMultipassNotification<T> {
	    broadcast: boolean;
	    sequenceNumber?: number;
	    gameState: EMultipassGameState;
	    roomId: string;
	    sessionId: string;
	    time: number;
	    type: EMultipassNotificationType;
	    content: T;
	}
	export class MultipassNotifications {
	    game: Multipass;
	    channel: PushChannel;
	    lastMessageId: number;
	    lastMessageBroadcastId: number;
	    onMessage: (data: IMultipassNotification<any>) => void;
	    private _muted;
	    private _closed;
	    private _timerId;
	    private _timerBroadcastId;
	    private _pendingNotifications;
	    private _pendingNotificationsBroadcast;
	    private _connectionPopin;
	    private _connectionRetryCount;
	    static tempo: number;
	    /**
	     * Constructor
	     * @param gameVariantName the game variant name to listen
	     * @param roomId the room id running the session with the given game variant name
	     */
	    constructor(game: Multipass, roomId?: string);
	    /**
	     * Creates the notifications channel
	     * @param roomId the room id running the session with the given game variant name
	     */
	    createChannel(roomId: string): Promise<void>;
	    /**
	     * Starts the notifications by connecting to the server
	     * @param retryCount the number of retries if connection failed
	     */
	    start(retryCount?: number): Promise<void>;
	    /**
	     * Closes the notifications by disconnecting from the server
	     */
	    close(): Promise<void>;
	    /**
	     * Returns if the notifications are muted or not
	     */
	    get muted(): boolean;
	    /**
	     * Mutes the notifications
	     */
	    set muted(muted: boolean);
	    /**
	     * Dispatches the given data by checking the last message id etc.
	     * @param data the data to dispatch
	     */
	    dispatchNotification(data: IMultipassNotification<any>): void;
	    /**
	     * Emits the given notification and updates the last message Id
	     * for private messages and broadcasts
	     * @param data the notification data
	     */
	    emitNotification(data: IMultipassNotification<any>): void;
	    /**
	     * Reset the notifications datas
	     */
	    reset(): void;
	    /**
	     * Setups pending notifications (reset tempo, create tempo etc.)
	     */
	    private _setupNotification;
	    /**
	     * Setups the pending notifications by adding the given notification to the pending
	     * list. If the timer wasn't created, the timer is created
	     */
	    private _setupPendingNotifications;
	    /**
	     * Shifts all the pending notifications until we find a hole
	     * in sequence number. If the count of pending notifications is equal
	     * to 0, then the associated timer is cleared
	     */
	    private _shiftNotifications;
	    private _updateSession;
	}
}

declare module "@gdk/gamekit/game/tweenUtils" {
	import { TweenMax } from "gsap";
	import { Timeline } from "@gdk/core-pixi";
	import type { Tween, TimelineMax } from "gsap";
	export class TweenUtils {
	    /**
	     * List of all paused tweens when calling TweenUtils.pauseAllTweens()
	     */
	    static pausedTweens: Tween[];
	    /**
	     * List of spine timelines
	     */
	    static rulesTweens: Array<Tween | Timeline>;
	    private static _forcedPause;
	    /**
	     * sets the TweenMax global time scale and apply that change to all Howler sounds speed rate.
	     */
	    static set globalTimeScale(value: number);
	    /**
	     * get the TweenMax global time scale.
	     */
	    static get globalTimeScale(): number;
	    /**
	     * Pauses all the active tweens
	     * @param forcedPause whether or not the user forced the pause and will have to manually resume all
	     */
	    static pauseAllTweens(forcedPause?: boolean): void;
	    /**
	     * Resumes all the given tweens (which was previously paused)
	     * @param forcedResume whether or not the user forced the pause so should force resume to resume all tweens
	     */
	    static resumeAllTweens(forcedResume?: boolean): void;
	    /**
	     * Pauses all tweens of the rules view
	     */
	    static pauseRulesTweens(): void;
	    /**
	     * Resumes all the tweens of the rules view
	     */
	    static resumeRulesTweens(): void;
	    /**
	     * Waits for the given duration before the promise is resolved.
	     * @param duration the time to wait in seconds.
	     */
	    static wait(duration: number): Promise<void>;
	    /**
	     * Static method for creating a TweenMax instance that animates to the specified destination values (from the current values).
	     * @param args the TweenMax.to arguments.
	     * @returns only the promise resolved when tween has been completed.
	     */
	    static to(...args: Parameters<typeof TweenMax.to>): Promise<void>;
	    /**
	     * Static method for creating a TweenMax instance that allows you to define both the starting and ending
	     * values (as opposed to to() and from() tweens which are based on the target's current values at one end or the other).
	     * @param args the TweenMax.fromTo arguments.
	     * @returns only the promise resolved when tween has been completed.
	     */
	    static fromTo(...args: Parameters<typeof TweenMax.fromTo>): Promise<void>;
	    /**
	     * Make a TweenMax / TimelineMax functions into a promise
	     * @param anim: The anim data
	     * @param includeDelay: Include delay when restarting the animation
	     * @Return Promise which is resolved when TweenMax / TimelineMax animation is completed
	     */
	    static playTween(anim: TimelineMax | TweenMax, includeDelay?: boolean): Promise<void>;
	}
}

declare module "@gdk/gamekit/game/ui/index" {
	export * from "@gdk/gamekit/game/ui/rules/index";
	export * from "@gdk/gamekit/game/ui/home/home";
	export * from "@gdk/gamekit/game/ui/result/index";
	export * from "@gdk/gamekit/game/ui/game/timer";
	export * from "@gdk/gamekit/game/ui/crossSell/crossSell";
}

declare module "@gdk/gamekit/game/ui/rules/index" {
	export { Rules, IRulesStyle } from "@gdk/gamekit/game/ui/rules/rules";
	export { Slide } from "@gdk/gamekit/game/ui/rules/slide";
	export { TextSlide, ISlideTextStyle, ELayout, ISlideStylePadding, SlideStylePaddingFunction, SlideStylePaddingValue, } from "@gdk/gamekit/game/ui/rules/textSlide";
	export { BaseSlide } from "@gdk/gamekit/game/ui/rules/baseSlide";
	export { AgreementSlide, IAgreementStyle } from "@gdk/gamekit/game/ui/rules/agreement";
}

declare module "@gdk/gamekit/game/ui/rules/rules" {
	import { Container, Sprite, Texture } from "pixi.js";
	import { Popup, Button } from "@gdk/core-pixi";
	import type { IPopupStyle, IButtonStyle } from "@gdk/core-pixi";
	import type { Point } from "pixi.js";
	import type { Slide } from "@gdk/gamekit/game/ui/rules/slide";
	export interface IRulesStyle {
	    popup: IPopupStyle | Popup;
	    nextButton: IButtonStyle | Button;
	    previousButton: IButtonStyle | Button;
	    bulletPoint: {
	        idle: string | Texture;
	        active: string | Texture;
	    };
	}
	export class Rules extends Container {
	    popup: Popup;
	    nextButton: Button;
	    previousButton: Button;
	    bullet: Container;
	    loop: boolean;
	    idleBulletTexture: Texture;
	    activeBulletTexture: Texture;
	    onClose: () => void;
	    onNext: () => void;
	    onPrevious: () => void;
	    onChangeSlide: () => void;
	    protected _slides: Slide[];
	    protected _currentSlide: Slide;
	    protected config: IRulesStyle;
	    protected currentBullet: Sprite;
	    protected touchStartTime: number;
	    protected touchStartPosition: Point;
	    protected touchEndPosition: Point;
	    protected containerToListen: Container;
	    /**
	     * Constructor
	     */
	    constructor(config: IRulesStyle);
	    /**
	     * Returns the slides
	     */
	    get slides(): Slide[];
	    /**
	     * Returns the current slide
	     */
	    get currentSlide(): Slide;
	    /**
	     * Sets the current slide
	     */
	    set currentSlide(slide: Slide);
	    /**
	     * Adds a slide to the rules popup
	     * @param slide the slide to add (can be a custom slide extending Slide)
	     */
	    addSlide(slide: Slide): void;
	    /**
	     * Removes the given slide from the rules popup
	     * @param slide the slide to remove
	     */
	    removeSlide(slide: Slide): void;
	    /**
	     * Returns a slide identified by the given name
	     * @param name the name of the slide to find
	     */
	    getSlideByName(name: string): Slide;
	    /**
	     * Removes all the slides from the rules component
	     */
	    removeAllSlides(): void;
	    /**
	     * Resets the rules component (rollback to first slide)
	     */
	    reset(): void;
	    /**
	     * Show the popup with the added slides
	     * @param loopMode a tag to set the loop mode through slides
	     */
	    show(loopMode?: boolean): void;
	    /**
	     * Switch to the specified slide by its index and returns the instance of the next slide
	     * @param index The index slide
	     * @return the specified slide
	     */
	    changeSlideByIndex(index: number): Slide;
	    /**
	     * Switches to the next slide and returns the instance of the next slide
	     * @return: the next slide
	     */
	    next(): Slide;
	    /**
	     * Switches to the previous slides and returns the instance of the previous slide
	     * @return: the next slide
	     */
	    previous(): Slide;
	    /**
	     * Closes the rules popup
	     */
	    close(): void;
	    /**
	     * Add a bullet point
	     */
	    private _addBullet;
	    /**
	     * show bullets while updating its texture
	     * @param currentIndex the index of the bullet to be activated
	     */
	    private _updateBulletsTexture;
	    private _bindEvents;
	    /**
	     * Listen to touchstart event
	     * @param ev: The interaction event data
	     */
	    private _onTouchStart;
	    /**
	     * Listen to touchend event
	     * @param ev: The interaction event data
	     */
	    private _onTouchEnd;
	    /**
	     * Add a container to listen for swipe event
	     * @param nextContainerToListen: The container to listen
	     */
	    addSwipeListenerToContainer(nextContainerToListen?: Container): void;
	    /**
	     * Export the rules component
	     */
	    export(): any;
	    /**
	     * Parses the rules component
	     * @param config the serialized data
	     * @param baseUrl the base url of the loader
	     */
	    static parse(config: any, baseUrl: string, rules?: Rules): Rules;
	}
}

declare module "@gdk/gamekit/game/ui/rules/slide" {
	import { Container } from "pixi.js";
	import type { Rules } from "@gdk/gamekit/game/ui/rules/rules";
	export abstract class Slide extends Container {
	    hasBullet: boolean;
	    /**
	     * Constructor
	     */
	    constructor();
	    /**
	     * Configures the slide in the given popup
	     * @param rules the popup containing the slide
	     */
	    configure(rules: Rules): void;
	    /**
	     * Called when showing the slide in the rules popup
	     */
	    onShow(rules: Rules): void;
	    /**
	     * Called when hiding the slide in the rules popup
	     */
	    onHide(rules: Rules): void;
	    /**
	     * On destroy the slide
	     */
	    onDestroy(rules: Rules): void;
	}
}

declare module "@gdk/gamekit/game/ui/rules/textSlide" {
	import { Sprite } from "pixi.js";
	import { TextArea, EAlign } from "@gdk/core-pixi";
	import type { IStyles } from "@gdk/core-pixi";
	import type { Container } from "pixi.js";
	import { Slide } from "@gdk/gamekit/game/ui/rules/slide";
	import type { Rules } from "@gdk/gamekit/game/ui/rules/rules";
	export enum ELayout {
	    TextLeft = 0,
	    TextTop = 1,
	    TextPadding = 2
	}
	export type SlideStylePaddingFunction<SlideType> = (slide: SlideType) => number;
	export type SlideStylePaddingValue<SlideType> = SlideStylePaddingFunction<SlideType> | number;
	export const getSlideStylePaddingValue: <SlideType>(value: SlideStylePaddingValue<SlideType>, slide: SlideType) => number;
	export interface ISlideStylePadding<SlideType> {
	    top?: SlideStylePaddingValue<SlideType>;
	    bottom?: SlideStylePaddingValue<SlideType>;
	    left?: SlideStylePaddingValue<SlideType>;
	    right?: SlideStylePaddingValue<SlideType>;
	}
	export interface ISlideTextStyle {
	    text?: {
	        text?: string;
	        style?: IStyles;
	        align?: EAlign;
	        padding?: ISlideStylePadding<TextSlide>;
	    };
	    title?: string | Sprite | {
	        text?: string;
	        style?: IStyles;
	        align?: EAlign;
	        padding?: ISlideStylePadding<TextSlide>;
	    };
	    image?: string | Container;
	    layout?: ELayout;
	    hasBullet?: boolean;
	}
	export class TextSlide extends Slide {
	    title: TextArea | Container;
	    text: TextArea;
	    image: Container;
	    layout: ELayout;
	    protected textPadding: ISlideStylePadding<TextSlide>;
	    protected titlePadding: ISlideStylePadding<TextSlide>;
	    /**
	     * Constructor
	     * @param config: the slide's style
	     */
	    constructor(config?: ISlideTextStyle);
	    /**
	     * Sets the slide text style (config)
	     */
	    set config(config: ISlideTextStyle);
	    /**
	     * Configures the slide in the given popup
	     * @param popup the popup containing the slide
	     */
	    configure(rules: Rules): void;
	    /**
	     * Called when showing the slide in the rules popup
	     */
	    onShow(rules: Rules): void;
	    /**
	     * Called when hiding the slide in the rules popup
	     */
	    onHide(rules: Rules): void;
	}
}

declare module "@gdk/gamekit/game/ui/rules/baseSlide" {
	import { Slide } from "@gdk/gamekit/game/ui/rules/slide";
	import type { Rules } from "@gdk/gamekit/game/ui/rules/rules";
	export class BaseSlide extends Slide {
	    /**
	     * Constructor
	     */
	    constructor();
	    /**
	     * Configures the slide in the given popup
	     * @param rules the popup containing the slide
	     */
	    configure(rules: Rules): void;
	    /**
	     * Called when showing the slide in the rules popup
	     * @param rules the popup containing the slide
	     */
	    onShow(rules: Rules): void;
	    /**
	     * Called when hiding the slide in the rules popup
	     * @param rules the popup containing the slide
	     */
	    onHide(rules: Rules): void;
	    /**
	     * Exports the base slide
	     */
	    export(): any;
	    /**
	     * Creates a new base slide. Function used by project loader
	     * @param config the JSON representation of the save slide.
	     * @param baseUrl the base Url where to find other assets if needed to be loaded incrementally.
	     */
	    static parse(config: any, baseUrl: string): BaseSlide;
	}
}

declare module "@gdk/gamekit/game/ui/rules/agreement" {
	import { Button, TextField } from "@gdk/core-pixi";
	import type { IStyles, IButtonStyle } from "@gdk/core-pixi";
	import { TextSlide } from "@gdk/gamekit/game/ui/rules/index";
	import type { ITrigger } from "@gdk/gamekit/com/index";
	import type { Rules, ISlideTextStyle, ISlideStylePadding } from "@gdk/gamekit/game/ui/rules/index";
	export interface IAgreementStyle extends ISlideTextStyle {
	    okButtonStyle?: IButtonStyle | Button;
	    gameRuleStyle?: TextField | IStyles;
	    gameRulePadding?: ISlideStylePadding<AgreementSlide>;
	    generalRuleStyle?: TextField | IStyles;
	    generalRulePadding?: ISlideStylePadding<AgreementSlide>;
	}
	export class AgreementSlide extends TextSlide {
	    /**
	     * Ok button reference being added when the agreement slide is shown
	     */
	    okButton: Button;
	    /**
	     * The general rules textfield working as a link
	     */
	    generalRule: TextField;
	    /**
	     * The game rules textfield working as a link
	     */
	    gameRule: TextField;
	    /**
	     * If the agreement slide should be auto-configured in the .configure method. True by default.
	     */
	    autoConfigure: boolean;
	    /**
	     * The com trigger reference used to open general rules and game rules
	     */
	    com: ITrigger;
	    private _gameRulePadding;
	    private _generalRulePadding;
	    /**
	     * Constructor
	     * @param com communication trigger
	     * @param style slide style
	     */
	    constructor(com: ITrigger, style: IAgreementStyle);
	    /**
	     * Configures the slide in the given popup
	     * @param rules the popup containing the slide
	     */
	    configure(rules: Rules): void;
	    /**
	     * Called when showing the slide in the rules popup
	     * @param rules the popup containing the slide
	     */
	    onShow(rules: Rules): void;
	    /**
	     * Called when hiding the slide in the rules popup
	     * @param rules the popup containing the slide
	     */
	    onHide(rules: Rules): void;
	    /**
	     * On destroy the slide
	     * @param rules the popup containing the slide
	     */
	    onDestroy(rules: Rules): void;
	    /**
	     * Exports the agreement slide
	     */
	    export(): any;
	    /**
	     * Creates a new agremment slide. Function used by project loader
	     * @param config the serialized data
	     * @param baseUrl the base url of the loader
	     */
	    static parse(config: any, baseUrl: string): AgreementSlide;
	}
}

declare module "@gdk/gamekit/game/ui/home/home" {
	import { Container, Sprite } from "pixi.js";
	import { Button, TextArea } from "@gdk/core-pixi";
	import type { IButtonStyle, IStyles } from "@gdk/core-pixi";
	/**
	 * Home text style, represents a text in the home component
	 */
	export interface IHomeTextStyle {
	    text?: string;
	    styles: IStyles;
	}
	/**
	 * Home button style, represents a the style of the play button
	 */
	export interface IHomeButtonStyle {
	    style: IButtonStyle;
	    text?: IHomeTextStyle;
	}
	/**
	 * Represents the overall style of the home component
	 */
	export interface IHomeStyle {
	    playButton: Button | IHomeButtonStyle;
	    gameName: string | Container | IHomeTextStyle;
	    claim: string | Container | IHomeTextStyle;
	}
	export class Home extends Container {
	    playButton: Button;
	    gameName: TextArea | Sprite | Container;
	    claim: TextArea | Sprite | Container;
	    /**
	     * Constructor
	     * @param config The home style
	     */
	    constructor(config: IHomeStyle);
	}
}

declare module "@gdk/gamekit/game/ui/result/index" {
	export { ResultBox, IDefaultResultBoxStyle, EResultBoxEvents } from "@gdk/gamekit/game/ui/result/resultBox";
	export { ResultStage } from "@gdk/gamekit/game/ui/result/resultStage";
	export { ScratchStage, IScratchResultStyle } from "@gdk/gamekit/game/ui/result/scratchStage";
	export { TextResultStage, ITextResultStyle, ITextResultLooser, ITextResultSounds, ITextResultThreshold, } from "@gdk/gamekit/game/ui/result/textResultStage";
	export { AmountResultStage, IAmountResultStyle } from "@gdk/gamekit/game/ui/result/amountResultStage";
}

declare module "@gdk/gamekit/game/ui/result/resultBox" {
	import { TweenMax } from "gsap";
	import { Container, particles, Sprite } from "pixi.js";
	import type { IStyles, SpineTimeline, TextField, IProjectContainer } from "@gdk/core-pixi";
	import type { IAmount } from "@gdk/core";
	import type { Howl } from "howler";
	import { TextResultStage } from "@gdk/gamekit/game/ui/result/textResultStage";
	import { AmountResultStage } from "@gdk/gamekit/game/ui/result/amountResultStage";
	import type { IScratchResultStyle } from "@gdk/gamekit/game/ui/result/scratchStage";
	import { ScratchStage } from "@gdk/gamekit/game/ui/result/scratchStage";
	import type { IAmountCoinWizzStyle } from "@gdk/gamekit/game/ui/result/amountCoinWizzStage";
	import { AmountCoinWizzStage } from "@gdk/gamekit/game/ui/result/amountCoinWizzStage";
	import type { IAmountCurrencyWizzStyle } from "@gdk/gamekit/game/ui/result/amountCurrencyWizzStage";
	import { AmountCurrencyWizzStage } from "@gdk/gamekit/game/ui/result/amountCurrencyWizzStage";
	import type { ISpineStageStyle } from "@gdk/gamekit/game/ui/result/spineStage";
	import { SpineStage } from "@gdk/gamekit/game/ui/result/spineStage";
	import type { AbstractGame } from "@gdk/gamekit/game/abstractGame";
	import type { IAmountResultStyle } from "@gdk/gamekit/game/ui/result/amountResultStage";
	import type { ITextResultStyle } from "@gdk/gamekit/game/ui/result/textResultStage";
	export enum EResultBoxEvents {
	    StageAppear = "StageAppear",
	    StageDisappear = "StageDisappear",
	    StageHasEntered = "StageHasEntered",
	    StageWillExit = "StageWillExit"
	}
	export interface IDefaultResultBoxStyle {
	    textStyles: {
	        mainTextWinner: Sprite | IStyles;
	        subText1Winner: Sprite | IStyles;
	        mainTextLooser: Sprite | IStyles;
	        subText1Looser: Sprite | IStyles;
	        subText2Looser: Sprite | IStyles;
	    };
	    winAmountTextStyle: IStyles;
	    disappears?: boolean;
	    amountDisappears?: boolean;
	    amountVerticalMargin?: number;
	    thresholds?: Array<{
	        mainText?: string;
	        subText?: string;
	        duration?: number;
	        animated?: boolean;
	        multiplier?: number;
	    }>;
	    thresholdsTexts?: Array<Partial<{
	        mainText: string;
	        subText: string;
	    }>>;
	    looserTexts?: Partial<{
	        mainText: string;
	        subText1: string;
	        subText2: string;
	    }>;
	    sounds?: {
	        loser?: string | Howl;
	        winner?: string | Howl;
	        incrementation?: string | Howl;
	    };
	    backgroundScratch?: {
	        loser?: string;
	        winner?: string;
	    };
	    particleSystems?: IParticleSystemStyle;
	    minimumFractionDigits?: number;
	    looserDuration?: number;
	}
	interface IParticleSystemStyle {
	    count: number;
	    sprites?: string[];
	    alpha: boolean;
	    position: boolean;
	    scale: boolean;
	}
	export interface IWizzResultBoxStyle {
	    game: AbstractGame;
	    winAmountTextStyle: IStyles;
	    sounds?: {
	        loser?: string | Howl;
	        winner?: string | Howl;
	        incrementation?: string | Howl;
	    };
	    hasCoinsAnimation?: boolean;
	    animationSpine?: {
	        assetIDWinner?: string;
	        assetIDLoser?: string;
	        assetIDCoins?: string;
	    };
	    minimumFractionDigits?: number;
	    loserDuration?: number;
	    winnerDuration?: number;
	}
	export interface IWizzCurrencyResultBoxStyle {
	    game: AbstractGame;
	    winAmountTextStyle: IStyles;
	    winAmountStrokeTextStyle: IStyles;
	    sounds?: {
	        loser?: string | Howl;
	        winner?: string | Howl;
	        incrementation?: string | Howl;
	    };
	    hasCoinsAnimation?: boolean;
	    animationSpine?: {
	        assetIDLoser?: string | SpineTimeline;
	        assetIDRollingFX?: string | SpineTimeline;
	    };
	    sprites?: {
	        currencyBackSprite?: Sprite;
	        currencyMovingSprite?: Sprite;
	        winTextSprite?: Sprite;
	    };
	    minimumFractionDigits?: number;
	}
	export interface IDefaultSpineResultBoxStyle {
	    thresholdsTexts: Array<{
	        mainText: string;
	        subText: string;
	    }>;
	    looserTexts: {
	        mainText: string;
	        subText: string;
	    };
	    winMainText?: TextField;
	    winSubText?: TextField;
	    winAmountText?: TextField;
	    loseMainText?: TextField;
	    loseSubText?: TextField;
	    thresholdsWinAmount?: number[];
	    winSpineTimeline: SpineTimeline;
	    loseSpineTimeline: SpineTimeline;
	    winEnterAnimationName?: string;
	    winExitAnimationName?: string;
	    loseEnterAnimationName?: string;
	    loseExitAnimationName?: string;
	    winnerDuration?: number;
	    loserDuration?: number;
	}
	export interface IProjectResulBox extends IProjectContainer {
	    resultBox: {
	        particleSystems?: IParticleSystemStyle;
	        stages: {
	            type: string;
	            config: IAmountCoinWizzStyle | IAmountCurrencyWizzStyle | IAmountResultStyle | IScratchResultStyle | ISpineStageStyle | ITextResultStyle;
	        }[];
	    };
	}
	export type Stage = AmountCoinWizzStage | AmountCurrencyWizzStage | AmountResultStage | ScratchStage | SpineStage | TextResultStage;
	export class ResultBox extends Container {
	    particleSystem: particles.ParticleContainer;
	    protected particleSystemConfig: IParticleSystemStyle;
	    onNext: (stage: Stage) => void;
	    protected _amount: IAmount;
	    protected _stages: Stage[];
	    protected _currentStage: Stage;
	    protected particleTweens: TweenMax[];
	    /**
	     * Constructor
	     * @param config the result box config (style)
	     */
	    constructor();
	    /**
	     * Returns the available stages (only get)
	     */
	    get stages(): Stage[];
	    /**
	     * Returns the current amount won by the player
	     */
	    get amount(): IAmount;
	    /**
	     * Animates the result box (automatically send the
	     * matching tracking event)
	     */
	    animate(amount: IAmount, done: () => void): void;
	    /**
	     * Goes to the next stage
	     */
	    next(done?: () => void): void;
	    /**
	     * Add a stage to the result box
	     * @param stage the stage to add
	     */
	    addStage(stage: Stage, index?: number): void;
	    /**
	     * Removes a stage from the result box
	     * @param stage the stage reference to remove
	     */
	    removeStage(stage: Stage): void;
	    /**
	     * Creates particles globally applied on the result box
	     */
	    createParticles(size: number, particleSprites: string[], properties: particles.ParticleContainerProperties): void;
	    /**
	     * Starts the particle system
	     */
	    startParticleSystem(deltaTime?: number): void;
	    /**
	     * Returns a result box following the wizz guidelines for game giving coins
	     */
	    static createCoinWizz(config: IWizzResultBoxStyle, stake?: IAmount): ResultBox;
	    /**
	     * Returns a result box following the wizz guidelines for game giving true currency
	     */
	    static createCurrencyWizz(config: IWizzCurrencyResultBoxStyle, stake?: IAmount): ResultBox;
	    /**
	     * Returns a default result box following the Illiko guidelines
	     */
	    static createDefault(config: IDefaultResultBoxStyle, stake?: IAmount): ResultBox;
	    /**
	     * Returns a result box containing a popup used for scratch games
	     */
	    static createDefaultScratch(config: IDefaultResultBoxStyle, stake?: IAmount): ResultBox;
	    /**
	     * Returns a result box containing spines used for games using spines
	     */
	    static createDefaultSpine(config: IDefaultSpineResultBoxStyle, stake?: IAmount): ResultBox;
	    export(): IProjectResulBox;
	    static parse(config: IProjectResulBox, baseUrl: string): ResultBox;
	}
	export {};
}

declare module "@gdk/gamekit/game/ui/result/textResultStage" {
	import { Container } from "pixi.js";
	import { TextArea } from "@gdk/core-pixi";
	import { Howl } from "howler";
	import type { IStyles } from "@gdk/core-pixi";
	import { ResultStage } from "@gdk/gamekit/game/ui/result/resultStage";
	import type { ResultBox } from "@gdk/gamekit/game/ui/result/resultBox";
	export interface ITextResultThreshold {
	    amount: number;
	    mainText: string;
	    subText1: string;
	    animated?: boolean;
	    duration?: number;
	}
	export interface ITextResultLooser {
	    disappears?: boolean;
	    mainText: string;
	    subText1: string;
	    subText2: string;
	}
	export interface ITextResultSounds {
	    loser?: Howl | string;
	    winner?: Howl | string;
	}
	export interface ITextResultStyle {
	    mainTextWinner: Container | IStyles;
	    subText1Winner: Container | IStyles;
	    mainTextLooser: Container | IStyles;
	    subText1Looser: Container | IStyles;
	    subText2Looser: Container | IStyles;
	    winningThresholds: ITextResultThreshold[];
	    looserTexts: ITextResultLooser;
	    looserDuration: number;
	    sounds?: ITextResultSounds;
	}
	export class TextResultStage extends ResultStage {
	    mainText: Container | TextArea;
	    subText1: Container | TextArea;
	    subText2: Container | TextArea;
	    config: ITextResultStyle;
	    private _loseSound;
	    private _winSound;
	    /**
	     * Constructor
	     */
	    constructor(config: ITextResultStyle);
	    /**
	     * On show the result box
	     * @param box the result box reference
	     * @param done the callback to call when stage animation done
	     */
	    onShow(box: ResultBox, done: (stop: boolean, hide?: boolean) => void): void;
	    protected animate(box: ResultBox, duration: number, done: (stop: boolean, hide?: boolean) => void): void;
	}
}

declare module "@gdk/gamekit/game/ui/result/resultStage" {
	import { Container } from "pixi.js";
	import type { ResultBox } from "@gdk/gamekit/game/ui/result/resultBox";
	export abstract class ResultStage extends Container {
	    /**
	     * Show the stage
	     * @param done The callback to call when animation done
	     */
	    abstract onShow(box: ResultBox, done: (stop: boolean, hide?: boolean) => void): void;
	    /**
	     * Hide the stage
	     * @param progressive: If true, stage is hidden in 0.3s, otherwise in 0s.
	     */
	    onHide(progressive: boolean): Promise<void>;
	    /**
	     * Hide the stage immediatly
	     */
	    hide(): void;
	}
}

declare module "@gdk/gamekit/game/ui/result/amountResultStage" {
	import { Sprite, Container } from "pixi.js";
	import { TextArea } from "@gdk/core-pixi";
	import { Howl } from "howler";
	import type { IStyles } from "@gdk/core-pixi";
	import { ResultStage } from "@gdk/gamekit/game/ui/result/resultStage";
	import type { ResultBox } from "@gdk/gamekit/game/ui/result/resultBox";
	export interface IAmountResultThreshold {
	    raysCount: number;
	    amount: number;
	}
	export interface IThresholdConfig {
	    amount: number;
	    duration?: number;
	    animated?: boolean;
	}
	export interface IAmountResultStyle {
	    smallRaySprite: string;
	    bigRaySprite: string;
	    middleSprite: string;
	    amountStyle: IStyles;
	    amountDisappears?: boolean;
	    amountVerticalMargin?: number;
	    raysPerThreshold: number;
	    thresholds: Array<number | IThresholdConfig>;
	    appearTime?: number;
	    stayTime?: number;
	    disappearTime?: number;
	    sounds?: {
	        incrementation?: Howl | string;
	    };
	    minimumFractionDigits?: number;
	}
	export class AmountResultStage extends ResultStage {
	    rays: Sprite[];
	    raysContainer: Container;
	    fastRaysContainer: Container;
	    middleSprite: Container;
	    amount: TextArea;
	    config: IAmountResultStyle;
	    protected currentAmount: number;
	    private _totalRaysCount;
	    private _averageRaysCount;
	    private _incrementationSound;
	    private _animatedThresholds;
	    /**
	     * Constructor
	     */
	    constructor(config: IAmountResultStyle);
	    /**
	     * On show the result box
	     * @param box the result box reference
	     * @param done the callback to call when stage animation done
	     */
	    onShow(box: ResultBox, done: (stop: boolean) => void): void;
	    protected showStatic(box: ResultBox, threshold: IThresholdConfig, done: (stop: boolean) => void): void;
	    protected showAnimated(box: ResultBox, done: (stop: boolean) => void): void;
	    /**
	     * Hide the stage
	     * @param progressive: If true, stage is hidden in 0.3s, otherwise in 0s.
	     */
	    onHide(progressive: boolean): Promise<void>;
	    /**
	     * Hide the stage immediatly
	     */
	    hide(): void;
	}
}

declare module "@gdk/gamekit/game/ui/result/scratchStage" {
	import { Container, Sprite } from "pixi.js";
	import { TextArea } from "@gdk/core-pixi";
	import type { IStyles } from "@gdk/core-pixi";
	import { ResultStage } from "@gdk/gamekit/game/ui/result/resultStage";
	import type { ResultBox } from "@gdk/gamekit/game/ui/result/resultBox";
	import type { ITextResultThreshold, ITextResultLooser, ITextResultSounds } from "@gdk/gamekit/game/ui/result/textResultStage";
	export interface IScratchResultStyle {
	    backgroundTexture?: {
	        loser?: string;
	        winner?: string;
	    };
	    disappears?: boolean;
	    mainTextWinner: Container | IStyles;
	    subText1Winner: Container | IStyles;
	    mainTextLooser: Container | IStyles;
	    subText1Looser: Container | IStyles;
	    subText2Looser: Container | IStyles;
	    amountStyle?: IStyles;
	    winningThresholds: ITextResultThreshold[];
	    looserTexts: ITextResultLooser;
	    looserDuration?: number;
	    sounds?: ITextResultSounds;
	    minimumFractionDigits?: number;
	}
	export class ScratchStage extends ResultStage {
	    mainText: Container | TextArea;
	    subText1: Container | TextArea;
	    subText2: Container | TextArea;
	    config: IScratchResultStyle;
	    background: Sprite;
	    private _amount;
	    private _loseSound;
	    private _winSound;
	    constructor(config: IScratchResultStyle);
	    /**
	     * onShow
	     * @param box
	     * @param done
	     */
	    onShow(box: ResultBox, done: (stop: boolean) => void): void;
	    /**
	     * Hide the stage
	     * @param progressive: If true, stage is hidden in 0.3s, otherwise in 0s.
	     */
	    onHide(progressive: boolean): Promise<void>;
	}
}

declare module "@gdk/gamekit/game/ui/result/amountCoinWizzStage" {
	import { Container } from "pixi.js";
	import { TextArea, SpineTimeline } from "@gdk/core-pixi";
	import { Howl } from "howler";
	import type { IStyles } from "@gdk/core-pixi";
	import { ResultStage } from "@gdk/gamekit/game/ui/result/resultStage";
	import type { ResultBox } from "@gdk/gamekit/game/ui/result/resultBox";
	import type { AbstractGame } from "@gdk/gamekit/game/abstractGame";
	export interface IAmountCoinWizzThreshold {
	    amount: number;
	}
	export interface IAmountCoinWizzSounds {
	    loser?: Howl | string;
	    winner?: Howl | string;
	    incrementation?: Howl | string;
	}
	export interface IAmountCoinWizzAnimations {
	    loser?: SpineTimeline | string;
	    winner?: SpineTimeline | string;
	    coin?: SpineTimeline | string;
	}
	export interface ITextResultEndGame {
	    mainText: string;
	    subText1: string;
	}
	export interface IAmountCoinWizzStyle {
	    game: AbstractGame;
	    amountStyle: IStyles;
	    hasCoinsAnimation: boolean;
	    animationSpine?: IAmountCoinWizzAnimations;
	    sounds?: IAmountCoinWizzSounds;
	    loserDuration?: number;
	    winnerDuration?: number;
	}
	export class AmountCoinWizzStage extends ResultStage {
	    mainText: Container | TextArea;
	    subText1: Container | TextArea;
	    config: IAmountCoinWizzStyle;
	    private _loseSound;
	    private _winSound;
	    private _incrementationSound;
	    private _winAnimation;
	    private _coinAnimation;
	    private _coins;
	    private _lostAnimation;
	    private _amount;
	    private coinsContainer;
	    private purse;
	    private static coinsPosition;
	    /**
	     * Constructor
	     */
	    constructor(config: IAmountCoinWizzStyle);
	    /**
	     * On show the result box
	     * @param box the result box reference
	     * @param done the callback to call when stage animation done
	     */
	    onShow(box: ResultBox, done: (stop: boolean) => void): void;
	}
}

declare module "@gdk/gamekit/game/ui/result/amountCurrencyWizzStage" {
	import { Sprite, Container } from "pixi.js";
	import { TextArea, SpineTimeline } from "@gdk/core-pixi";
	import { Howl } from "howler";
	import type { IStyles } from "@gdk/core-pixi";
	import { ResultStage } from "@gdk/gamekit/game/ui/result/resultStage";
	import type { ResultBox } from "@gdk/gamekit/game/ui/result/resultBox";
	import type { AbstractGame } from "@gdk/gamekit/game/abstractGame";
	export interface IAmountCurrencyWizzThreshold {
	    amount: number;
	}
	export interface IAmountCurrencyWizzSounds {
	    loser?: Howl | string;
	    winner?: Howl | string;
	    increment?: Howl | string;
	}
	export interface IAmountCurrencyWizzAnimations {
	    loser?: SpineTimeline | string;
	    rollingFX?: SpineTimeline | string;
	}
	export interface IAmountCurrencyWizzSprites {
	    winTextSprite?: Sprite | string;
	    currencyBackSprite?: Sprite | string;
	    currencyMovingSprite?: Sprite | string;
	}
	export interface ITextResultEndGame {
	    mainText: string;
	    subText1: string;
	}
	export interface IAmountCurrencyWizzStyle {
	    game: AbstractGame;
	    amountStyle: IStyles;
	    amountStrokeStyle: IStyles;
	    hasCoinsAnimation: boolean;
	    animationSpine?: IAmountCurrencyWizzAnimations;
	    sounds?: IAmountCurrencyWizzSounds;
	    sprites?: IAmountCurrencyWizzSprites;
	    minimumFractionDigits: number;
	}
	export class AmountCurrencyWizzStage extends ResultStage {
	    mainText: Container | TextArea;
	    subText1: Container | TextArea;
	    config: IAmountCurrencyWizzStyle;
	    private _loseSound;
	    private _winSound;
	    private _incrementSound;
	    private _rollingFX;
	    private _lostAnimation;
	    private _referenceCoin;
	    private _movingCoins;
	    private _referenceBackgroundCoin;
	    private _backgroundCoins;
	    private _sparkles;
	    private _fxRayon;
	    private _winText;
	    private _amount;
	    private _amountStroke;
	    private _coinsContainer;
	    private sparkles;
	    private resultWin;
	    private purse;
	    private static coinsPosition;
	    private static sparkleRotation;
	    private static backgroundCoinsPosition;
	    private static numberPerRayon;
	    /**
	     * Constructor
	     */
	    constructor(config: IAmountCurrencyWizzStyle);
	    /**
	     * On show the result box
	     * @param box the result box reference
	     * @param done the callback to call when stage animation done
	     */
	    onShow(box: ResultBox, done: (stop: boolean) => void): void;
	}
}

declare module "@gdk/gamekit/game/ui/result/spineStage" {
	import type { SpineTimeline, TextField } from "@gdk/core-pixi";
	import { ResultStage } from "@gdk/gamekit/game/ui/result/resultStage";
	import type { ResultBox } from "@gdk/gamekit/game/ui/result/resultBox";
	export interface ISpineStageStyle {
	    thresholdsTexts: Array<{
	        mainText: string;
	        subText: string;
	    }>;
	    looserTexts: {
	        mainText: string;
	        subText: string;
	    };
	    winMainText: TextField;
	    winSubText: TextField;
	    winAmountText: TextField;
	    loseMainText: TextField;
	    loseSubText: TextField;
	    thresholdsWinAmount: number[];
	    winSpineTimeline: SpineTimeline;
	    loseSpineTimeline: SpineTimeline;
	    winEnterAnimationName: string;
	    winExitAnimationName: string;
	    loseEnterAnimationName: string;
	    loseExitAnimationName: string;
	    winnerDuration: number;
	    loserDuration: number;
	}
	export class SpineStage extends ResultStage {
	    config: ISpineStageStyle;
	    /**
	     * @constructor
	     * @param config Configuration of the stage
	     */
	    constructor(config: ISpineStageStyle);
	    /**
	     * onShow
	     * @param box
	     * @param done
	     */
	    onShow(box: ResultBox, done: (stop: boolean) => void): Promise<void>;
	    /**
	     * Reset the stage
	     */
	    reset(): void;
	}
}

declare module "@gdk/gamekit/game/ui/game/timer" {
	import { Container } from "pixi.js";
	import { TweenMax } from "gsap";
	import type { TextField } from "@gdk/core-pixi";
	export class Timer extends Container {
	    /**
	     * timer text with the countdown
	     */
	    timerText: TextField;
	    /**
	     * "game canceled after" text
	     */
	    txt: TextField;
	    /**
	     * "let's go!" text
	     */
	    txtGo: TextField;
	    /**
	     * current left time
	     */
	    protected time: number;
	    /**
	     * the time tween
	     */
	    protected tween: TweenMax;
	    /**
	     * the time promise
	     */
	    protected tweenPromise: Promise<void>;
	    /**
	     * The i18n key
	     */
	    private _key;
	    /**
	     * the timer start time
	     */
	    private _startTime;
	    /**
	     * Set the starting time in seconds
	     * @param time in seconds
	     */
	    set startTime(time: number);
	    /**
	     * Set the formating string key (count var used for time display)
	     * @param key the i18n key
	     */
	    set key(key: string);
	    /**
	     * Start the timer
	     * @param time, optional, set the start time in seconds
	     */
	    start(time?: number): Promise<void>;
	    /**
	     * Reset the timer to the startTime without start
	     */
	    reset(): void;
	    /**
	     * Pause the timer
	     */
	    pause(): void;
	    /**
	     * Unpause the timer
	     */
	    unpause(): Promise<void>;
	}
}

declare module "@gdk/gamekit/game/ui/crossSell/crossSell" {
	import { TweenMax } from "gsap";
	import { Container } from "pixi.js";
	import { SpineTimelineButton } from "@gdk/core-pixi";
	import type { ICrossSell } from "@gdk/core";
	import type { Button, SpineTimeline } from "@gdk/core-pixi";
	import { Carousel } from "@gdk/gamekit/game/carousel";
	import type { ICarouselSettings } from "@gdk/gamekit/game/carousel";
	import type { AbstractGame } from "@gdk/gamekit/game/abstractGame";
	export interface ICrossSellOptions {
	    upAnimation?: string;
	    outAnimation?: string;
	    overAnimation?: string;
	    downAnimation?: string;
	    enterAnimation?: string;
	    idleLoopAnimation?: string;
	    enterBackAnimation?: string;
	    frontToBackAnimation?: string;
	    backToFrontAnimation?: string;
	    idleLoopBackAnimation?: string;
	    mainCardName?: string;
	    defaultSpineTimelineButtonId?: string;
	}
	export interface ICrossSellCarouselOptions {
	    nextArrow?: Button;
	    previousArrow?: Button;
	    settings?: ICarouselSettings;
	}
	export class CrossSell extends Container {
	    private game;
	    /**
	     * List of all visible cards
	     */
	    cards: SpineTimeline[];
	    /**
	     * The main card, corresponding to the current game
	     */
	    mainCard: SpineTimeline;
	    /**
	     * The carousel
	     */
	    carousel: Carousel;
	    /**
	     * The play button from the active container (used for carousel)
	     */
	    protected playButton: Container;
	    /**
	     * The tweenMax used for the IdleWave animation
	     */
	    tweenIdleWave: TweenMax;
	    /**
	     * Options applied to the cross sell instance
	     */
	    options: ICrossSellOptions;
	    /**
	     * Force animation to be stopped
	     */
	    private _animationStopped;
	    /**
	     * Disable the carousel interactivity
	     */
	    private _carouselDisabled;
	    /**
	     * @constructor
	     * @param game - The reference to the game
	     */
	    constructor(game: AbstractGame, options?: ICrossSellOptions);
	    /**
	     * On Loaded
	     */
	    onLoaded(): void;
	    /**
	     * Create a card in the card container
	     * @param options - Options to pass to the card container
	     */
	    createCard(option: ICrossSell): SpineTimelineButton;
	    /**
	     * Initialize the carousel
	     * @param options - Options of the carousel
	     */
	    initializeCarousel(options?: ICrossSellCarouselOptions): void;
	    /**
	     * Appear the cross sell
	     */
	    appear(): Promise<void>;
	    /**
	     * Disappear animation of the cross sell
	     */
	    disappear(): void;
	    /**
	     * Disable carousel interactivity
	     */
	    disableCarousel(): void;
	    /**
	     * Enable the carousel
	     */
	    enableCarousel(): void;
	    /**
	     * Stop the IdleWave animation of the main card
	     */
	    stopIdleWaveAnimation(): void;
	    /**
	     * Create a timer to restart the idle wave animation
	     */
	    startTimeoutIdleWave(): void;
	    /**
	     * Create a wave animation base on the "idleLoop" animation of all cards
	     */
	    playIdleWaveAnimation: () => Promise<void>;
	    /**
	     * Returns true if the carousel should be disabled
	     */
	    isCarouselDisabled(): boolean;
	}
}

declare module "@gdk/gamekit/game/carousel" {
	import { EOrientation } from "@gdk/core";
	import { Point, utils } from "pixi.js";
	import type { Container, interaction } from "pixi.js";
	import type { Button } from "@gdk/core-pixi";
	import type { AbstractGame } from "@gdk/gamekit/game/abstractGame";
	export interface ICarouselData {
	    /**
	     * The game
	     */
	    game: AbstractGame;
	    /**
	     * The parent container of the carousel
	     */
	    container: Container;
	    /**
	     * The previous arrow button
	     */
	    previousArrow?: Button;
	    /**
	     * The next arrow button
	     */
	    nextArrow?: Button;
	}
	export interface ICarouselSettings {
	    /**
	     * Duration of animation
	     */
	    animationDuration?: number;
	    /**
	     * The offset between cards in px
	     */
	    offset?: number;
	    /**
	     * The orientation of the carousel
	     */
	    orientation?: EOrientation;
	    /**
	     * The list of scales for cards
	     */
	    scales?: number[];
	    /**
	     * The fixed docking position for all cards (x axis for Orientation Landscape and y axis for Portrait orientation)
	     */
	    fixedDocking?: Point[];
	    /**
	     * The fixed docking if there is only 2 cards
	     */
	    fixedDocking2Cards?: Point[];
	    /**
	     * The max time during drag event can be active
	     */
	    maxDragTime?: number;
	    /**
	     * The number of pixel required to be considered has a swipe
	     */
	    dragSensibility?: number;
	    /**
	     * If true, arrows won't be positionned automaticaly
	     */
	    useCustomArrowsPositions?: boolean;
	}
	export class Carousel extends utils.EventEmitter {
	    /**
	     * The game
	     */
	    protected game: AbstractGame;
	    /**
	     * The parent container
	     */
	    protected container: Container;
	    /**
	     * List of cards
	     */
	    protected cards: Container[];
	    /**
	     * Button for previous arrow
	     */
	    previousArrow: Button;
	    /**
	     * Button for next arrow
	     */
	    nextArrow: Button;
	    /**
	     * The active card
	     */
	    protected activeCard: Container;
	    /**
	     * The previous card
	     */
	    protected previousActiveCard: Container;
	    /**
	     * The settings of the carousel
	     */
	    protected settings: ICarouselSettings;
	    /**
	     * The timestamp of the drag start
	     */
	    protected dragStartTime: number;
	    /**
	     * The mouse position when the drag has started
	     */
	    protected dragStartPosition: Point;
	    /**
	     * Check if the player is currently dragging the carousel
	     */
	    isDragging: boolean;
	    /**
	     * card sequence of z-order where you cycle from center to right, then left to center without wrong depth
	     */
	    correspondingIndex: number[];
	    /**
	     * Check if the carousel is active
	     */
	    protected isActive: boolean;
	    /**
	     * @constructor
	     * @param cards: List of cards containers
	     * @param leftArrow: Button for Left Arrow
	     * @param rightArrow: Button for Right Arrow
	     */
	    constructor(data: ICarouselData, settings?: ICarouselSettings);
	    /**
	     * Get the maximum dimension depending of cards
	     */
	    protected getCardDimension(): Point;
	    /**
	     * Get the offset value between each cards relative to the container dimension
	     */
	    protected getCardsOffset(): number;
	    /**
	     * Sort cards with children to prevent card to nlap other
	     * @param reverseLastCard: True if you want that the right card will be the first drawed card
	     */
	    protected sortCards(reverseLastCard?: boolean): void;
	    /**
	     * Convert an array of indices to the full array for each cards (useful to sort cards by peer)
	     * @param array: The array to compute
	     * @param isNegative: If true, the left part of the array will be negative
	     * @returns The computed array
	     */
	    computeArray(ar: number[], isNegative?: boolean): number[];
	    /**
	     * Get all card positions based on fixed docking positions
	     * @returns
	     */
	    protected getCardPositions(): number[];
	    /**
	     * When scroll has been detected
	     * @param e: The window event
	     */
	    protected onScroll(e: Event): void;
	    /**
	     * @event
	     * When the drag has started
	     * @param e: The interaction event
	     * @returns
	     */
	    protected onDragStart(e: interaction.InteractionEvent): void;
	    /**
	     * @event
	     * When drag has stopped
	     * @param e: The interaction event
	     * @returns
	     */
	    protected onDragStop(e: interaction.InteractionEvent): void;
	    /**
	     * Update positions of arrows relative to the screen and orientation
	     */
	    protected updateArrowsPositions(): void;
	    /**
	     * Set a new card as active
	     * @param nextCard: The next card to active
	     * @param disableAnimation: True if animation should be disabled
	     */
	    setActiveCard(nextCard: Container, disableAnimation?: boolean): Promise<void>;
	    /**
	     * Update positions of cards
	     * @param disableAnimation: If true, cards will be updated without animation
	     * @param reverseRotation: True if the default rotation should be reversed for better animation
	     */
	    updateCardPositions(disableAnimation?: boolean, reverseRotation?: boolean): Promise<void>;
	    /**
	     * Active or deactive buttons Left/Right arrow
	     * @param active: True if buttons must be active
	     */
	    setButtonActive(active?: boolean): void;
	    /**
	     * Switch to previous card
	     * @param disableAnimation: True if the changement should be instant
	     */
	    previousCard(disableAnimation?: boolean): Promise<void>;
	    /**
	     * Switch to next card
	     * @param disableAnimation: True if the changement shoud be instant
	     */
	    nextCard(disableAnimation?: boolean): Promise<void>;
	    /**
	     * Kill the carousel and remove all events
	     */
	    kill(): void;
	    /**
	     * Sets wether or not the carousel is active.
	     * @param isActive defines wether or not the carousel is active.
	     */
	    setActive(isActive: boolean): boolean;
	    /**
	     * Know if arrows should be active, in relation with the number of cards present in carousel
	     */
	    isCarousel(): boolean;
	    /**
	     * Get the active card
	     * @returns
	     */
	    getActiveCard(): Container;
	    /**
	     * Get list of cards
	     * @returns
	     */
	    getCards(): Container[];
	    /**
	     * Check if the carousel is in simple mode (without wheel)
	     * @returns True if the carousel is in simple mode
	     */
	    isSimpleMode(): boolean;
	}
}

declare module "@gdk/gamekit/game/wizz/index" {
	import type { TextField } from "@gdk/core-pixi";
	import type { Amount } from "@gdk/core";
	import type { Container, Texture } from "pixi.js";
	import type { Timer } from "@gdk/gamekit/game/ui/index";
	export interface IAvatar extends Container {
	    setTexture: (texture: Texture) => void;
	    setAsCurrentPlayer: () => void;
	    setStatus: (status: EAvatarStatus) => void;
	}
	export interface IAvatarSlot extends Container {
	    reset: () => void;
	    enterRoomAnim: () => void;
	    pseudo: TextField;
	    avatar: IAvatar;
	    playerId: string;
	}
	export interface ICoinPosition {
	    x: number;
	    y: number;
	    startTime: number;
	    rotation: number;
	}
	export enum EAvatarStatus {
	    quit = 0,
	    pending = 1,
	    ready = 2,
	    none = 3
	}
	export interface IBottomBanner extends Container {
	    contextText: TextField;
	    timer: Timer;
	    content: Container;
	}
	export interface IWaitingRoom extends Container {
	    timer: Timer;
	    maxPlayers: number;
	}
	export interface IPurse extends Container {
	    setPurse: (value: Amount) => void;
	}
	export interface IPurses {
	    gift: IPurse;
	    token: IPurse;
	    gameWin: IPurse;
	    standard: IPurse;
	}
}

declare module "@gdk/gamekit/game/inactivity" {
	import { TweenMax } from "gsap";
	import type { AbstractGame } from "@gdk/gamekit/game/abstractGame";
	export interface IInactivityOptions {
	    /**
	     * If true, the timer will restart after each call of "onInactivity" event
	     */
	    loop?: boolean;
	    /**
	     * Delay of the timer before calling "onInactivity" event
	     */
	    delay?: number;
	    /**
	     * If true, the timer will be launched after instantiate
	     */
	    autoStart?: boolean;
	    /**
	     * Set a delay before each loop. If this attribute is not assigned, the delay between loops will be the default delay
	     */
	    loopDelay?: number;
	}
	export class Inactivity {
	    /**
	     * Set to true to call event every delay exceed
	     */
	    protected loop: boolean;
	    /**
	     * The function called when delay has been exceeded
	     */
	    protected onInactivity: () => Promise<void> | void;
	    /**
	     * The function called when inactivity has been resetted
	     */
	    protected onEndInactivity: () => Promise<void> | void;
	    /**
	     * The timeout TweenMax to call the event with delay
	     */
	    protected timeOut: TweenMax;
	    /**
	     * Check if the click is maintained
	     */
	    protected isClickMaintained: boolean;
	    /**
	     * Check if settings is opened
	     */
	    protected isSettingsOpened: boolean;
	    /**
	     * Check if rules are opened
	     */
	    protected isRulesOpened: boolean;
	    /**
	     * The current game
	     */
	    protected game: AbstractGame;
	    /**
	     * Check if it has been subscribed to event listener of the document
	     */
	    protected subscribed: boolean;
	    /**
	     * Check if inactivity event has been called
	     */
	    protected inactive: boolean;
	    /**
	     * Options of the inactivity
	     */
	    protected options: IInactivityOptions;
	    /**
	     * @constructor
	     */
	    constructor(game: AbstractGame, onInactivity: () => Promise<void> | void, onEndInactivity: () => Promise<void> | void, options?: IInactivityOptions);
	    /**
	     * Stop the TweenMax timeout
	     */
	    protected stopTimeOut(): void;
	    /**
	     * Start the TweenMax timeout
	     */
	    protected startTimeOut(customDelay?: number): void;
	    /**
	     * Event called to start the inactivity event
	     */
	    protected onDelayExceeded: () => Promise<void>;
	    /**
	     * Event trigger when click is maintained
	     */
	    protected onClickMaintained: () => Promise<void>;
	    /**
	     * Event trigger when click is ended
	     */
	    protected onClickEnd: () => Promise<void>;
	    /**
	     * Event trigger when pointer is moving
	     */
	    protected onPointerMove: () => Promise<void>;
	    /**
	     * Event trigger when settings are shown
	     */
	    protected onShowSettings: () => Promise<void>;
	    /**
	     * Event trigger when rules are shown
	     */
	    protected onShowRules: () => Promise<void>;
	    /**
	     * Event trigger when settings are hide
	     */
	    protected onHideSettings: () => Promise<void>;
	    /**
	     * Event trigger when settings are hide
	     */
	    protected onHideRules: () => Promise<void>;
	    /**
	     * Event trigger when game is paused / unpaused
	     */
	    protected onGamePaused: (paused: boolean) => Promise<void>;
	    /**
	     * Subscribe to all document events
	     */
	    protected subscribe(): void;
	    /**
	     * Unsubscribe from all document events
	     */
	    protected unsubscribe(): void;
	    /**
	     * Change the delay before calling the inactivity event
	     * @param delay: The delay to change
	     */
	    setDelay(delay: number): void;
	    /**
	     * Start/Restart the timer
	     */
	    start: () => Promise<void>;
	    pause: () => Promise<void>;
	    /**
	     * Stop the current timer
	     */
	    stop: () => Promise<void>;
	    /**
	     * True if inactivity event has been called
	     */
	    isInactive(): boolean;
	}
}

declare module "@gdk/gamekit/com/messageManager/index" {
	export { EMessageType, IMessage } from "@gdk/gamekit/com/messageManager/definitions";
	export { MessageManager } from "@gdk/gamekit/com/messageManager/messageManager";
}

declare module "@gdk/gamekit/com/messageManager/definitions" {
	import type { IPopinDefinition } from "@gdk/gamekit/com/popin/index";
	/**
	 * When to display the message.
	 */
	export enum EMessageType {
	    /**
	     * Immediatly after the call of the message manager.
	     */
	    Immediate = "immediate",
	    /**
	     * At the end of a game.
	     */
	    End = "end"
	}
	/**
	 * Definition of an inGame message.
	 */
	export interface IMessage {
	    /**
	     * Error code.
	     */
	    code: string;
	    /**
	     * When to display the message.
	     */
	    type?: EMessageType;
	    /**
	     * Popin definition.
	     */
	    popup?: IPopinDefinition;
	    /**
	     * Context in case of an IF error
	     */
	    context?: {
	        code: string;
	        message: string;
	    };
	}
}

declare module "@gdk/gamekit/com/popin/index" {
	export { Popin } from "@gdk/gamekit/com/popin/popin";
	export { EPopinLevel, IPopinDefinition, PopinButtonAction, IPopinButton, IPopinLink, IPopinActions, PopinLinkTarget, } from "@gdk/gamekit/com/popin/definitions";
}

declare module "@gdk/gamekit/com/popin/popin" {
	import type { IPopinDefinition, IPopinActions } from "@gdk/gamekit/com/popin/definitions";
	/**
	 * InGame HTML Popin
	 */
	export class Popin {
	    protected static instances: Popin[];
	    protected static _defaultOrientation: undefined | "portrait" | "landscape";
	    static wrapper: HTMLElement;
	    /**
	     * Define popin orientation. If not set, popin will follow natural page orientation.
	     * If specified, and if it does not match page orientation, popups will be rotated
	     * to fit with the new orientation.
	     * This is useful when game orientation differs from device orientation.
	     */
	    static set defaultOrientation(orientation: "portrait" | "landscape");
	    /**
	     * Instantiate and display a popin
	     * @param definition popin definition
	     * @param actions callback actions
	     */
	    static display(definition: IPopinDefinition, actions: IPopinActions): Promise<void>;
	    private _definition;
	    private _actions;
	    private _domElement;
	    private _notifyClosed;
	    constructor(definition: IPopinDefinition, actions: IPopinActions);
	    dispose(): void;
	    /**
	     * Change popin orientation, rotate it if orientation is not the same as device
	     * orientation (rotation is applied through css tranform, thanks to classes "portrait"
	     * and "landscape").
	     */
	    set orientation(orientation: "portrait" | "landscape");
	    /**
	     * Display the popin
	     */
	    display(): Promise<void>;
	    /**
	     * Close the popin
	     */
	    close(): Promise<void>;
	    private _configure;
	    private _getButtons;
	    private _getButton;
	    private _getButtonAction;
	    private _getCloseCross;
	    private _getCloseLayer;
	}
}

declare module "@gdk/gamekit/com/popin/definitions" {
	import type { Popin } from "@gdk/gamekit/com/popin/popin";
	/**
	 * Log level
	 */
	export enum EPopinLevel {
	    Info = "info",
	    Warning = "warning",
	    Error = "error"
	}
	/**
	 * Interface defining popin options & content
	 */
	export interface IPopinDefinition {
	    /**
	     * Log level.
	     */
	    level: EPopinLevel;
	    /**
	     * Title of the popin.
	     */
	    title?: string;
	    /**
	     * Content of the popin.
	     */
	    content?: string;
	    /**
	     * Alias for content.
	     */
	    text?: string;
	    /**
	     * Display a close button in the top right of the popin.
	     */
	    closable?: boolean;
	    /**
	     * Give possibility fo close the popin by clicking on the background overlay.
	     */
	    clickOutsideToClose?: boolean;
	    /**
	     * List of buttons for the popin.
	     */
	    buttons?: IPopinButton[];
	    /**
	     * For overriding the popin CSS.
	     */
	    style?: {
	        [key: string]: string | number;
	    };
	    /**
	     * For overriding the title CSS.
	     */
	    titleStyle?: {
	        [key: string]: string | number;
	    };
	    /**
	     * For overriding the text CSS.
	     */
	    textStyle?: {
	        [key: string]: string | number;
	    };
	}
	/**
	 * List of actions available for a popin button.
	 */
	export enum PopinButtonAction {
	    /**
	     * Open a link.
	     */
	    Link = "link",
	    /**
	     * Close the popin.
	     */
	    ClosePopin = "closePopup",
	    /**
	     * Close the game through the bridge.
	     */
	    CloseGame = "closeGame",
	    /**
	     * Refresh the game.
	     */
	    RefreshGame = "refreshGame",
	    /**
	     * Call a callback with the popin as argument.
	     */
	    Callback = "callback"
	}
	/**
	 * Set type of link.
	 */
	export enum PopinLinkTarget {
	    /**
	     * Open the link in an another page.
	     */
	    Blank = "blank",
	    /**
	     * Open the link in the current page.
	     */
	    Self = "self"
	}
	/**
	 * Definition of a link for a popin link button.
	 */
	export interface IPopinLink {
	    /**
	     * Target of the link.
	     */
	    url: string;
	    /**
	     * Type of link.
	     */
	    target: PopinLinkTarget;
	}
	/**
	 * Definition of a popin button.
	 */
	export interface IPopinButton {
	    /**
	     * Label of the button.
	     */
	    label: string;
	    /**
	     * Type of click action.
	     */
	    action: PopinButtonAction;
	    /**
	     * Optionnal link definition for a Link button.
	     */
	    link?: IPopinLink;
	    /**
	     * Optionnal callback for a Callback button.
	     * Provide the Popin as argument.
	     */
	    callback?: (self: Popin) => void;
	    /**
	     * For overriding the button CSS;
	     */
	    style?: {
	        [key: string]: string | number;
	    };
	}
	/**
	 * Actions available for a Popin.
	 */
	export interface IPopinActions {
	    /**
	     * Close the game through the bridge.
	     */
	    closeGame: () => void;
	    /**
	     * Refresh game
	     */
	    refreshGame: () => void;
	}
}

declare module "@gdk/gamekit/com/messageManager/messageManager" {
	import type { IMessage } from "@gdk/gamekit/com/messageManager/definitions";
	import type { Com } from "@gdk/gamekit/com/index";
	/**
	 * InGame message manager. Displays popins.
	 */
	export class MessageManager {
	    private _messages;
	    private _com;
	    private _messageDisplayStack;
	    constructor(com: Com);
	    /**
	     * Push one or multiples messages to be displayed immediatly or at the end of the game
	     * regarding the provided configuration
	     * @param message message.s to display
	     */
	    push(message: IMessage | IMessage[]): Promise<void>;
	    /**
	     * Remove all messages waiting to be displayed.
	     */
	    reset(): void;
	    /**
	     * Display all messages waiting for GameEnd event
	     */
	    onGameEnd(): Promise<void>;
	    /**
	     * Display a popin message
	     * We first ask the lottery frontsite to display the message
	     * without positive response we handle the popin ourself
	     * @param message message to display
	     */
	    display(message: IMessage): Promise<void>;
	    private _pushOne;
	}
}

declare module "@gdk/gamekit/loading/index" {
	import { ProjectLoader } from "@gdk/gamekit/loading/projectLoader";
	import { BehaviorCodeExtension, IBehaviorScript, IBehaviorScriptReference, IBehaviorCode } from "@gdk/gamekit/loading/extensions/behaviorCode";
	export { ProjectLoader, BehaviorCodeExtension, IBehaviorScript, IBehaviorScriptReference, IBehaviorCode, };
}

declare module "@gdk/gamekit/loading/projectLoader" {
	import type { GamePixi, IProject, IProjectContainer, IViewMap } from "@gdk/core-pixi";
	import type { Container } from "pixi.js";
	export class ProjectLoader {
	    /**
	     * Load the given project
	     * @param game the game reference, typically a GamePixi
	     * @param project the project's configuration
	     * @param baseUrl the base url of the loader
	     * @param viewMap the viewmap to map views with states
	     */
	    static load(game: GamePixi, project: IProject, baseUrl: string, viewMap?: IViewMap): void;
	    /**
	     * Function that customizes the given container according to its metadatas
	     * @param config the container's configuration
	     * @param container the currently customized container
	     * @param baseUrl the base url of the loader
	     * @param project the project JSON data (source data)
	     */
	    static customContainerCustomizer(game: GamePixi, config: IProjectContainer, container: Container, baseUrl: string, project: IProject): void;
	    /**
	     * Custom loader for loading custom containers like ui.TextField etc.
	     * @param config the container's configuration
	     * @param baseUrl the base url of the loader
	     * @param container the currently created container
	     * @param project the project JSON data (source data)
	     */
	    static customContainerLoader(config: IProjectContainer, baseUrl: string, container?: Container, project?: IProject): Container;
	}
}

declare module "@gdk/gamekit/loading/extensions/behaviorCode" {
	import type { Container } from "pixi.js";
	import type { IProject, GamePixi } from "@gdk/core-pixi";
	export interface IBehaviorScript {
	    /**
	     * The name of the script
	     */
	    name: string;
	    /**
	     * The id of the script (automatically set)
	     */
	    id: string;
	    /**
	     * Compiled code (javascript) from the TypeScript
	     */
	    compiledCode: string;
	    /**
	     * The TypeScript source code
	     */
	    baseCode: string;
	}
	export interface IBehaviorScriptReference {
	    /**
	     * The id of the script to reference
	     */
	    id: string;
	    /**
	     * Sets wether or not the attached script is active or not
	     */
	    active: boolean;
	}
	export interface IBehaviorCode {
	    /**
	     * The collection of distinct scripts available
	     */
	    scripts: IBehaviorScript[];
	}
	export class BehaviorCodeExtension {
	    /**
	     * The id of the behavior code extension
	     */
	    static id: string;
	    /**
	     * Applies the behavior code extension on the given container
	     * @param game the game reference containing the behavior scripts
	     * @param project the project JSON reference
	     * @param container the container having scripts attached
	     */
	    static apply(game: GamePixi, project: IProject, container: Container): void;
	}
}

declare module "@gdk/gamekit/ds/index" {
	import { ISoftDSVIButtonsOptions, IDSPopinsContainerOptions, EGameStates, DSPopinsContainer } from "@gdk/gamekit/ds/popinsContainer";
	import { IDSVIButtonsOptions } from "@gdk/gamekit/ds/viButtons";
	export { ISoftDSVIButtonsOptions, IDSPopinsContainerOptions, EGameStates, DSPopinsContainer, IDSVIButtonsOptions, };
}

declare module "@gdk/gamekit/ds/popinsContainer" {
	import { Container } from "pixi.js";
	import type { IItgTicket } from "@falcon/bridge";
	import { ETicketMode } from "@gdk/gamekit/game/index";
	import type { Express, Ticket } from "@gdk/gamekit/game/index";
	export type ITicket<T extends Ticket = Ticket> = new (ticket: IItgTicket, mode: ETicketMode, _game: Express) => T;
	export interface ISoftDSVIButtonsOptions {
	    onAuto: () => void;
	    onStop: () => void;
	}
	export interface IDSPopinsContainerOptions {
	    onStart: () => Promise<void>;
	    viButtonsCallbacks: ISoftDSVIButtonsOptions;
	    secondaryColor?: string;
	    titleColor?: string;
	    gainFontsizes?: {
	        main?: number;
	        left?: number;
	    };
	    gainMaxLines?: number;
	}
	export enum EGameStates {
	    First = 0,
	    AfterDemoLose = 1,
	    AfterDemoWin = 2,
	    AfterWin = 3,
	    AfterLose = 4,
	    AfterReplayWin = 5,
	    AfterReplayLose = 6
	}
	export class DSPopinsContainer<U extends Ticket = Ticket, T extends ITicket<U> = ITicket<U>> extends Container {
	    private ticketType;
	    static verticalOffset: number;
	    static verticalOffsetIOS: number;
	    state: EGameStates;
	    private _ticket;
	    private betPopin;
	    private demoEndPopin;
	    private betEndPopin;
	    private replayEndPopin;
	    private confirmPopin;
	    private rules;
	    private gainTable;
	    private replayPopin;
	    private resumePopin;
	    private game;
	    private onStart;
	    private onAuto;
	    private viButtons;
	    private rulesOpen;
	    private popinsOverlay;
	    private viOverlay;
	    private replayTicketResponse;
	    private _verticalOffset;
	    constructor(options: IDSPopinsContainerOptions, game: Express, ticketType: T);
	    get ticket(): U;
	    /**
	     * Handle the game start.
	     * It will show the rules if thisit's rulesequired optionsr ask for wich game type this play.
	     * It will also check for replay or resume if required.
	     *
	     * @access public
	     */
	    start(): Promise<void>;
	    /**
	     * This will hide all the viButtons and deactivate them
	     *
	     * @access public
	     */
	    hideButtons(): void;
	    /**
	     * It will handle the end of game. It shows the result popin
	     *
	     * @access public
	     */
	    end(): void;
	    /**
	     * Claim the ticket when the game is finished
	     *
	     * @access public
	     * @returns {Promise<void>} The claim promise
	     */
	    claim(): Promise<void>;
	    private replay;
	    private handleGameStart;
	    private startAndActivateButtons;
	    private onHideSettings;
	    private onShowSettings;
	    private showVIGains;
	    private showVIRules;
	    private toGame;
	    private cancelBet;
	    private resume;
	    private confirm;
	    private noMoreRules;
	    private get shouldHideRules();
	    private seeResult;
	    private seeDemoResult;
	    private onAdded;
	    private onVIClose;
	    private setViElements;
	    private setRules;
	    private setGainBoard;
	    private makeGainBoardSlides;
	    private setViAccessableElements;
	    private setConfirmPopin;
	    private setReplayPopin;
	    private setBetPopin;
	    private setReplayEndPopin;
	    private setDemoEndPopin;
	    private setBetEndPopin;
	    private setResumePopin;
	}
}

declare module "@gdk/gamekit/ds/viButtons" {
	import type { Express } from "@gdk/gamekit/game/index";
	export interface IDSVIButtonsOptions {
	    onAuto: () => void;
	    onStop: () => void;
	    onPlayAgain: () => void;
	    onTryAgain: () => void;
	}
	export class DSVIButtons {
	    private auto;
	    private stop;
	    private playAgain;
	    private tryAgain;
	    private onAuto;
	    private onStop;
	    private onPlayAgain;
	    private onTryAgain;
	    private buttons;
	    private game;
	    constructor(game: Express, callbacks: IDSVIButtonsOptions);
	    /**
	     * Activate the play again button
	     *
	     * @access public
	     */
	    activatePlayAgain(): void;
	    /**
	     * Activate the try again button
	     *
	     * @access public
	     */
	    activateTryAgain(): void;
	    /**
	     * Activate the auto button
	     *
	     * @access public
	     */
	    activateAuto(): void;
	    /**
	     * Activate the pause button
	     *
	     * @access public
	     */
	    activatePause(): void;
	    /**
	     * It will hide all the vi buttons.
	     *
	     * @access public
	     * @param {boolean} deactivateAll=false, if it must disable all buttons
	     */
	    hideButtons(deactivateAll?: boolean): void;
	    /**
	     * Show all the active buttons
	     *
	     * @access public
	     */
	    showActiveButtons(): void;
	    private activateButtons;
	    private deactivateButtons;
	}
}
