// Does it work ?
import * as fs from "fs-extra";
import * as path from "path";
import { exec } from "child_process";
import { logger } from "@gdk/backutils";
import { createReport, generateUsrSql } from "@gdk/croupier";
import type { ICroupier, ICroupierConfig } from "@gdk/backutils";

import {
	scriptDeliveryFileName,
	deliveryFolderName,
	EProjectType,
	DeliveryGenerator,
	EAssetType,
	EArchiveType,
	EEngines,
} from "../tools/deliveryGenerator";

export class CroupierPacker {
	public static deliveryName: string;
	public static deliveryDir: string = deliveryFolderName;

	/**
	 * Pack several croupier
	 * @param games List of game names
	 * @param test If set to true executes the npm run test commend in the project. (default: true)
	 * @param resourcesPath Optionnal parameter that allows to specify the folder where is located the resources. (default: resources)
	 * @param version Optional parameter that allows to specify the script version instead of taking the package.json version.
	 * @returns A promise with a boolean as value that defines wether or not the packing has succedeed.
	 */
	public static async packMany(
		games: string[],
		test: boolean = true,
		resourcesPath: string = "resources",
		version?: string
	): Promise<boolean> {
		for await (const name of games) {
			if (!(await CroupierPacker.packOne(name, test, resourcesPath, version))) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Pack one
	 * @param name
	 * @param test If set to true executes the npm run test commend in the project. (default: true)
	 * @param resourcesPath Optionnal parameter that allows to specify the folder where is located the resources. (default: resources)
	 * @param version Optional parameter that allows to specify the script version instead of taking the package.json version.
	 * @returns A promise with a boolean as value that defines wether or not the packing has succedeed.
	 */
	public static async packOne(
		name: string,
		test: boolean = true,
		resourcesPath: string = "resources",
		version?: string
	): Promise<boolean> {
		try {
			if (!fs.existsSync(this.deliveryDir)) {
				fs.mkdirSync(this.deliveryDir, 0o744);
			}

			const gamePackageJson = require(path.resolve("package.json"));
			const deliveryVersion = version ?? gamePackageJson.version;

			// creates tmpDir
			const tmpDir = fs.mkdtempSync(path.join(this.deliveryDir, "tmp"));

			// Copy specifications if any
			if (fs.pathExistsSync(path.join(resourcesPath, name, "specifications"))) {
				fs.copySync(
					path.join(resourcesPath, name, "specifications"),
					path.join(tmpDir, "specifications")
				);
			} else {
				logger.warn(`No specifications found for ${name}`);
			}

			// retrieve jsonCroupier File
			const croupier: ICroupier = fs.readJsonSync(path.join("out", name, "croupier.json"));

			await this._execAndSave(
				`${process.platform === "win32" ? "npm.cmd" : "npm"} run test -- ${name}`,
				path.join(tmpDir, "test-report.txt")
			);

			// set version
			croupier.productVersion = deliveryVersion;
			fs.mkdirSync(path.join(tmpDir, "json"));
			fs.writeJSONSync(path.join(tmpDir, "json", `croupier-${croupier.code}.json`), croupier);

			// create report
			const report = await createReport(croupier);
			await report.xlsx.writeFile(path.join(tmpDir, "report.xlsx"));

			// Generate USR sql file if possible
			try {
				const conf: ICroupierConfig = fs.readJsonSync(gamePackageJson.games[name]);
				if (conf.infos) {
					fs.writeFileSync(
						`${tmpDir}/${conf.infos.serviceName}_external_service.sql`,
						generateUsrSql(conf.infos)
					);
				} else {
					throw new Error();
				}
			} catch (e) {
				logger.warn(`No information found to generate USR sql file for ${croupier.code}`);
			}

			this.deliveryName = scriptDeliveryFileName(
				croupier.masterGameCode,
				croupier.code,
				deliveryVersion
			);

			const files = fs.readdirSync(tmpDir).map((each) => path.resolve(tmpDir, each));

			logger.verbose("Creating final archive...");

			const deliveryGenerator = new DeliveryGenerator(this.deliveryDir, {
				assetType: EAssetType.script,
				engine: EEngines.itg,
				assetName: name,
				archiveType: EArchiveType.tgz,
				version: deliveryVersion,
				baseDirectory: tmpDir,
				fileBaseName: this.deliveryName,
				overrideArchives: true,
				files,
			});

			const deliveryFile = await deliveryGenerator.generateDeliveryFile();
			logger.info(`Delivery file: ${deliveryFile}`);
			fs.removeSync(tmpDir);
			return true;
		} catch (e) {
			logger.error(e.message, e);
			return false;
		}
	}

	private static _execAndSave(cmd: string, fileName: string): Promise<void> {
		logger.info(`Executing command: ${cmd} and saving output to ${fileName}`);
		const fileStream = fs.createWriteStream(fileName);
		const child = exec(cmd);
		child.stdout.on("data", (data) => process.stdout.write(data));
		child.stdout.pipe(fileStream);
		return new Promise((pResolve, pReject) =>
			child.on("close", (code) => {
				if (code === 0) {
					pResolve();
				} else {
					pReject(`Process returned non-zero exit code: ${code}`);
				}
			})
		);
	}
}
