import * as path from "path";
import * as _ from "lodash";
import * as fs from "fs-extra";
import * as tar from "tar";
import { logger } from "@gdk/backutils";

/**
 * Available assets type
 */
export enum EAssetType {
	applet = "applet",
	script = "script",
}

/**
 * Available engines
 */
export enum EEngines {
	itg = "ITG",
	mtr = "MTR",
	gam = "GAM",
	prs = "PRS",
	mtp = "MTP",
}

/**
 * Available project types
 * used for delivery file names
 */
export enum EProjectType {
	applet = "applet",
	script = "script",
}

/**
 * Available archive type for delivery
 */
export enum EArchiveType {
	tar = "tar",
	tgz = "tgz",
	zip = "zip",
}

/**
 * List of files path.
 */
export type IFilesList = string[];

/**
 * Description of a module to deliver.
 */
export interface IDeliveryOptions {
	/**
	 *  Type of the delivery
	 */
	assetType?: EAssetType;
	/**
	 *  Engine
	 */
	engine?: EEngines;
	/**
	 * Optionnal name of the delivery (for theme & i18n): fr-FR, en-US, default...
	 */
	assetName?: string;
	/**
	 * Version of the delivery file
	 */
	version?: string;
	/**
	 * Archive type (tgz, tar, zip)
	 */
	archiveType?: EArchiveType;
	/**
	 * Auto generates manifest.json
	 */
	manifest?: boolean;
	/**
	 * Name of the delivery file to create (without extension)
	 */
	fileBaseName: string;
	/**
	 * Set if existing archive files should be overriten (will fail if false and archive already exists)
	 */
	overrideArchives: boolean;
	/**
	 * Base directory from where folder tree should start in archive file
	 */
	baseDirectory: string;
	/**
	 * List of files absolute paths to include in the delivery file
	 */
	files: string[];
	/**
	 * Custom data
	 */
	data?: object;
}

/**
 * Name of the folder which will contain the delivery files
 */
export const deliveryFolderName = "delivery";

/**
 * Name of the delivery file
 * @param name
 * @param type
 * @param version
 */
export function scriptDeliveryFileName(
	masterGameCode: string,
	code: string,
	version: string
): string {
	return `${masterGameCode}_${code}_script_${version}`;
}

export function appletDeliveryFilename(name: string, version: string): string {
	return `${name}_applet_${version}`;
}
export class DeliveryGenerator {
	/**
	 * Constructor
	 * @param _destinationDir destination directory full path
	 * @param _options delivery options
	 */
	public constructor(private _destinationDir: string, private _options: IDeliveryOptions) {
		this._options = _.merge(
			{},
			{
				archiveType: EArchiveType.tgz,
				manifest: true,
			},
			this._options
		);
	}

	/**
	 * Create the delivery archive for the asset
	 * @returns the created archive path
	 */
	public async generateDeliveryFile(): Promise<string> {
		const files = [
			...this._options.files.map((file) => path.relative(this._options.baseDirectory, file)),
		];

		if (this._options.manifest) {
			// generate manifest
			const manifestFile = path.resolve(this._options.baseDirectory, "manifest.json");
			fs.writeFileSync(manifestFile, this._getManifest(), { encoding: "utf8" });
			files.push(path.relative(this._options.baseDirectory, manifestFile));
		}

		const deliveryFile = this._getFullDestinationPath();
		if (fs.existsSync(deliveryFile)) {
			if (this._options.overrideArchives) {
				logger.debug(`file ${deliveryFile} already exists, removing it before packing`);
				fs.removeSync(deliveryFile);
			} else {
				throw new Error(
					`file ${deliveryFile} already exists, remove it or set override option to true`
				);
			}
		}

		// generate archive file
		switch (this._options.archiveType) {
			case EArchiveType.tgz:
			case EArchiveType.tar:
				await tar.c(
					{
						gzip: this._options.archiveType === EArchiveType.tgz ? true : false,
						file: deliveryFile,
						strict: true,
						cwd: this._options.baseDirectory,
						umask: 0o444,
					} as any,
					files
				);
				break;
			case EArchiveType.zip:
				throw new Error("zip archive type not supported yet");
			default:
				throw new Error(`${this._options.archiveType} archive type unknown`);
		}

		return deliveryFile;
	}

	/**
	 * Generates the delivery manifest.
	 * @returns the manifest as a json string
	 */
	private _getManifest(): string {
		const object = {
			type: this._options.assetType,
			engine: this._options.engine,
			name: this._options.assetName,
			filename: this._options.fileBaseName,
			version: this._options.version,
			files: this._options.files.map((file) =>
				path.relative(this._options.baseDirectory, file).replace(/\\/g, "/")
			),
			data: this._options.data,
		};
		return JSON.stringify(object);
	}

	/**
	 * @returns the filename for the deliveryFile
	 */
	private _getFullDestinationPath(): string {
		return path.resolve(
			this._destinationDir,
			`${this._options.fileBaseName}.${this._options.archiveType}`
		);
	}
}
