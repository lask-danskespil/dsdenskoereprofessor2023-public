import program from "commander";
import { readFileSync } from "fs";
import { join, resolve } from "path";
import { existsSync, readJSONSync } from "fs-extra";
import { logger, watchProcess } from "@gdk/backutils";

import { GamePacker } from "./game/packer";
import { ModelPacker } from "./model/modelPack";
import { PackageJson } from "./tools/packageJson.js";
import { MultipassScriptPacker } from "./mtp/packer.js";
import { CroupierPacker } from "./croupier/croupierPack.js";
import type { IPackageJsonGame, IPackageJsonModel } from "./game/interface.js";
import type { IPackageJson } from "./tools/packageJson.js";
import type { IModelOptions } from "./model/modelPack";

interface IOptions {
	gameDirectory: string;
	logLevel: string;
	override: boolean;
	noTest?: boolean;
	forceVersion?: string;
}

const packers: Array<{
	test: (pkg: PackageJson<IPackageJson>) => boolean;
	pack: (
		options: IOptions,
		pkg: PackageJson<IPackageJson>,
		componentsToPack?: string[]
	) => Promise<boolean>;
}> = [
	{
		test: (pkg: PackageJson<IPackageJson>) => pkg.content.keywords.includes("applet"),
		pack: packGame,
	},
	{
		test: (pkg: PackageJson<IPackageJson>) =>
			pkg.content.keywords.includes("script") && pkg.content.keywords.includes("itg"),
		pack: packCroupier,
	},
	{
		test: (pkg: PackageJson<IPackageJson>) =>
			pkg.content.keywords.includes("script") && pkg.content.keywords.includes("mtr"),
		pack: packModel,
	},
	{
		test: (pkg: PackageJson<IPackageJson>) =>
			pkg.content.keywords.includes("mtp") && pkg.content.keywords.includes("script"),
		pack: packMultipassScript,
	},
];

export function start(): void {
	new program.Command()
		.version(new PackageJson(resolve(__dirname, "..")).version)
		.usage("[components...] [options]")
		.arguments("[components...]") // either gameConf files or game name from game package.json
		.action(action)
		.option(
			"-d, --gameDirectory <value>",
			"Directory of the game to run, defaultly current directory.",
			process.cwd()
		)
		.option(
			"-l, --logLevel <level>",
			`Log level to use for logger`,
			/^(error|warn|info|http|verbose|debug|silly)$/,
			"info"
		)
		.option("-o, --override", "Overrides existing archive if necessary", false)
		.option("-n, --noTest", "Disable tests on pack (croupiers)", false)
		.option("--forceVersion <version>", "force package version (croupiers)")
		.parse(process.argv);
}

async function action(componentsToPack: string[], options: IOptions): Promise<void> {
	logger.level = options.logLevel;
	watchProcess();

	const pkg = new PackageJson(options.gameDirectory);
	const packer = packers.find((each) => each.test(pkg));
	if (!packer) {
		logger.error("Unable to recognize project type.");
		process.exit(1);
	} else {
		const success = await packer.pack(options, pkg, componentsToPack);
		if (!success) {
			process.exit(1);
		}
	}
}

function packGame(
	options: IOptions,
	pkg: PackageJson<IPackageJsonGame>,
	gamesToPack: string[]
): Promise<boolean> {
	if (!pkg.content.games) {
		throw new Error("no games found in package.json");
	}

	const games = pkg.content.games;
	if (!gamesToPack.length) {
		gamesToPack = Object.keys(games);
	}

	const configurations = gamesToPack.map((gameName) => games[gameName] || gameName);
	const missingConfigurations = configurations.filter(
		(configuration) => !existsSync(resolve(options.gameDirectory, configuration))
	);
	if (missingConfigurations.length) {
		logger.error(
			`Unable to find something to pack for entry(ies): ${missingConfigurations.join(", ")}`
		);
		return Promise.resolve(false);
	}

	return GamePacker.packManyGames(configurations, options.gameDirectory, options.override);
}

async function packCroupier(
	options: IOptions,
	pkg: PackageJson<IPackageJsonGame>,
	gamesToPack: string[]
): Promise<boolean> {
	if (!pkg.content.games) {
		throw new Error("no games found in package.json");
	}

	const games = pkg.content.games;
	if (!gamesToPack.length) {
		gamesToPack = Object.keys(games);
	}

	const configurations = gamesToPack.map((gameName) => games[gameName]);
	const missingConfigurations = configurations.filter(
		(configuration) => !existsSync(resolve(options.gameDirectory, configuration))
	);
	if (missingConfigurations.length) {
		logger.error(
			`Unable to find something to pack for entry(ies): ${missingConfigurations.join(", ")}`
		);
		return Promise.resolve(false);
	}

	return await CroupierPacker.packMany(
		gamesToPack,
		!options.noTest,
		"resources",
		options.forceVersion
	);
}

async function packModel(
	options: IOptions,
	pkg: PackageJson<IPackageJsonModel>,
	gamesToPack: string[]
): Promise<boolean> {
	if (!pkg.content.games) {
		throw new Error("no games found in package.json");
	}
	if (!pkg.content.masterGameCode) {
		throw new Error("no master game code found in package.json");
	}

	const games = pkg.content.games;
	if (!gamesToPack.length) {
		gamesToPack = Object.keys(games);
	}

	const configurations = gamesToPack.map((gameName) => games[gameName]);
	const missingConfigurations = configurations.filter(
		(configuration) => !existsSync(resolve(options.gameDirectory, configuration))
	);
	if (missingConfigurations.length) {
		logger.error(
			`Unable to find something to pack for entry(ies): ${missingConfigurations.join(", ")}`
		);
		return Promise.resolve(false);
	}

	return await ModelPacker.packMany(
		gamesToPack.map((gameName): IModelOptions => {
			const gameConfiguration: IModelOptions = {
				name: gameName,
				directory: games[gameName],
				masterGameCode: pkg.content.masterGameCode,
			};

			if (
				existsSync(
					resolve(options.gameDirectory, gameConfiguration.directory, "configuration.json")
				)
			) {
				const configuration: IModelOptions = readJSONSync(
					resolve(options.gameDirectory, gameConfiguration.directory, "configuration.json")
				);

				if (configuration.trigram && configuration.bic && configuration.bicVariant) {
					// this game is as fdj on and requires sql
					gameConfiguration.trigram = configuration.trigram;
					gameConfiguration.bic = configuration.bic;
					gameConfiguration.bicVariant = configuration.bicVariant;

					if (configuration.engine) {
						// this game is not on MTR maybe PRS engine so fdj sql need the correct one.
						gameConfiguration.engine = configuration.engine;
					}

					if (configuration.type) {
						// this game is not MOTORS (maybe PRESTO).
						gameConfiguration.type = configuration.type;
					}

					if (configuration.range) {
						// this game is not in the FDJ_WEB range (Presto or other custom range).
						gameConfiguration.range = configuration.range;
					}
				}

				if (configuration.gamif) {
					// this game is a gamif game and require the flag
					gameConfiguration.gamif = true;
				}

				if (configuration.masterGameCode) {
					gameConfiguration.masterGameCode = configuration.masterGameCode;
				}

				gameConfiguration.fdjBoxName = configuration.fdjBoxName ?? gameConfiguration.name;
			}

			return gameConfiguration;
		})
	);
}

function packMultipassScript(options: IOptions): Promise<boolean> {
	return MultipassScriptPacker.pack(options.gameDirectory);
}
