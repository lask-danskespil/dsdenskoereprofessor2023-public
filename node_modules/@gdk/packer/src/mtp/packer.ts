import {
	readJSONSync,
	ensureDirSync,
	mkdtempSync,
	readdirSync,
	writeJSONSync,
	copySync,
	removeSync,
	writeFileSync,
} from "fs-extra";
import { join, resolve } from "path";
import { JsonValidator, logger } from "@gdk/backutils";

import {
	deliveryFolderName,
	scriptDeliveryFileName,
	EProjectType,
} from "../tools/deliveryGenerator";
import { DeliveryGenerator, EArchiveType } from "../tools/deliveryGenerator.js";
import { PackageJson } from "../tools/packageJson.js";
import GAME_SCHEMA from "./schemas/gameValidator.json";
import MANIFEST_SCHEMA from "./schemas/manifestValidator.json";
import SCRIPT_METADATA_SCHEMA from "./schemas/scriptMetadataValidator.json";
import SETTINGS_SCHEMA from "./schemas/settingsValidator.json";
import VARIANT_SCHEMA from "./schemas/variantValidator.json";
import { TEMPLATE_SQL_USR } from "./templateSQL.js";
import type { IPackageJson } from "../tools/packageJson.js";

interface IScript {
	description: string;
}

interface IParameters {
	name: string;
	ref: string;
	description: string;
	gameExternalReference?: string;
	externalReference?: string;
}

interface IVariant {
	name: string;
	ref: string;
	description: string;
	parametersRef: string;
	bic: string;
	bicVariant: string;
	exsCode: string;
}

interface IPackageJsonMultipass extends IPackageJson {
	deliveries: {
		script?: IScript;
		parameters?: IParameters;
		variant?: IVariant;
		history?: any;
	};
}

interface IManifest {
	gameDefinitionFileName?: string;
	variantFileName?: string;
	certifiedSettingsFileName?: string;
	renderingScriptFileName?: string;
	scriptCodeFileName?: string;
	scriptMetaDataFileName?: string;
}

// TODO: update when we understand what is expected with namings (external references)
export class MultipassScriptPacker {
	/**
	 * Pack a multipass script.
	 * @param scriptDirectory directory of the script to pack.
	 * @returns a promise resolving with true in case of success, false otherwise.
	 */
	public static pack(scriptDirectory: string): Promise<boolean> {
		const packer = new MultipassScriptPacker(scriptDirectory);
		return packer._pack();
	}

	private _deliveryDir: string = deliveryFolderName;
	private _deliveryName: string;

	private _gameValidator: JsonValidator = new JsonValidator(GAME_SCHEMA);
	private _manifestValidator: JsonValidator = new JsonValidator(MANIFEST_SCHEMA);
	private _scriptMetadataValidator: JsonValidator = new JsonValidator(SCRIPT_METADATA_SCHEMA);
	private _settingsValidator: JsonValidator = new JsonValidator(SETTINGS_SCHEMA);
	private _variantValidator: JsonValidator = new JsonValidator(VARIANT_SCHEMA);

	private _scriptDirectory: string;
	private _tmpDirectory: string;
	private _tmpScriptDirectory: string;

	private _pkg: PackageJson<IPackageJsonMultipass>;
	private _manifest: IManifest = {};

	private constructor(scriptDirectory: string) {
		this._scriptDirectory = scriptDirectory;
		this._pkg = new PackageJson<IPackageJsonMultipass>(scriptDirectory);
	}

	private async _pack(): Promise<boolean> {
		logger.info("Packing multipass script.");

		this._deliveryName = scriptDeliveryFileName(
			this._pkg.fullName,
			this._pkg.content.deliveries.variant.ref,
			this._pkg.version
		);

		try {
			// missing definition in fs-extra types
			(ensureDirSync as (path: string, desiredMode: number) => void)(this._deliveryDir, 0o744);
			const prefix = join(this._deliveryDir, "tmp");
			this._tmpDirectory = mkdtempSync(prefix);
			this._tmpScriptDirectory = mkdtempSync(prefix);
		} catch (e) {
			logger.error(`Could not prepare delivery directories: ${e.message}`);
			return false;
		}

		try {
			this._handleGameDeclaration();
			this._handleScript();
			this._handleHistory();
			this._handleSettings();
			this._handleVariantParameters();
			this._validateManifest();
			this._doSomethingRelatedToFalcon();
			await this._createScriptArchive();
			const result = await this._createArchive();
			this._dispose();
			logger.info(`Pack successful. Delivery can be found at: ${result}`);
			return true;
		} catch (e) {
			logger.error(e.message, e);
			this._dispose();
			return false;
		}
	}

	private _handleGameDeclaration(): void {
		logger.verbose("Handling game declaration...");

		// load @TODO use dynamic path ?
		const declaration: any = readJSONSync(resolve(this._scriptDirectory, "dist/declaration.json"));

		// prepare
		declaration.name = this._pkg.fullName;
		declaration.externalReference = this._pkg.fullName;
		declaration.description = this._pkg.content.description;

		// validate
		this._gameValidator.assert(declaration);

		// declare
		this._manifest.gameDefinitionFileName = "game.json";

		// copy
		const outputPath = resolve(this._tmpScriptDirectory, this._manifest.gameDefinitionFileName);
		writeJSONSync(outputPath, declaration);
	}

	private _handleScript(): void {
		if (!this._pkg.content.deliveries.script) {
			return;
		}
		logger.verbose("Handling script metadata...");

		// prepare
		const scriptDefinition = {
			gameExternalReference: this._pkg.fullName,
			description:
				this._pkg.content.deliveries.script.description ||
				`script ${this._pkg.version} for ${this._pkg.fullName}`,
			version: this._pkg.version,
		};

		// validate
		this._scriptMetadataValidator.assert(scriptDefinition);

		// declare
		this._manifest.scriptCodeFileName = "script.js";
		this._manifest.scriptMetaDataFileName = "script.json";

		// copy
		const fromPath = resolve(this._scriptDirectory, `dist/script.min.js`);
		const toPath = resolve(this._tmpScriptDirectory, this._manifest.scriptCodeFileName);
		copySync(fromPath, toPath);
		const outputPath = resolve(this._tmpScriptDirectory, this._manifest.scriptMetaDataFileName);
		writeJSONSync(outputPath, scriptDefinition);
	}

	private _handleHistory(): void {
		if (!this._pkg.content.deliveries.history) {
			return;
		}

		logger.verbose("Handling history...");

		// declare
		this._manifest.renderingScriptFileName = "history.js";

		// copy
		const fromPath = resolve(this._scriptDirectory, "dist/history.min.js");
		const toPath = resolve(this._tmpScriptDirectory, this._manifest.renderingScriptFileName);
		copySync(fromPath, toPath);
	}

	private _handleSettings(): void {
		if (!this._pkg.content.deliveries.parameters) {
			return;
		}

		logger.verbose("Handling settings...");

		// load @TODO use dynamic path ?
		const parameters: IParameters = readJSONSync(
			resolve(this._scriptDirectory, "dist/parameters.json")
		);

		// prepare
		parameters.name = this._pkg.content.deliveries.parameters.name;
		parameters.gameExternalReference = this._pkg.fullName;
		parameters.externalReference = this._pkg.content.deliveries.parameters.ref;
		parameters.description = this._pkg.content.deliveries.parameters.description;

		// validate
		this._settingsValidator.assert(parameters);

		// declare
		this._manifest.certifiedSettingsFileName = "parameters.json";

		// write
		const outputPath = resolve(this._tmpScriptDirectory, "parameters.json");
		writeJSONSync(outputPath, parameters);
	}

	private _handleVariantParameters(): void {
		if (!this._pkg.content.deliveries.variant) {
			return;
		}

		logger.verbose("Handling variant parameters...");

		// load @TODO use dynamic path ?
		const variantParameters: any = readJSONSync(
			resolve(this._scriptDirectory, "dist/variant-parameters.json")
		);

		// prepare
		variantParameters.name = this._pkg.content.deliveries.variant.name;
		variantParameters.certifiedSettingsRef = this._pkg.content.deliveries.variant.parametersRef;
		variantParameters.externalReference = this._pkg.content.deliveries.variant.ref;
		variantParameters.description = this._pkg.content.deliveries.variant.description;
		variantParameters.betLevel = variantParameters.bets;
		delete variantParameters.bets;
		variantParameters.nbMinPlayer = variantParameters.minPlayers;
		delete variantParameters.minPlayers;
		if (variantParameters.maxPlayers) {
			variantParameters.nbMaxPlayer = variantParameters.maxPlayers;
			delete variantParameters.maxPlayers;
		}

		// validate
		this._variantValidator.assert(variantParameters);

		// declare
		this._manifest.variantFileName = "variant.json";

		// write
		const outputPath = resolve(this._tmpScriptDirectory, this._manifest.variantFileName);
		writeJSONSync(outputPath, variantParameters);
	}

	private _validateManifest(): void {
		logger.verbose("Handling manifest...");

		this._manifestValidator.assert(this._manifest);

		const outputPath = resolve(this._tmpScriptDirectory, "manifest.json");
		writeJSONSync(outputPath, this._manifest);
	}

	private _doSomethingRelatedToFalcon(): void {
		if (!this._pkg.content.deliveries.variant) {
			return;
		}

		logger.verbose("Doing some falcon related things...");

		// prepare
		const sqlFile = TEMPLATE_SQL_USR(
			this._pkg.content.description,
			this._pkg.content.deliveries.variant.bic,
			this._pkg.content.deliveries.variant.bicVariant,
			this._pkg.content.deliveries.variant.exsCode,
			this._pkg.content.deliveries.variant.ref
		);

		// write
		ensureDirSync(resolve(this._tmpDirectory, "falcon"));
		const outputPath = resolve(
			this._tmpDirectory,
			`falcon/${this._pkg.content.deliveries.variant.ref}.sql`
		);
		writeFileSync(outputPath, sqlFile, { encoding: "utf8" });
	}

	private _createScriptArchive(): Promise<string> {
		logger.verbose("Creating script archive...");
		const outputDirectory = resolve(this._tmpDirectory, "model");
		ensureDirSync(outputDirectory);

		const generator = new DeliveryGenerator(outputDirectory, {
			archiveType: EArchiveType.tgz,
			manifest: false,
			fileBaseName: "model",
			overrideArchives: true,
			baseDirectory: this._tmpScriptDirectory,
			files: readdirSync(this._tmpScriptDirectory).map((each) =>
				resolve(this._tmpScriptDirectory, each)
			),
		});
		return generator.generateDeliveryFile();
	}

	private _createArchive(): Promise<string> {
		logger.verbose("Creating final archive...");
		const generator = new DeliveryGenerator(this._deliveryDir, {
			archiveType: EArchiveType.tgz,
			manifest: false,
			fileBaseName: this._deliveryName,
			overrideArchives: true,
			baseDirectory: this._tmpDirectory,
			files: readdirSync(this._tmpDirectory).map((each) => resolve(this._tmpDirectory, each)),
		});
		return generator.generateDeliveryFile();
	}

	private _dispose(): void {
		logger.verbose("Disposing temporary directories...");
		removeSync(this._tmpScriptDirectory);
		removeSync(this._tmpDirectory);
	}
}
