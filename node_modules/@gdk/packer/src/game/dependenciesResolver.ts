import { parse, join } from "path";
import { readdirSync, pathExistsSync } from "fs-extra";
import { logger } from "@gdk/backutils";

/**
 * Build path of a dependency for production.
 * @param modPath node_modules path to the dependency file.
 * @param gameDirectory path of the game.
 * @returns the production path of the dependency.
 */
export function getDependencyPath(modPath: string, gameDirectory: string): string {
	const path = parse(modPath);
	let dir = join(gameDirectory, path.dir);
	let files = readdirSync(dir);
	while (files.filter((f) => f === "package.json").length !== 1) {
		dir = join(dir, "..");
		files = readdirSync(dir);
	}
	const { version } = require(join(dir, "package.json"));

	return getModuleProductionPath(modPath, version);
}

/**
 * Dispatch dependency to the correct path production handler.
 * @param modulePath node_modules path to the dependency.
 * @param version desired version of the dependency.
 * @returns the cleaned dependency path.
 */
export function getModuleProductionPath(modulePath: string, version: string): string {
	if (modulePath.match("systemjs")) {
		return getSystemJsProductionPath(modulePath, version);
	} else if (modulePath.match("gsap")) {
		return getGsapProductionPath(modulePath, version);
	} else if (modulePath.match("es6-promise")) {
		return getEs6PromiseJsProductionPath(modulePath, version);
	} else {
		return getDefaultModuleProductionPath(modulePath, version);
	}
}

/**
 * Check if .min of a dependency exists;
 * @param modulePath node_modules path to the dependency.
 * @param minifiedModulePath node_modules path to the minified dependency.
 * @returns min path if it exists, non min path otherwise.
 */
export function selectModule(modulePath: string, minifiedModulePath: string): string {
	if (pathExistsSync(minifiedModulePath)) {
		return minifiedModulePath;
	} else {
		logger.warn(`!! Found no minified version for ${modulePath}`);
		return modulePath;
	}
}

/**
 * Handle systemjs path for production.
 * @param modulePath node_modules path to the systemjs dependency.
 * @param version desired version of systemjs.
 * @returns the cleaned systemjs path.
 */
export function getSystemJsProductionPath(modulePath: string, version: string): string {
	// we use systemjs src fril because current systemjs production does not support metadata
	return modulePath
		.replace(/\\/g, "/")
		.replace("node_modules/", "")
		.replace("systemjs/", `systemjs/v${version}/`);
}

/**
 * Handle es6promise path for production.
 * @param modulePath node_modules path to the es6promise dependency.
 * @param version desired version of es6promise.
 * @returns the cleaned es6promise path.
 */
export function getEs6PromiseJsProductionPath(modulePath: string, version: string): string {
	return modulePath
		.replace(/\\/g, "/")
		.replace("node_modules/", "")
		.replace("es6-promise/", `es6-promise/v${version}/`);
}

/**
 * Handle gsap path for production.
 * @param modulePath node_modules path to the gsap dependency.
 * @param version desired version of gsap.
 * @returns the cleaned gsap path.
 */
export function getGsapProductionPath(modulePath: string, version: string): string {
	const minifiedModulePath = modulePath
		.replace(/\\/g, "/")
		.replace("gsap/", "gsap/src/minified/")
		.replace(/\.js$/, ".min.js");

	const productionPath = selectModule(modulePath, minifiedModulePath);

	return productionPath.replace("node_modules/", "").replace("gsap/", `gsap/v${version}/`);
}

/**
 * Handle gdk modules path for production.
 * @param modulePath node_modules path to the gdk dependency.
 * @param version desired version of gdk module.
 * @returns the cleaned gdk path.
 */
export function getDefaultModuleProductionPath(modulePath: string, version: string): string {
	const isGDK = modulePath.match("@gdk");
	const minifiedModulePath = modulePath.replace(/\.js$/, ".min.js");

	let productionPath = selectModule(modulePath, minifiedModulePath);

	productionPath = productionPath
		.replace(/\\/g, "/")
		.replace("node_modules/", "")
		.replace("@gdk", "gdk");

	const insertionPoint = isGDK ? 2 : 1;
	const paths = productionPath.split("/");

	paths.splice(insertionPoint, 0, `v${version}`);

	return paths.join("/");
}
