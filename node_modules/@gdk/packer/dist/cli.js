"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.start = void 0;
const commander_1 = __importDefault(require("commander"));
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
const backutils_1 = require("@gdk/backutils");
const packer_1 = require("./game/packer");
const modelPack_1 = require("./model/modelPack");
const packageJson_js_1 = require("./tools/packageJson.js");
const packer_js_1 = require("./mtp/packer.js");
const croupierPack_js_1 = require("./croupier/croupierPack.js");
const packers = [
    {
        test: (pkg) => pkg.content.keywords.includes("applet"),
        pack: packGame,
    },
    {
        test: (pkg) => pkg.content.keywords.includes("script") && pkg.content.keywords.includes("itg"),
        pack: packCroupier,
    },
    {
        test: (pkg) => pkg.content.keywords.includes("script") && pkg.content.keywords.includes("mtr"),
        pack: packModel,
    },
    {
        test: (pkg) => pkg.content.keywords.includes("mtp") && pkg.content.keywords.includes("script"),
        pack: packMultipassScript,
    },
];
function start() {
    new commander_1.default.Command()
        .version(new packageJson_js_1.PackageJson((0, path_1.resolve)(__dirname, "..")).version)
        .usage("[components...] [options]")
        .arguments("[components...]") // either gameConf files or game name from game package.json
        .action(action)
        .option("-d, --gameDirectory <value>", "Directory of the game to run, defaultly current directory.", process.cwd())
        .option("-l, --logLevel <level>", `Log level to use for logger`, /^(error|warn|info|http|verbose|debug|silly)$/, "info")
        .option("-o, --override", "Overrides existing archive if necessary", false)
        .option("-n, --noTest", "Disable tests on pack (croupiers)", false)
        .option("--forceVersion <version>", "force package version (croupiers)")
        .parse(process.argv);
}
exports.start = start;
async function action(componentsToPack, options) {
    backutils_1.logger.level = options.logLevel;
    (0, backutils_1.watchProcess)();
    const pkg = new packageJson_js_1.PackageJson(options.gameDirectory);
    const packer = packers.find((each) => each.test(pkg));
    if (!packer) {
        backutils_1.logger.error("Unable to recognize project type.");
        process.exit(1);
    }
    else {
        const success = await packer.pack(options, pkg, componentsToPack);
        if (!success) {
            process.exit(1);
        }
    }
}
function packGame(options, pkg, gamesToPack) {
    if (!pkg.content.games) {
        throw new Error("no games found in package.json");
    }
    const games = pkg.content.games;
    if (!gamesToPack.length) {
        gamesToPack = Object.keys(games);
    }
    const configurations = gamesToPack.map((gameName) => games[gameName] || gameName);
    const missingConfigurations = configurations.filter((configuration) => !(0, fs_extra_1.existsSync)((0, path_1.resolve)(options.gameDirectory, configuration)));
    if (missingConfigurations.length) {
        backutils_1.logger.error(`Unable to find something to pack for entry(ies): ${missingConfigurations.join(", ")}`);
        return Promise.resolve(false);
    }
    return packer_1.GamePacker.packManyGames(configurations, options.gameDirectory, options.override);
}
async function packCroupier(options, pkg, gamesToPack) {
    if (!pkg.content.games) {
        throw new Error("no games found in package.json");
    }
    const games = pkg.content.games;
    if (!gamesToPack.length) {
        gamesToPack = Object.keys(games);
    }
    const configurations = gamesToPack.map((gameName) => games[gameName]);
    const missingConfigurations = configurations.filter((configuration) => !(0, fs_extra_1.existsSync)((0, path_1.resolve)(options.gameDirectory, configuration)));
    if (missingConfigurations.length) {
        backutils_1.logger.error(`Unable to find something to pack for entry(ies): ${missingConfigurations.join(", ")}`);
        return Promise.resolve(false);
    }
    return await croupierPack_js_1.CroupierPacker.packMany(gamesToPack, !options.noTest, "resources", options.forceVersion);
}
async function packModel(options, pkg, gamesToPack) {
    if (!pkg.content.games) {
        throw new Error("no games found in package.json");
    }
    if (!pkg.content.masterGameCode) {
        throw new Error("no master game code found in package.json");
    }
    const games = pkg.content.games;
    if (!gamesToPack.length) {
        gamesToPack = Object.keys(games);
    }
    const configurations = gamesToPack.map((gameName) => games[gameName]);
    const missingConfigurations = configurations.filter((configuration) => !(0, fs_extra_1.existsSync)((0, path_1.resolve)(options.gameDirectory, configuration)));
    if (missingConfigurations.length) {
        backutils_1.logger.error(`Unable to find something to pack for entry(ies): ${missingConfigurations.join(", ")}`);
        return Promise.resolve(false);
    }
    return await modelPack_1.ModelPacker.packMany(gamesToPack.map((gameName) => {
        var _a;
        const gameConfiguration = {
            name: gameName,
            directory: games[gameName],
            masterGameCode: pkg.content.masterGameCode,
        };
        if ((0, fs_extra_1.existsSync)((0, path_1.resolve)(options.gameDirectory, gameConfiguration.directory, "configuration.json"))) {
            const configuration = (0, fs_extra_1.readJSONSync)((0, path_1.resolve)(options.gameDirectory, gameConfiguration.directory, "configuration.json"));
            if (configuration.trigram && configuration.bic && configuration.bicVariant) {
                // this game is as fdj on and requires sql
                gameConfiguration.trigram = configuration.trigram;
                gameConfiguration.bic = configuration.bic;
                gameConfiguration.bicVariant = configuration.bicVariant;
                if (configuration.engine) {
                    // this game is not on MTR maybe PRS engine so fdj sql need the correct one.
                    gameConfiguration.engine = configuration.engine;
                }
                if (configuration.type) {
                    // this game is not MOTORS (maybe PRESTO).
                    gameConfiguration.type = configuration.type;
                }
                if (configuration.range) {
                    // this game is not in the FDJ_WEB range (Presto or other custom range).
                    gameConfiguration.range = configuration.range;
                }
            }
            if (configuration.gamif) {
                // this game is a gamif game and require the flag
                gameConfiguration.gamif = true;
            }
            if (configuration.masterGameCode) {
                gameConfiguration.masterGameCode = configuration.masterGameCode;
            }
            gameConfiguration.fdjBoxName = (_a = configuration.fdjBoxName) !== null && _a !== void 0 ? _a : gameConfiguration.name;
        }
        return gameConfiguration;
    }));
}
function packMultipassScript(options) {
    return packer_js_1.MultipassScriptPacker.pack(options.gameDirectory);
}
//# sourceMappingURL=cli.js.map