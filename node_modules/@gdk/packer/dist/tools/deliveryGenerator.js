"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeliveryGenerator = exports.appletDeliveryFilename = exports.scriptDeliveryFileName = exports.deliveryFolderName = exports.EArchiveType = exports.EProjectType = exports.EEngines = exports.EAssetType = void 0;
const path = __importStar(require("path"));
const _ = __importStar(require("lodash"));
const fs = __importStar(require("fs-extra"));
const tar = __importStar(require("tar"));
const backutils_1 = require("@gdk/backutils");
/**
 * Available assets type
 */
var EAssetType;
(function (EAssetType) {
    EAssetType["applet"] = "applet";
    EAssetType["script"] = "script";
})(EAssetType = exports.EAssetType || (exports.EAssetType = {}));
/**
 * Available engines
 */
var EEngines;
(function (EEngines) {
    EEngines["itg"] = "ITG";
    EEngines["mtr"] = "MTR";
    EEngines["gam"] = "GAM";
    EEngines["prs"] = "PRS";
    EEngines["mtp"] = "MTP";
})(EEngines = exports.EEngines || (exports.EEngines = {}));
/**
 * Available project types
 * used for delivery file names
 */
var EProjectType;
(function (EProjectType) {
    EProjectType["applet"] = "applet";
    EProjectType["script"] = "script";
})(EProjectType = exports.EProjectType || (exports.EProjectType = {}));
/**
 * Available archive type for delivery
 */
var EArchiveType;
(function (EArchiveType) {
    EArchiveType["tar"] = "tar";
    EArchiveType["tgz"] = "tgz";
    EArchiveType["zip"] = "zip";
})(EArchiveType = exports.EArchiveType || (exports.EArchiveType = {}));
/**
 * Name of the folder which will contain the delivery files
 */
exports.deliveryFolderName = "delivery";
/**
 * Name of the delivery file
 * @param name
 * @param type
 * @param version
 */
function scriptDeliveryFileName(masterGameCode, code, version) {
    return `${masterGameCode}_${code}_script_${version}`;
}
exports.scriptDeliveryFileName = scriptDeliveryFileName;
function appletDeliveryFilename(name, version) {
    return `${name}_applet_${version}`;
}
exports.appletDeliveryFilename = appletDeliveryFilename;
class DeliveryGenerator {
    /**
     * Constructor
     * @param _destinationDir destination directory full path
     * @param _options delivery options
     */
    constructor(_destinationDir, _options) {
        this._destinationDir = _destinationDir;
        this._options = _options;
        this._options = _.merge({}, {
            archiveType: EArchiveType.tgz,
            manifest: true,
        }, this._options);
    }
    /**
     * Create the delivery archive for the asset
     * @returns the created archive path
     */
    async generateDeliveryFile() {
        const files = [
            ...this._options.files.map((file) => path.relative(this._options.baseDirectory, file)),
        ];
        if (this._options.manifest) {
            // generate manifest
            const manifestFile = path.resolve(this._options.baseDirectory, "manifest.json");
            fs.writeFileSync(manifestFile, this._getManifest(), { encoding: "utf8" });
            files.push(path.relative(this._options.baseDirectory, manifestFile));
        }
        const deliveryFile = this._getFullDestinationPath();
        if (fs.existsSync(deliveryFile)) {
            if (this._options.overrideArchives) {
                backutils_1.logger.debug(`file ${deliveryFile} already exists, removing it before packing`);
                fs.removeSync(deliveryFile);
            }
            else {
                throw new Error(`file ${deliveryFile} already exists, remove it or set override option to true`);
            }
        }
        // generate archive file
        switch (this._options.archiveType) {
            case EArchiveType.tgz:
            case EArchiveType.tar:
                await tar.c({
                    gzip: this._options.archiveType === EArchiveType.tgz ? true : false,
                    file: deliveryFile,
                    strict: true,
                    cwd: this._options.baseDirectory,
                    umask: 0o444,
                }, files);
                break;
            case EArchiveType.zip:
                throw new Error("zip archive type not supported yet");
            default:
                throw new Error(`${this._options.archiveType} archive type unknown`);
        }
        return deliveryFile;
    }
    /**
     * Generates the delivery manifest.
     * @returns the manifest as a json string
     */
    _getManifest() {
        const object = {
            type: this._options.assetType,
            engine: this._options.engine,
            name: this._options.assetName,
            filename: this._options.fileBaseName,
            version: this._options.version,
            files: this._options.files.map((file) => path.relative(this._options.baseDirectory, file).replace(/\\/g, "/")),
            data: this._options.data,
        };
        return JSON.stringify(object);
    }
    /**
     * @returns the filename for the deliveryFile
     */
    _getFullDestinationPath() {
        return path.resolve(this._destinationDir, `${this._options.fileBaseName}.${this._options.archiveType}`);
    }
}
exports.DeliveryGenerator = DeliveryGenerator;
//# sourceMappingURL=deliveryGenerator.js.map