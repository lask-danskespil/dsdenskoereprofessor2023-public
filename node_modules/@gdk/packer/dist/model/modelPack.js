"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModelPacker = void 0;
const fs = __importStar(require("fs-extra"));
const path = __importStar(require("path"));
const child_process_1 = require("child_process");
const backutils_1 = require("@gdk/backutils");
const deliveryGenerator_1 = require("../tools/deliveryGenerator");
const packageJson_js_1 = require("../tools/packageJson.js");
class ModelPacker {
    /**
     * Pack several model
     * @param games
     */
    static async packMany(games) {
        var _a, e_1, _b, _c;
        const npmCMD = process.platform === "win32" ? "npm.cmd" : "npm";
        await this._spawn(npmCMD, ["run", "generate", "--", "production"]);
        try {
            for (var _d = true, games_1 = __asyncValues(games), games_1_1; games_1_1 = await games_1.next(), _a = games_1_1.done, !_a;) {
                _c = games_1_1.value;
                _d = false;
                try {
                    const name = _c;
                    if (!ModelPacker.packOne(name)) {
                        return false;
                    }
                }
                finally {
                    _d = true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = games_1.return)) await _b.call(games_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return true;
    }
    /**
     * Pack one
     * @param options
     */
    static async packOne(options) {
        try {
            if (!fs.existsSync(this.deliveryDir)) {
                fs.mkdirSync(this.deliveryDir, 0o744);
            }
            const packageJson = new packageJson_js_1.PackageJson(".");
            const deliveryVersion = packageJson.version;
            // creates tmpDir
            const tmpDir = fs.mkdtempSync(path.join(this.deliveryDir, "tmp"));
            // Copy specifications if any
            const specDir = path.join(options.directory, "specifications");
            if (fs.existsSync(specDir)) {
                fs.copySync(specDir, path.join(tmpDir, "specifications"));
            }
            // Copy betList
            const betListFile = path.join("dist", options.directory, "betList.json");
            fs.copySync(betListFile, path.join(tmpDir, "betList.json"));
            // Copy model
            const modelFile = path.join("dist", options.directory, "model.xml");
            fs.copySync(modelFile, path.join(tmpDir, "model.xml"));
            // Calculate model hash
            const hash = (await Promise.resolve().then(() => __importStar(require("crypto"))))
                .createHash("sha1")
                .update(fs.readFileSync(modelFile))
                .digest("hex");
            if (this.includeSql && options.trigram && options.bic && options.bicVariant) {
                fs.writeFileSync(path.join(tmpDir, "usr_insert.sql"), ModelPacker.generateSql(options));
                fs.writeFileSync(path.join(tmpDir, "execute_request.json"), ModelPacker.generateSchema(options));
            }
            fs.writeFileSync(path.join(tmpDir, "game.conf.deprecated.json"), ModelPacker.generacteGameConfDeprecated(options));
            const files = fs.readdirSync(tmpDir).map((each) => path.resolve(tmpDir, each));
            backutils_1.logger.verbose("Creating final archive...");
            const deliveryGenerator = new deliveryGenerator_1.DeliveryGenerator(this.deliveryDir, {
                assetType: deliveryGenerator_1.EAssetType.script,
                engine: deliveryGenerator_1.EEngines.mtr,
                assetName: options.name,
                archiveType: deliveryGenerator_1.EArchiveType.tgz,
                version: deliveryVersion,
                baseDirectory: tmpDir,
                fileBaseName: (0, deliveryGenerator_1.scriptDeliveryFileName)(options.masterGameCode, options.name, deliveryVersion),
                overrideArchives: true,
                files,
                data: {
                    modelPath: "model.xml",
                    betListPath: "betList.json",
                    xsdVersion: "1.3",
                    hash,
                    gamif: options.gamif || false,
                    masterGameCode: options.masterGameCode,
                },
            });
            const deliveryFile = await deliveryGenerator.generateDeliveryFile();
            backutils_1.logger.info(`Delivery file: ${deliveryFile}`);
            fs.removeSync(tmpDir);
            return true;
        }
        catch (e) {
            backutils_1.logger.error(e.message, e);
            return false;
        }
    }
    static _spawn(cmd, args) {
        backutils_1.logger.info(`Executing command: ${cmd} ${args.join(" ")}`);
        const child = (0, child_process_1.spawn)(cmd, args);
        child.stdout.on("data", (data) => process.stdout.write(data));
        child.stderr.on("data", (data) => process.stderr.write(data));
        return new Promise((pResolve, pReject) => child.on("close", (code) => {
            if (code === 0) {
                pResolve();
            }
            else {
                pReject(`Process returned non-zero exit code: ${code}`);
            }
        }));
    }
    static generateSchema(options) {
        return `{
\t"$schema": "http://json-schema.org/draft-04/schema#",
\t"title": "${options.name} execute request",
\t"properties": {
\t\t"evn": {
\t\t\t"type": "string",
\t\t\t "minLength": 3,
\t\t\t "maxLength": 3
\t\t},
\t\t"sid": {
\t\t\t"type": "integer"
\t\t},
\t\t"prm": {
\t\t\t"type": "object"
\t\t}
\t},
\t"required": [
\t\t"evn",
\t\t"sid"
\t]
}
`;
    }
    static generacteGameConfDeprecated(options) {
        return `{
    "gameName": "${options.name}",
    "engineName": "MTR",
    "gameType": "MTR",
    "category": "MTRGAME",
    "provider": "FDJ",
    "service": {
        "name": "${options.name}"
    },
    "demo": false,
    "locale": {
        "available": [
            "fr-FR",
            "en-US"
        ],
        "default": "fr-FR",
        "current": "fr-FR",
        "currency": {
            "available": [
                "EUR"
            ],
            "current": "EUR",
            "default": "EUR"
        },
        "fileList": [
            {}
        ]
    },
    "logo": {},
    "currency": {
        "available": [
            "EUR"
        ],
        "current": "EUR",
        "default": "EUR"
    },
    "theme": {
        "available": [
            "default"
        ],
        "current": "default"
    }
}
`;
    }
    static generateSql(options) {
        return `UPDATE REF_USR_EXTERNAL_SERVICE SET
EXS_NAME = '${options.fdjBoxName.toLocaleLowerCase()}',
EXS_DESCRIPTION = '${options.fdjBoxName.toUpperCase()}',
EXS_TYPE = '${options.type || "Motors"}',
EXS_ACCOUNT_NUMBER = '${options.bic}',
EXS_VARIANT_CODE = '${options.bicVariant}',
EXS_CREATED = SYSDATE,
EXS_UPDATED = SYSDATE
WHERE ECO_CODE ='${options.engine || "MTR"}' AND EXS_CODE = '${options.trigram}';

INSERT INTO REF_USR_EXTERNAL_SERVICE (ECO_CODE, EXS_CODE, EXS_NAME, EXS_DESCRIPTION, EXS_TYPE, EXS_ACCOUNT_NUMBER, EXS_VARIANT_CODE, EXS_CREATED, EXS_UPDATED)
VALUES ('${options.engine || "MTR"}', '${options.trigram}', '${options.fdjBoxName.toLocaleLowerCase()}', '${options.fdjBoxName.toUpperCase()}', '${options.type || "Motors"}', '${options.bic}', '${options.bicVariant}', SYSDATE, SYSDATE);

INSERT INTO USR_SITE_OFFER (ECO_CODE, EXS_CODE, SIT_CODE, SIO_STATUS, SIO_CREATED, SIO_UPDATED)
VALUES ('${options.engine || "MTR"}', '${options.trigram}', '${options.range || "FDJ_WEB"}', 'C', SYSDATE, SYSDATE);

COMMIT;`;
    }
}
exports.ModelPacker = ModelPacker;
ModelPacker.includeSql = true;
ModelPacker.deliveryDir = deliveryGenerator_1.deliveryFolderName;
//# sourceMappingURL=modelPack.js.map