"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultipassScriptPacker = void 0;
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const backutils_1 = require("@gdk/backutils");
const deliveryGenerator_1 = require("../tools/deliveryGenerator");
const deliveryGenerator_js_1 = require("../tools/deliveryGenerator.js");
const packageJson_js_1 = require("../tools/packageJson.js");
const gameValidator_json_1 = __importDefault(require("./schemas/gameValidator.json"));
const manifestValidator_json_1 = __importDefault(require("./schemas/manifestValidator.json"));
const scriptMetadataValidator_json_1 = __importDefault(require("./schemas/scriptMetadataValidator.json"));
const settingsValidator_json_1 = __importDefault(require("./schemas/settingsValidator.json"));
const variantValidator_json_1 = __importDefault(require("./schemas/variantValidator.json"));
const templateSQL_js_1 = require("./templateSQL.js");
// TODO: update when we understand what is expected with namings (external references)
class MultipassScriptPacker {
    /**
     * Pack a multipass script.
     * @param scriptDirectory directory of the script to pack.
     * @returns a promise resolving with true in case of success, false otherwise.
     */
    static pack(scriptDirectory) {
        const packer = new MultipassScriptPacker(scriptDirectory);
        return packer._pack();
    }
    constructor(scriptDirectory) {
        this._deliveryDir = deliveryGenerator_1.deliveryFolderName;
        this._gameValidator = new backutils_1.JsonValidator(gameValidator_json_1.default);
        this._manifestValidator = new backutils_1.JsonValidator(manifestValidator_json_1.default);
        this._scriptMetadataValidator = new backutils_1.JsonValidator(scriptMetadataValidator_json_1.default);
        this._settingsValidator = new backutils_1.JsonValidator(settingsValidator_json_1.default);
        this._variantValidator = new backutils_1.JsonValidator(variantValidator_json_1.default);
        this._manifest = {};
        this._scriptDirectory = scriptDirectory;
        this._pkg = new packageJson_js_1.PackageJson(scriptDirectory);
    }
    async _pack() {
        backutils_1.logger.info("Packing multipass script.");
        this._deliveryName = (0, deliveryGenerator_1.scriptDeliveryFileName)(this._pkg.fullName, this._pkg.content.deliveries.variant.ref, this._pkg.version);
        try {
            // missing definition in fs-extra types
            fs_extra_1.ensureDirSync(this._deliveryDir, 0o744);
            const prefix = (0, path_1.join)(this._deliveryDir, "tmp");
            this._tmpDirectory = (0, fs_extra_1.mkdtempSync)(prefix);
            this._tmpScriptDirectory = (0, fs_extra_1.mkdtempSync)(prefix);
        }
        catch (e) {
            backutils_1.logger.error(`Could not prepare delivery directories: ${e.message}`);
            return false;
        }
        try {
            this._handleGameDeclaration();
            this._handleScript();
            this._handleHistory();
            this._handleSettings();
            this._handleVariantParameters();
            this._validateManifest();
            this._doSomethingRelatedToFalcon();
            await this._createScriptArchive();
            const result = await this._createArchive();
            this._dispose();
            backutils_1.logger.info(`Pack successful. Delivery can be found at: ${result}`);
            return true;
        }
        catch (e) {
            backutils_1.logger.error(e.message, e);
            this._dispose();
            return false;
        }
    }
    _handleGameDeclaration() {
        backutils_1.logger.verbose("Handling game declaration...");
        // load @TODO use dynamic path ?
        const declaration = (0, fs_extra_1.readJSONSync)((0, path_1.resolve)(this._scriptDirectory, "dist/declaration.json"));
        // prepare
        declaration.name = this._pkg.fullName;
        declaration.externalReference = this._pkg.fullName;
        declaration.description = this._pkg.content.description;
        // validate
        this._gameValidator.assert(declaration);
        // declare
        this._manifest.gameDefinitionFileName = "game.json";
        // copy
        const outputPath = (0, path_1.resolve)(this._tmpScriptDirectory, this._manifest.gameDefinitionFileName);
        (0, fs_extra_1.writeJSONSync)(outputPath, declaration);
    }
    _handleScript() {
        if (!this._pkg.content.deliveries.script) {
            return;
        }
        backutils_1.logger.verbose("Handling script metadata...");
        // prepare
        const scriptDefinition = {
            gameExternalReference: this._pkg.fullName,
            description: this._pkg.content.deliveries.script.description ||
                `script ${this._pkg.version} for ${this._pkg.fullName}`,
            version: this._pkg.version,
        };
        // validate
        this._scriptMetadataValidator.assert(scriptDefinition);
        // declare
        this._manifest.scriptCodeFileName = "script.js";
        this._manifest.scriptMetaDataFileName = "script.json";
        // copy
        const fromPath = (0, path_1.resolve)(this._scriptDirectory, `dist/script.min.js`);
        const toPath = (0, path_1.resolve)(this._tmpScriptDirectory, this._manifest.scriptCodeFileName);
        (0, fs_extra_1.copySync)(fromPath, toPath);
        const outputPath = (0, path_1.resolve)(this._tmpScriptDirectory, this._manifest.scriptMetaDataFileName);
        (0, fs_extra_1.writeJSONSync)(outputPath, scriptDefinition);
    }
    _handleHistory() {
        if (!this._pkg.content.deliveries.history) {
            return;
        }
        backutils_1.logger.verbose("Handling history...");
        // declare
        this._manifest.renderingScriptFileName = "history.js";
        // copy
        const fromPath = (0, path_1.resolve)(this._scriptDirectory, "dist/history.min.js");
        const toPath = (0, path_1.resolve)(this._tmpScriptDirectory, this._manifest.renderingScriptFileName);
        (0, fs_extra_1.copySync)(fromPath, toPath);
    }
    _handleSettings() {
        if (!this._pkg.content.deliveries.parameters) {
            return;
        }
        backutils_1.logger.verbose("Handling settings...");
        // load @TODO use dynamic path ?
        const parameters = (0, fs_extra_1.readJSONSync)((0, path_1.resolve)(this._scriptDirectory, "dist/parameters.json"));
        // prepare
        parameters.name = this._pkg.content.deliveries.parameters.name;
        parameters.gameExternalReference = this._pkg.fullName;
        parameters.externalReference = this._pkg.content.deliveries.parameters.ref;
        parameters.description = this._pkg.content.deliveries.parameters.description;
        // validate
        this._settingsValidator.assert(parameters);
        // declare
        this._manifest.certifiedSettingsFileName = "parameters.json";
        // write
        const outputPath = (0, path_1.resolve)(this._tmpScriptDirectory, "parameters.json");
        (0, fs_extra_1.writeJSONSync)(outputPath, parameters);
    }
    _handleVariantParameters() {
        if (!this._pkg.content.deliveries.variant) {
            return;
        }
        backutils_1.logger.verbose("Handling variant parameters...");
        // load @TODO use dynamic path ?
        const variantParameters = (0, fs_extra_1.readJSONSync)((0, path_1.resolve)(this._scriptDirectory, "dist/variant-parameters.json"));
        // prepare
        variantParameters.name = this._pkg.content.deliveries.variant.name;
        variantParameters.certifiedSettingsRef = this._pkg.content.deliveries.variant.parametersRef;
        variantParameters.externalReference = this._pkg.content.deliveries.variant.ref;
        variantParameters.description = this._pkg.content.deliveries.variant.description;
        variantParameters.betLevel = variantParameters.bets;
        delete variantParameters.bets;
        variantParameters.nbMinPlayer = variantParameters.minPlayers;
        delete variantParameters.minPlayers;
        if (variantParameters.maxPlayers) {
            variantParameters.nbMaxPlayer = variantParameters.maxPlayers;
            delete variantParameters.maxPlayers;
        }
        // validate
        this._variantValidator.assert(variantParameters);
        // declare
        this._manifest.variantFileName = "variant.json";
        // write
        const outputPath = (0, path_1.resolve)(this._tmpScriptDirectory, this._manifest.variantFileName);
        (0, fs_extra_1.writeJSONSync)(outputPath, variantParameters);
    }
    _validateManifest() {
        backutils_1.logger.verbose("Handling manifest...");
        this._manifestValidator.assert(this._manifest);
        const outputPath = (0, path_1.resolve)(this._tmpScriptDirectory, "manifest.json");
        (0, fs_extra_1.writeJSONSync)(outputPath, this._manifest);
    }
    _doSomethingRelatedToFalcon() {
        if (!this._pkg.content.deliveries.variant) {
            return;
        }
        backutils_1.logger.verbose("Doing some falcon related things...");
        // prepare
        const sqlFile = (0, templateSQL_js_1.TEMPLATE_SQL_USR)(this._pkg.content.description, this._pkg.content.deliveries.variant.bic, this._pkg.content.deliveries.variant.bicVariant, this._pkg.content.deliveries.variant.exsCode, this._pkg.content.deliveries.variant.ref);
        // write
        (0, fs_extra_1.ensureDirSync)((0, path_1.resolve)(this._tmpDirectory, "falcon"));
        const outputPath = (0, path_1.resolve)(this._tmpDirectory, `falcon/${this._pkg.content.deliveries.variant.ref}.sql`);
        (0, fs_extra_1.writeFileSync)(outputPath, sqlFile, { encoding: "utf8" });
    }
    _createScriptArchive() {
        backutils_1.logger.verbose("Creating script archive...");
        const outputDirectory = (0, path_1.resolve)(this._tmpDirectory, "model");
        (0, fs_extra_1.ensureDirSync)(outputDirectory);
        const generator = new deliveryGenerator_js_1.DeliveryGenerator(outputDirectory, {
            archiveType: deliveryGenerator_js_1.EArchiveType.tgz,
            manifest: false,
            fileBaseName: "model",
            overrideArchives: true,
            baseDirectory: this._tmpScriptDirectory,
            files: (0, fs_extra_1.readdirSync)(this._tmpScriptDirectory).map((each) => (0, path_1.resolve)(this._tmpScriptDirectory, each)),
        });
        return generator.generateDeliveryFile();
    }
    _createArchive() {
        backutils_1.logger.verbose("Creating final archive...");
        const generator = new deliveryGenerator_js_1.DeliveryGenerator(this._deliveryDir, {
            archiveType: deliveryGenerator_js_1.EArchiveType.tgz,
            manifest: false,
            fileBaseName: this._deliveryName,
            overrideArchives: true,
            baseDirectory: this._tmpDirectory,
            files: (0, fs_extra_1.readdirSync)(this._tmpDirectory).map((each) => (0, path_1.resolve)(this._tmpDirectory, each)),
        });
        return generator.generateDeliveryFile();
    }
    _dispose() {
        backutils_1.logger.verbose("Disposing temporary directories...");
        (0, fs_extra_1.removeSync)(this._tmpScriptDirectory);
        (0, fs_extra_1.removeSync)(this._tmpDirectory);
    }
}
exports.MultipassScriptPacker = MultipassScriptPacker;
//# sourceMappingURL=packer.js.map