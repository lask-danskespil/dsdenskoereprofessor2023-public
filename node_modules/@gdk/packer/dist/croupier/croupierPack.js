"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CroupierPacker = void 0;
// Does it work ?
const fs = __importStar(require("fs-extra"));
const path = __importStar(require("path"));
const child_process_1 = require("child_process");
const backutils_1 = require("@gdk/backutils");
const croupier_1 = require("@gdk/croupier");
const deliveryGenerator_1 = require("../tools/deliveryGenerator");
class CroupierPacker {
    /**
     * Pack several croupier
     * @param games List of game names
     * @param test If set to true executes the npm run test commend in the project. (default: true)
     * @param resourcesPath Optionnal parameter that allows to specify the folder where is located the resources. (default: resources)
     * @param version Optional parameter that allows to specify the script version instead of taking the package.json version.
     * @returns A promise with a boolean as value that defines wether or not the packing has succedeed.
     */
    static async packMany(games, test = true, resourcesPath = "resources", version) {
        var _a, e_1, _b, _c;
        try {
            for (var _d = true, games_1 = __asyncValues(games), games_1_1; games_1_1 = await games_1.next(), _a = games_1_1.done, !_a;) {
                _c = games_1_1.value;
                _d = false;
                try {
                    const name = _c;
                    if (!(await CroupierPacker.packOne(name, test, resourcesPath, version))) {
                        return false;
                    }
                }
                finally {
                    _d = true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = games_1.return)) await _b.call(games_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return true;
    }
    /**
     * Pack one
     * @param name
     * @param test If set to true executes the npm run test commend in the project. (default: true)
     * @param resourcesPath Optionnal parameter that allows to specify the folder where is located the resources. (default: resources)
     * @param version Optional parameter that allows to specify the script version instead of taking the package.json version.
     * @returns A promise with a boolean as value that defines wether or not the packing has succedeed.
     */
    static async packOne(name, test = true, resourcesPath = "resources", version) {
        try {
            if (!fs.existsSync(this.deliveryDir)) {
                fs.mkdirSync(this.deliveryDir, 0o744);
            }
            const gamePackageJson = require(path.resolve("package.json"));
            const deliveryVersion = version !== null && version !== void 0 ? version : gamePackageJson.version;
            // creates tmpDir
            const tmpDir = fs.mkdtempSync(path.join(this.deliveryDir, "tmp"));
            // Copy specifications if any
            if (fs.pathExistsSync(path.join(resourcesPath, name, "specifications"))) {
                fs.copySync(path.join(resourcesPath, name, "specifications"), path.join(tmpDir, "specifications"));
            }
            else {
                backutils_1.logger.warn(`No specifications found for ${name}`);
            }
            // retrieve jsonCroupier File
            const croupier = fs.readJsonSync(path.join("out", name, "croupier.json"));
            await this._execAndSave(`${process.platform === "win32" ? "npm.cmd" : "npm"} run test -- ${name}`, path.join(tmpDir, "test-report.txt"));
            // set version
            croupier.productVersion = deliveryVersion;
            fs.mkdirSync(path.join(tmpDir, "json"));
            fs.writeJSONSync(path.join(tmpDir, "json", `croupier-${croupier.code}.json`), croupier);
            // create report
            const report = await (0, croupier_1.createReport)(croupier);
            await report.xlsx.writeFile(path.join(tmpDir, "report.xlsx"));
            // Generate USR sql file if possible
            try {
                const conf = fs.readJsonSync(gamePackageJson.games[name]);
                if (conf.infos) {
                    fs.writeFileSync(`${tmpDir}/${conf.infos.serviceName}_external_service.sql`, (0, croupier_1.generateUsrSql)(conf.infos));
                }
                else {
                    throw new Error();
                }
            }
            catch (e) {
                backutils_1.logger.warn(`No information found to generate USR sql file for ${croupier.code}`);
            }
            this.deliveryName = (0, deliveryGenerator_1.scriptDeliveryFileName)(croupier.masterGameCode, croupier.code, deliveryVersion);
            const files = fs.readdirSync(tmpDir).map((each) => path.resolve(tmpDir, each));
            backutils_1.logger.verbose("Creating final archive...");
            const deliveryGenerator = new deliveryGenerator_1.DeliveryGenerator(this.deliveryDir, {
                assetType: deliveryGenerator_1.EAssetType.script,
                engine: deliveryGenerator_1.EEngines.itg,
                assetName: name,
                archiveType: deliveryGenerator_1.EArchiveType.tgz,
                version: deliveryVersion,
                baseDirectory: tmpDir,
                fileBaseName: this.deliveryName,
                overrideArchives: true,
                files,
            });
            const deliveryFile = await deliveryGenerator.generateDeliveryFile();
            backutils_1.logger.info(`Delivery file: ${deliveryFile}`);
            fs.removeSync(tmpDir);
            return true;
        }
        catch (e) {
            backutils_1.logger.error(e.message, e);
            return false;
        }
    }
    static _execAndSave(cmd, fileName) {
        backutils_1.logger.info(`Executing command: ${cmd} and saving output to ${fileName}`);
        const fileStream = fs.createWriteStream(fileName);
        const child = (0, child_process_1.exec)(cmd);
        child.stdout.on("data", (data) => process.stdout.write(data));
        child.stdout.pipe(fileStream);
        return new Promise((pResolve, pReject) => child.on("close", (code) => {
            if (code === 0) {
                pResolve();
            }
            else {
                pReject(`Process returned non-zero exit code: ${code}`);
            }
        }));
    }
}
exports.CroupierPacker = CroupierPacker;
CroupierPacker.deliveryDir = deliveryGenerator_1.deliveryFolderName;
//# sourceMappingURL=croupierPack.js.map