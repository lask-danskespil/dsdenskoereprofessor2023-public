declare module "@gdk/core-pixi" {
	import "@gdk/core-pixi/augmentations/index";
	export { GamePixi, IGamePixiOptions } from "@gdk/core-pixi/gamePixi";
	export { Application } from "@gdk/core-pixi/application";
	export { PixiLoader } from "@gdk/core-pixi/loader";
	export { SVGGraphics, IDrawStyle } from "@gdk/core-pixi/svg/SVGGraphics";
	export { Docking, IDocking, DockingType } from "@gdk/core-pixi/container/docking";
	export { Anchor } from "@gdk/core-pixi/container/anchor";
	export { DockingBounds, IDockingBounds } from "@gdk/core-pixi/container/dockingBounds";
	export { Resize } from "@gdk/core-pixi/container/resize";
	export { ContainerUtils } from "@gdk/core-pixi/container/utils";
	export { ILayoutConfiguration, Layout } from "@gdk/core-pixi/container/layout";
	export { AccessibilityHelper } from "@gdk/core-pixi/accessibility/helper";
	export { ContainerView } from "@gdk/core-pixi/view/containerView";
	export { LoadedView } from "@gdk/core-pixi/view/loadedView";
	export { Clip, IClipOptions, IClipFramesOptions, IAnimatedSpriteTextureTimeObject, } from "@gdk/core-pixi/components/clip";
	export { CommonImporter } from "@gdk/core-pixi/loading/import/commonImporter";
	export { ContainerImporter, EContainerImporterMode } from "@gdk/core-pixi/loading/import/containerImporter";
	export { TextureImporter } from "@gdk/core-pixi/loading/import/textureImporter";
	export { StateImporter } from "@gdk/core-pixi/loading/import/stateImporter";
	export { ProjectImporter } from "@gdk/core-pixi/loading/import/projectImporter";
	export { CommonExporter } from "@gdk/core-pixi/loading/export/commonExporter";
	export { ContainerExporter } from "@gdk/core-pixi/loading/export/containerExporter";
	export { TextureExporter } from "@gdk/core-pixi/loading/export/textureExporter";
	export { StateExporter } from "@gdk/core-pixi/loading/export/stateExporter";
	export { ProjectExporter } from "@gdk/core-pixi/loading/export/projectExporter";
	export { IProject, IProjectTexture, IProjectContainer, IProjectSprite, IProjectView, IProjectRectangle, IViewConfig, ViewConstructor, IViewMap, IProjectPoint, IProjectAnimatedSprite, IProjectTilingSprite, IAsset, IAssetsRoot, ILocalizedAsset, } from "@gdk/core-pixi/loading/model";
	export { ProtonSerializer } from "@gdk/core-pixi/proton/serialization";
	export { ProtonContainer, EProtonContainerEvent } from "@gdk/core-pixi/proton/protonContainer";
	export { ISerializedEmitter, ISerializedEmitterComponent, ESerializedEmitterComponentType, } from "@gdk/core-pixi/proton/types";
	export * from "@gdk/core-pixi/assets/index";
	export * from "@gdk/core-pixi/decorators/index";
	export * from "@gdk/core-pixi/proton/parser/index";
	export * from "@gdk/core-pixi/proton/parser2/index";
	export * from "@gdk/core-pixi/spine/index";
	export * from "@gdk/core-pixi/spine2/index";
	export * from "@gdk/core-pixi/ui/index";
	export * from "@gdk/core-pixi/tools/index";
	export const VERSION: string;
}

declare module "@gdk/core-pixi/augmentations/index" {
	import "@gdk/core-pixi/augmentations/container";
	import "@gdk/core-pixi/augmentations/gsap";
}

declare module "@gdk/core-pixi/augmentations/container" {
	/// <reference types="pixi.js" />
	import type { Docking } from "@gdk/core-pixi/container/docking";
	import type { DockingBounds } from "@gdk/core-pixi/container/dockingBounds";
	import type { Resize } from "@gdk/core-pixi/container/resize";
	import type { Layout } from "@gdk/core-pixi/container/layout";
	module "pixi.js" {
	    interface ICustomMetadata {
	        /**
	         * If the container is a prefab, the property will be set to save
	         */
	        prefab?: {
	            /**
	             * The id of the prefab asset
	             */
	            assetId?: string;
	            /**
	             * The id of the container being modified using the prefab editor
	             */
	            id?: string;
	            /**
	             * Gets whether or not the object has been modified
	             */
	            properties?: {
	                [key: string]: boolean;
	            };
	        };
	        script?: {
	            /**
	             * Defines the name of the script.
	             */
	            name: string;
	            /**
	             * Defines the properties the user decided to customize.
	             */
	            properties: {
	                [propertyName: string]: any;
	            };
	        };
	        /**
	         * Any other key-value pair for containers
	         */
	        [key: string]: any;
	    }
	    interface Container {
	        docking: Docking;
	        dockingBounds: DockingBounds;
	        resize: Resize;
	        layouts: Layout;
	        scaleXY: number;
	        scaleX: number;
	        scaleY: number;
	        dockAsPoint: boolean;
	        slide: number;
	        debugBoundingBox: Graphics;
	        /**
	         * clone the current Container.
	         * @param noChildren default false, set to true to clone the container without his children.
	         * @returns the new cloned Container.
	         */
	        clone(noChildren?: boolean): Container;
	        /**
	         * Called once the container has been parsed using the ProjectImpoter.
	         */
	        onLoaded?(): void;
	        /**
	         * Update bounding box.
	         */
	        updateDebugBoundingBox(): void;
	    }
	    interface DisplayObject {
	        /**
	         * Set the name of the DisplayObject.
	         * @param name
	         */
	        setName(name: string): this;
	        /**
	         * Get the name of the DisplayObject.
	         * @returns the name.
	         */
	        getName(): string;
	        /**
	         * ID of the DisplayObject. (guid)
	         */
	        id: string;
	        /**
	         * Custom object that can be filled by the developer.
	         */
	        metadata: ICustomMetadata;
	        /**
	         * Export the DisplayObject through the ProjectExporter.
	         * @returns a json representation of the serialized DisplayObject.
	         */
	        export?(): any;
	        /**
	         * Using the ProjectExporter, sets whether or not the DisplayObject will be exported or ignored.
	         */
	        doNotExport: boolean;
	    }
	}
}

declare module "@gdk/core-pixi/container/docking" {
	import { Transform, Rectangle, Point } from "pixi.js";
	import type { Container } from "pixi.js";
	import { DataCache } from "@gdk/core-pixi/tools/dataCache";
	import type { IDockingBounds } from "@gdk/core-pixi/container/dockingBounds";
	/**
	 * Docking function type alias
	 */
	export type DockingType = (child: Container) => void;
	/**
	 * Interface that represents
	 */
	export interface IDocking {
	    /**
	     * X offset according to the current dock
	     */
	    x?: number;
	    /**
	     * Y offset according to the current dock
	     */
	    y?: number;
	    /**
	     * Docking type as lambda function
	     */
	    dock?: (child: Container) => void;
	    /**
	     * compensate pivot position for docking
	     */
	    cancelPivot?: boolean;
	}
	export class Docking implements IDocking {
	    /**
	     * The docking offset on axis (X, Y).
	     */
	    position: Point;
	    /**
	     * Docking type as lambda function
	     */
	    dock: DockingType;
	    /**
	     * Compensate pivot position for docking.
	     */
	    cancelPivot: boolean;
	    /**
	     * Used for cache, stores the latest known parent bounds.
	     * @hidden
	     */
	    _lastParentBounds: Rectangle;
	    /**
	     * Used for cache, stores the lastest bounds of the docked object.
	     * @hidden
	     */
	    _lastBounds: Rectangle;
	    /**
	     * Used for cache, stores the latest position of the docked object.
	     * @hidden
	     */
	    _lastPosition: Point;
	    /**
	     * Used for cache, store the latest docking function of the docked object.
	     * @hidden
	     */
	    _lastDock: DockingType;
	    /**
	     * Used for cache, stores the latest pivot of the docked object.
	     * @hidden
	     */
	    _lastPivot: Point;
	    /**
	     * Used for cache, stores the latest state for cancel pivot.
	     * @hidden
	     */
	    _lastCancelPivot: boolean;
	    /**
	     * Used for cache, to check cache.
	     * @hidden
	     */
	    _cache: DataCache<Docking>;
	    /**
	     * Constructor
	     * @param width fixed width of the container
	     * @param height fixed height of the container
	     * @param x x offset of the container
	     * @param y y offset of the container
	     * @param dock the docking function to apply
	     * @param usePivot (default 1) define if we shall use pivot while docking.
	     */
	    constructor(dock?: DockingType, x?: number, y?: number, cancelPivot?: boolean);
	    /**
	     * Gets X offset according to the current dock.
	     */
	    get x(): number;
	    /**
	     * Sets the X offset according to the current dock.
	     */
	    set x(value: number);
	    /**
	     * Gets the Y offset according to the current dock.
	     */
	    get y(): number;
	    /**
	     * Sets the Y offset according to the current dock.
	     */
	    set y(value: number);
	    /**
	     * Sets the docking position of the container according to the parent
	     * @param x the x offset.
	     * @param y the y offset.
	     * @deprecated please use .position.set instead.
	     */
	    setPosition(x: number, y: number): Docking;
	    /**
	     * Clones the current docking bounds object
	     */
	    clone(): Docking;
	    /**
	     * Sets the docking forced dirty. Especially used when implemented custom/animated docking.
	     */
	    setDirty(): void;
	    /**
	     * Returns wether or not the docking is dirty. If yes, the docking function should be applied.
	     * @param parentBounds the potental new parent bounds rectangle.
	     * @param bounds the current bounds of the docked object.
	     */
	    isDirty(child: Container, parentBounds: Rectangle, bounds: Rectangle): boolean;
	    /**
	     * Exports the docking configuration
	     */
	    export(): any;
	    /**
	     * Parses the given docking configuration
	     * @param config the exported configuration of the docking object
	     */
	    static parse(config: any, ref?: Docking): Docking;
	    static _transform: Transform;
	    static _parentTransform: Transform;
	    static _parentBounds: Rectangle;
	    static _bounds: IDockingBounds;
	    static _pivotInfluenceRatio: number;
	    static _transformedPivot: Point;
	    /**
	     * Docks the element on the center according to the parent
	     */
	    static readonly centerAll: (child: Container) => void;
	    /**
	     * Docks the element on top left according to the parent
	     */
	    static readonly topLeft: (child: Container) => void;
	    /**
	     * Docks the element on top and horizontaly centered according to the parent
	     */
	    static readonly topCenterHorizontal: (child: Container) => void;
	    /**
	     * Docks the element on top right according to the parent
	     */
	    static readonly topRight: (child: Container) => void;
	    /**
	     * Docks the element verticaly on center and right according to the parent
	     */
	    static readonly centerVerticalRight: (child: Container) => void;
	    /**
	     * Docks the element on bottom left according to the parent
	     */
	    static readonly bottomLeft: (child: Container) => void;
	    /**
	     * Docks the element on left and verticaly centered according to the parent
	     */
	    static readonly centerVerticalLeft: (child: Container) => void;
	    /**
	     * Docks the element on bottom and horizontaly centered according to the parent
	     */
	    static readonly bottomCenterHorizontal: (child: Container) => void;
	    /**
	     * Docks the element on bottom right according to the parent
	     */
	    static readonly bottomRight: (child: Container) => void;
	    /**
	     * Docks the element horizontaly on center according to the parent
	     */
	    static readonly centerHorizontal: (child: Container) => void;
	    /**
	     * Docks the element verticaly on center according to the parent
	     */
	    static readonly centerVertical: (child: Container) => void;
	    /**
	     * Docks the element on left according to the parent
	     */
	    static readonly left: (child: Container) => void;
	    /**
	     * Docks the element on right according to the parent
	     */
	    static readonly right: (child: Container) => void;
	    /**
	     * Docks the element on top according to the parent
	     */
	    static readonly top: (child: Container) => void;
	    /**
	     * Docks the element on bottom according to the parent
	     */
	    static readonly bottom: (child: Container) => void;
	}
}

declare module "@gdk/core-pixi/tools/dataCache" {
	import type { Rectangle, Point } from "pixi.js";
	/**
	 * @hidden
	 */
	export interface ICacheDictionary<T> {
	    [index: string]: T;
	}
	/**
	 * Used to help managing/checking cache.
	 * @see Docking for more usage examples.
	 * @see Resize for more usage examples.
	 */
	export class DataCache<T> {
	    /**
	     * The base object reference being used to check cache.
	     */
	    object: T;
	    /**
	     * @hidden
	     */
	    _rectangles: ICacheDictionary<Rectangle>;
	    /**
	     * @hidden
	     */
	    _points: ICacheDictionary<Point>;
	    /**
	     * @hidden
	     */
	    _commons: ICacheDictionary<number | boolean | string | ((...args: any[]) => any)>;
	    /**
	     * @hidden
	     */
	    _isDirty: boolean;
	    /**
	     * @hidden
	     */
	    _forcedDirty: boolean;
	    /**
	     * Constructor.
	     * @param object the base object reference being used to check cache.
	     * @see Docking for more usage examples.
	     * @see Resize for more usage examples.
	     */
	    constructor(object: T);
	    /**
	     * Adds a new rectangle to check values.
	     * @param name the name of the rectangle property in the base class.
	     * @param newRectangle the new rectangle reference to test.
	     */
	    addRectangle(name: string, newRectangle: Rectangle): void;
	    /**
	     * Adds a new point to check values.
	     * @param name the name of the point property in the base class.
	     * @param newPoint the new point reference to test.
	     */
	    addPoint(name: string, newPoint: Point): void;
	    /**
	     * Adds a new common value to check.
	     * @param name the name of the value property in the base class.
	     * @param newValue the new value to test.
	     */
	    addCommon(name: string, newValue: number | boolean | string | ((...args: any[]) => any)): void;
	    /**
	     * Returns wether or not the cache is dirty. If dirty, the cache is updated.
	     */
	    checkDirty(): boolean;
	}
}

declare module "@gdk/core-pixi/container/dockingBounds" {
	/**
	 * Represents the bounds used by the docking functions
	 * for couple width/height
	 */
	export interface IDockingBounds {
	    /**
	     * Fixed width for the parent
	     */
	    width?: number;
	    /**
	     * Fixed height for the parent
	     */
	    height?: number;
	}
	export class DockingBounds implements IDockingBounds {
	    width: number;
	    height: number;
	    /**
	     * Constructor
	     * @param width Fixed width for docking
	     * @param height Fixed height for docking
	     */
	    constructor(width?: number, height?: number);
	    /**
	     * Sets the new bounds for docking
	     * @param width New fixed width for docking
	     * @param height New fixed height for docking
	     */
	    setBounds(width: number, height: number): void;
	    /**
	     * Returns if the docking bounds are empty (width/heigh equal to 0)
	     */
	    isEmpty(): boolean;
	    /**
	     * Clones the current docking bounds object
	     */
	    clone(): DockingBounds;
	    /**
	     * Exports the current docking bounds configuration
	     */
	    export(): IDockingBounds;
	    /**
	     * Creates a new bounding bounds object using the
	     * given configuration
	     * @param config the previously exported configuration
	     */
	    static parse(config: any, ref?: DockingBounds): DockingBounds;
	}
}

declare module "@gdk/core-pixi/container/resize" {
	import { Transform, Rectangle } from "pixi.js";
	import type { Container } from "pixi.js";
	import { DataCache } from "@gdk/core-pixi/tools/dataCache";
	/**
	 * Resize function type alias
	 */
	export type ResizeType = (child: Container) => void;
	export class Resize {
	    /**
	     * Docking type as lambda function
	     */
	    resize: ResizeType;
	    /**
	     * Used for cache, stores the latest parent bounds.
	     * @hidden
	     */
	    _lastParentBounds: Rectangle;
	    /**
	     * Used for cache, stores the latest bounds of the resized object.
	     * @hidden
	     */
	    _lastBounds: Rectangle;
	    /**
	     * Used for cache, to check cache.
	     * @hidden
	     */
	    _cache: DataCache<Resize>;
	    /**
	     * Constructor.
	     * @param resize the resize function to apply. Can be a custom function.
	     */
	    constructor(resize: ResizeType);
	    /**
	     * Sets the resize forced dirty. Especially used when implemented custom/animated resize.
	     */
	    setDirty(): void;
	    /**
	     * Returns wether or not the resize is dirty. If yes, the resize function should be applied.
	     * @param parentBounds the potental new parent bounds rectangle.
	     * @param bounds the current bounds of the resized object.
	     */
	    isDirty(parentBounds: Rectangle, bounds: Rectangle): boolean;
	    /**
	     * Exports the resize configuration as a JSON.
	     */
	    export(): any;
	    /**
	     * Parses the given resize configuration and returns a new reference.
	     * @param config the exported configuration of the resize object.
	     */
	    static parse(config: any, ref?: Resize): Resize;
	    static _transform: Transform;
	    static _parentTransform: Transform;
	    static _parentBounds: Rectangle;
	    static _bounds: {
	        width: number;
	        height: number;
	    };
	    /**
	     * Resizes the element to cover its parent according to its width/height pair.
	     */
	    static readonly cover: (child: Container) => void;
	    /**
	     * Resizes the element to be contained in its parent according to its width/height pair.
	     */
	    static readonly contain: (child: Container) => void;
	    /**
	     * Resize the element to fill the parent container, breaking the element's ratio
	     */
	    static readonly fill: (child: Container) => void;
	    /**
	     * Resizes the element to be contained in its parent according to its width/height pair.
	     * Fit contain means that all children of the element will be docked according the element's parent bounds instead
	     * of the element's bounds. Typically used only to fit contain views.
	     */
	    static readonly fitContain: (child: Container) => void;
	    /**
	     * Resizes the element to be contained in its parent according to its width/height pair.
	     * Similar to fitContains except that an upper and lower parent's area will be ignore
	     * Typically used for top and bottom menu bar
	     * @param topSafeAreaHeight height of the top safe area, in pixel
	     * @param bottomSafeAreaHeight height of the bottom safe area, in pixel
	     * @param totalAreaHeight total height of the area, in pixel
	     */
	    static readonly boundedFitContain: (topSafeAreaHeight: number, bottomSafeAreaHeight: number, totalAreaHeight: number) => (child: Container) => void;
	    /**
	     * Resizes the element to be contained in its parent according to its width/height pair.
	     * Similar to cover except that an upper and lower parent's area will be ignore
	     * Typically used for top and bottom menu bar
	     * @param topSafeAreaHeight height of the top safe area, in pixel
	     * @param bottomSafeAreaHeight height of the bottom safe area, in pixel
	     * @param totalAreaHeight total height of the area, in pixel
	     * @param mainArea main container including safe area, used to follow scaleXY evolution
	     * @param safeHeight height of the top and bottom area in pixel
	     */
	    static readonly boundedCover: (topSafeAreaHeight: number, bottomSafeAreaHeight: number, totalAreaHeight: number, area: Container) => (child: Container) => void;
	}
}

declare module "@gdk/core-pixi/container/layout" {
	import type { Container } from "pixi.js";
	import type { IProjectContainerTransform } from "@gdk/core-pixi/loading/model";
	export interface ILayoutConfiguration {
	    /**
	     * Defines the name of the layout.
	     */
	    name: string;
	    /**
	     * Defines the ratio under the one the layout should be applied.
	     */
	    ratio: number;
	    /**
	     * Defines the configuration of the layout.
	     */
	    config: IProjectContainerTransform;
	    /**
	     * Sets wether or not the transition should be animated.
	     */
	    animateTransition: boolean;
	}
	/**
	 * Defines the main class used to store, apply, etc. layouts on a container.
	 */
	export class Layout {
	    /**
	     * Defines the list of all available layouts.
	     */
	    layoutConfigurations: ILayoutConfiguration[];
	    /**
	     * Defines the default configuration of the container.
	     */
	    defaultLayoutConfiguration: ILayoutConfiguration;
	    private _container;
	    private _currentLayoutConfiguration;
	    private _lastWidth;
	    private _lastHeight;
	    /**
	     * Constructor.
	     * @param container the reference to the container to apply the layouts.
	     * @param layouts defines the list of all available layouts for a container.
	     */
	    constructor(container: Container, layouts?: ILayoutConfiguration[], defaultLayout?: ILayoutConfiguration);
	    /**
	     * Returns the name of the current layout.
	     */
	    get currentLayoutConfiguration(): ILayoutConfiguration;
	    /**
	     * Returns the layout configuration identified by the given name.
	     * @param name the name of the layout configuration to retrieve.
	     */
	    getLayoutConfigurationByName(name: string): ILayoutConfiguration;
	    /**
	     * Adds a new layout configuration to the current list.
	     * @param name the name of the layout configuration.
	     * @param ratio the ratio under the one the layout is applied.
	     */
	    addLayoutConfiguration(name: string, ratio: number): ILayoutConfiguration;
	    /**
	     * Removes the given layout configuration from the list.
	     * @param layoutConfiguration the layout configuration to remove from the list.
	     */
	    removeLayoutConfiguration(layoutConfiguration: ILayoutConfiguration): boolean;
	    /**
	     * Sorts the current list of layout configurations.
	     */
	    sortLayoutConfigurations(): void;
	    /**
	     * Applies the layout according to the given parent's dimensions.
	     * @param width the width of the parent container.
	     * @param height the height of the parent container.
	     */
	    apply(width: number, height: number): void;
	    /**
	     * Applies the given layout configuration.
	     * @param layoutConfiguration the layout configuration to apply.
	     */
	    applyLayoutConfiguration(layoutConfiguration: ILayoutConfiguration): void;
	    /**
	     * Saves the current layout configurations.
	     */
	    saveCurrentLayoutConfiguration(): void;
	    /**
	     * Applies the layout according to last saved parent's dimensions.
	     */
	    private _applyFromLastDimensions;
	    /**
	     * Applies the layout configuration.
	     */
	    private _applyLayoutConfiguration;
	    /**
	     * Exports the given container's configuration with its children's configuration, recursively.
	     * @hidden
	     */
	    _exportContainer(container: Container): IProjectContainerTransform;
	    /**
	     * Exports the current layouts configuration to a JSON representation.
	     */
	    export(): any;
	    /**
	     * Parses the given layout configuration.
	     * @param container the reference to the container to apply the layouts.
	     * @param config defines the layout's configuration as a JSON representation.
	     */
	    static parse(container: Container, config: any): any;
	}
}

declare module "@gdk/core-pixi/loading/model" {
	import type { LoadedView } from "@gdk/core-pixi/view/loadedView";
	import type { ContainerView } from "@gdk/core-pixi/view/containerView";
	import type { IDocking } from "@gdk/core-pixi/container/docking";
	import type { IDockingBounds } from "@gdk/core-pixi/container/dockingBounds";
	import type { ILayoutConfiguration } from "@gdk/core-pixi/container/layout";
	/**
	 * Point
	 */
	export interface IProjectPoint {
	    x: number;
	    y: number;
	}
	/**
	 * Hit Area
	 */
	export interface IProjectHitArea {
	    type: number;
	}
	/**
	 * Rectangle
	 */
	export interface IProjectRectangle extends IProjectHitArea {
	    x: number;
	    y: number;
	    width: number;
	    height: number;
	}
	export interface IProjectRoundedRectangle extends IProjectRectangle {
	    radius: number;
	}
	export interface IProjectEllipse extends IProjectHitArea {
	    x: number;
	    y: number;
	    width: number;
	    height: number;
	}
	export interface IProjectCircle extends IProjectHitArea {
	    x: number;
	    y: number;
	    radius: number;
	}
	export interface IProjectPolygon extends IProjectHitArea {
	    points: number[];
	}
	/**
	 * Texture
	 */
	export interface IProjectTexture {
	    imageUrl: string;
	}
	/**
	 * Container transforms
	 */
	export interface IProjectContainerTransform {
	    name: string;
	    x: number;
	    y: number;
	    rotation: number;
	    scaleX?: number;
	    scaleY?: number;
	    pivot: IProjectPoint;
	    docking: IDocking;
	    dockingBounds: IDockingBounds;
	    resize: {
	        type: string;
	    };
	    children?: IProjectContainerTransform[];
	}
	/**
	 * Container
	 */
	export interface IProjectContainer extends IProjectContainerTransform {
	    type?: string;
	    visible: boolean;
	    alpha: number;
	    worldAlpha: number;
	    buttonMode: boolean;
	    interactive: boolean;
	    layouts?: ILayoutConfiguration[];
	    children?: IProjectContainer[];
	    metadata: any;
	}
	/**
	 * Animated Sprite
	 */
	export interface IProjectAnimatedSprite extends IProjectContainer {
	    animatedSprite: {
	        loop?: boolean;
	        animationSpeed?: number;
	        textures: IProjectTexture[];
	        durations?: number[];
	    };
	}
	export interface IProjectSymbolSprite extends IProjectContainer {
	    symbolSprite: {
	        frames: {
	            [frameId: string]: IProjectTexture;
	        };
	        defaultFrameId?: string;
	    };
	}
	/**
	 * Tiling Sprite
	 */
	export interface IProjectTilingSprite extends IProjectContainer {
	    tilingSprite: {
	        width: number;
	        height: number;
	        texture: IProjectTexture;
	        uvRespectAnchor: boolean;
	        clampMargin: number;
	        tileScale: IProjectPoint;
	        tilePosition: IProjectPoint;
	    };
	}
	/**
	 * Sprite
	 */
	export interface IProjectSprite extends IProjectContainer {
	    sprite: {
	        texture: IProjectTexture;
	    };
	}
	/**
	 * Nine slice plane
	 */
	export interface IProjectNineSlicePlane extends IProjectContainer {
	    nineSlicePlane: {
	        texture: IProjectTexture;
	        width?: number;
	        height?: number;
	        leftWidth: number;
	        rightWidth: number;
	        topHeight: number;
	        bottomHeight: number;
	    };
	}
	/**
	 * Graphics
	 */
	export interface IGraphicsData {
	    lineWidth: number;
	    lineColor: number;
	    lineAlpha: number;
	    fillColor: number;
	    fillAlpha: number;
	    fill: boolean;
	    nativeLines: boolean;
	    shape: IProjectHitArea;
	}
	export interface IProjectGraphics extends IProjectContainer {
	    graphicsDatas: IGraphicsData[];
	}
	/**
	 * View
	 */
	export interface IProjectView extends IProjectContainer {
	    stateName: string;
	    trackingName?: string;
	}
	/**
	 * Assets
	 */
	export interface IAsset {
	    name: string;
	    id: string;
	    data: any;
	    type?: string;
	}
	export interface IAssetsRoot {
	    [index: string]: IAsset[];
	}
	export interface ILocalizedAsset {
	    [referenceId: string]: {
	        [i18nCode: string]: string;
	    };
	}
	/**
	 * Project
	 */
	export interface IProject {
	    stage: IProjectContainer;
	    views: IProjectView[];
	    assets: IAssetsRoot;
	    skin?: any;
	    metadata?: any;
	    editorVersion?: string;
	    filesList?: string[];
	    localizedAssets?: ILocalizedAsset;
	    toolsStates?: any[];
	}
	/**
	 * Represents an exported view from the editor
	 */
	export type ViewConstructor = new (baseUrl: string, viewConfig: IProjectView, project: IProject) => LoadedView;
	/**
	 * Represents a view map used to build state from
	 * an editor project
	 */
	export interface IViewMap {
	    [index: string]: ViewConstructor;
	}
	/**
	 *
	 */
	export interface IViewConfig {
	    view: ContainerView;
	    name: string;
	}
}

declare module "@gdk/core-pixi/view/loadedView" {
	import { Container } from "pixi.js";
	import type { IView } from "@gdk/core";
	import type { IProjectContainer } from "@gdk/core-pixi/loading/model";
	export class LoadedView extends Container implements IView {
	    /**
	     * Defines the optional name of the object to be tracked.
	     * If unset, a default value will be taken by the tracker. For example,
	     * the name of the object (button, scratch, etc.).
	     */
	    trackingName: string;
	    private _baseUrl;
	    private _viewConfig;
	    private _project;
	    /**
	     * Constructor
	     * @param baseUrl the base url of the loader
	     * @param viewConfig the view configuration JSON
	     * @param project the editor project
	     */
	    constructor(baseUrl?: string, viewConfig?: any, project?: any);
	    /**
	     * Configure the view before loading
	     * @param baseUrl the base url of the loader
	     * @param viewCode the view configuration JSON
	     */
	    config(baseUrl: string, viewConfig: any, project: any): void;
	    /**
	     * On the view will appear
	     */
	    onWillAppear(done?: () => void): void;
	    /**
	     * On the view will disappear
	     */
	    onWillDisappear(done?: () => void): void;
	    /**
	     * On load the view
	     * @param done callback once loading done
	     */
	    onLoad(): void;
	    /**
	     * Returns a child container by name. Tries to find recursively
	     * @param name the name of the container to find
	     * @param root the root container for traversing children (default is "this" view)
	     */
	    getContainerByName<T extends Container>(name: string, root?: Container): T;
	    export(): IProjectContainer;
	}
}

declare module "@gdk/core-pixi/view/containerView" {
	import { Container } from "pixi.js";
	import type { IView } from "@gdk/core";
	export abstract class ContainerView extends Container implements IView {
	    /**
	     * Defines the optional name of the object to be tracked.
	     * If unset, a default value will be taken by the tracker. For example,
	     * the name of the object (button, scratch, etc.).
	     */
	    trackingName: string;
	    /**
	     * Constructor
	     */
	    constructor();
	    /**
	     * onLoad method
	     * @param done the callback when loading done, if not provided, onLoad is synchronous
	     */
	    abstract onLoad(done?: () => void): void;
	}
}

declare module "@gdk/core-pixi/augmentations/gsap" {
	/// <reference types="gsap" />
	module "gsap" {
	    interface TimelineMax extends TimelineLite {
	        /**
	         * Add callback to the Timeline.
	         * @todo Baron De Testa
	         * @param callback
	         * @param position
	         * @param params
	         * @param scope
	         */
	        addCallback(callback: (params?: any[]) => void, position: any, params?: any[], scope?: any): TimelineMax;
	    }
	}
	export {};
}

declare module "@gdk/core-pixi/gamePixi" {
	import { GameCore } from "@gdk/core";
	import { CanvasRenderer, Container } from "pixi.js";
	import type { WebGLRenderer, ApplicationOptions } from "pixi.js";
	import { Application } from "@gdk/core-pixi/application";
	import { PixiLoader } from "@gdk/core-pixi/loader";
	/**
	 * Options for game pixi instance creation
	 */
	export interface IGamePixiOptions extends ApplicationOptions {
	    /**
	     * The application reference created by the user.
	     * @example new BabylonApplication(...)
	     */
	    application?: Application;
	    /**
	     * Wether or not the GameCore instance should create a game div to put canvas in it.
	     */
	    createGameDiv?: boolean;
	}
	export class GamePixi extends GameCore {
	    static instance: GamePixi;
	    application: Application;
	    pixiLoader: PixiLoader;
	    onResize: () => void;
	    onShowLockScreen: () => void;
	    onHideLockScreen: () => void;
	    lockScreenEnabled: boolean;
	    private _lastRendererWidth;
	    private _lastRendererHeight;
	    /**
	     * Constructor
	     * @param with: the renderer width
	     * @param height: the renderer height
	     * @param noWebGL: if force to use canvas renderer
	     * @param options: the Pixi.js application options
	     */
	    constructor(width: number, height: number, noWebGL: boolean, options?: IGamePixiOptions);
	    /**
	     * Returns webgl support
	     * override PIXI.utils.isWebGLSupported method
	     */
	    isWebGLSupported(): boolean;
	    /**
	     * Returns the renderer created by PIXI.js
	     */
	    get renderer(): CanvasRenderer | WebGLRenderer;
	    /**
	     * Returns if the renderer is instance of CanvasRenderer. If not, WebGLRenderer is used
	     */
	    get isCanvasRenderer(): boolean;
	    /**
	     * Returns the main stage of the PIXI.js application
	     */
	    get stage(): Container;
	    /**
	     * Returns the lock stage (lockscreen) of the PIXI.js application
	     */
	    get lockStage(): Container;
	    /**
	     * Starts the game.
	     * @param view Specifies the first view to make appear.
	     * @returns A promise resolved when the game is loaded and started or void for backward compatibility.
	     */
	    start(state?: string): Promise<void> | void;
	    /**
	     * Resizes the main stage
	     * @param width the width in pixels
	     * @param height the height in pixels
	     */
	    resize(width?: number, height?: number, force?: boolean): void;
	    /**
	     * Disposes the GamePixi instance. Destroys everything
	     */
	    dispose(): void;
	    /**
	     * Return the game's infos. Should be overidden to add
	     * more informations to log
	     */
	    protected getInfos(): Promise<any>;
	}
}

declare module "@gdk/core-pixi/application" {
	import { Application as PixiApplication, Container, utils } from "pixi.js";
	import type { IGamePixiOptions } from "@gdk/core-pixi/gamePixi";
	export class Application extends PixiApplication {
	    /**
	     * Stage being rendered by Pixi.js to draw the lock view
	     */
	    lockStage: Container;
	    /**
	     * If the application should render the lock screen (lockStage)
	     */
	    shouldLockScreen: boolean;
	    /**
	     * Called before rendering the pixi.js main stage
	     * @deprecated
	     */
	    onBeforeRender: () => void;
	    /**
	     * Called after rendered the pixi.js main stage
	     * @deprecated
	     */
	    onAfterRender: () => void;
	    /**
	     * Emitter used to send events like "beforeRender", etc.
	     * @example: "beforeRender", "afterRender", "start", "stop"
	     */
	    emitter: utils.EventEmitter;
	    /**
	     * Defines the time in ms to wait before checking the renderer resolution optimizer
	     */
	    waitingTimeBeforeOptimization: number;
	    /**
	     * Defines the resolution ratios (capping) used by the optimizer
	     * @example optimizerResolutionRatios.lowQuality = 0.5; // Means that if FPS <= 30, change to low quality resolution (1)
	     * @example optimizerResolutionRatios.highQuality = 0.75; // Means that if FPS >= 45, change to high quality resolution (window.devicePixelRatio)
	     */
	    optimizerResolutionRatios: {
	        lowQuality: number;
	        highQuality: number;
	    };
	    /**
	     * Defines wether or not the optimizer should be disabled once the resolution changed.
	     * Typically fell back to lower resolution. To re-enable optimizer, juste set
	     * shouldOptimizeRendererResolution = true.
	     */
	    shouldStopOptimizerOnceFellBack: boolean;
	    /**
	     * Called once the renderer's resolution has been changed (when optimizing)
	     * @param newResolution the new resolution of the renderer
	     */
	    onRendererResolutionChanged: (newResolution?: number) => void;
	    /**
	     * Defines the start time for the optimizer (when the renderer starts: date.now())
	     */
	    protected startOptimizerTime: number;
	    /**
	     * Defines the framerate state:
	     *    * count: number of frames rendered before we compute the optimizer
	     *    * time: number of ms taken to render the ${count} frames
	     */
	    protected framerate: {
	        count: number;
	        time: number;
	    };
	    /**
	     * Defines wether or not the application should optimize itself by changing resolution.
	     */
	    private _shouldOptimizeRendererResolution;
	    /**
	     * Constructor
	     * @param width the width in pixels
	     * @param height the height in pixels
	     * @param noWebGL to force no webgl
	     * @param options the application options
	     */
	    constructor(width: number, height: number, noWebGL: boolean, options?: IGamePixiOptions);
	    /**
	     * Gets wether or not the application should optimize itself by changing resolution.
	     */
	    get shouldOptimizeRendererResolution(): boolean;
	    /**
	     * Sets wether or not the application should optimize itself by changing resolution.
	     */
	    set shouldOptimizeRendererResolution(enabled: boolean);
	    /**
	     * Starts the application (ticker)
	     */
	    start(): void;
	    /**
	     * Stops the application (ticker)
	     */
	    stop(): void;
	    /**
	     * Renders the application:
	     * - Renders the main stage if not locked
	     * - Else, just render the locked screen view
	     */
	    render(): void;
	    /**
	     * Resizes the application
	     * @param width the new canvas width
	     * @param height the new canvas height
	     */
	    resize(width: number, height: number): void;
	    /**
	     * Computes the optimizer to determine if the renderer should render
	     * in a lower or higher resolution
	     */
	    protected computeOptimizer(elapsed: number): void;
	    /**
	     * Checks the renderer optimizer.
	     */
	    protected _checkOptimizer(elapsed: number): void;
	}
}

declare module "@gdk/core-pixi/loader" {
	import { loaders } from "pixi.js";
	import type { ILoader } from "@gdk/core";
	export class PixiLoader implements ILoader {
	    extensions: string[];
	    instance: loaders.Loader;
	    overrideOnMultipleLoads: boolean;
	    /**
	     * Constructor
	     */
	    constructor(baseUrl?: string);
	    get baseUrl(): string;
	    set baseUrl(url: string);
	    /**
	     * Add the given file to the files to load
	     * @param filename the file to add
	     */
	    add(filename: string, key?: string, options?: any): void;
	    /**
	     * Removes the given entry identified by the given key
	     * @param key the key used to identify the entry to remove
	     */
	    remove(key: string): void;
	    /**
	     * Load all files previously added
	     * @param callback called when all files loaded
	     */
	    load(callback: () => void, progress?: () => void, error?: (file: string) => void): void;
	    /**
	     * Clears the resources previously loaded
	     */
	    clear(): void;
	    /**
	     * Returns the resource identified by the given key
	     * @param key the key of the value to get
	     */
	    get?<T>(key: string, raw?: boolean): T;
	}
}

declare module "@gdk/core-pixi/svg/SVGGraphics" {
	import { Graphics, Point } from "pixi.js";
	export interface IDrawStyle {
	    fill?: {
	        color?: number;
	        alpha?: number;
	    };
	    stroke?: {
	        lineWidth?: number;
	        color?: number;
	        alpha?: number;
	    };
	}
	export class SVGGraphics extends Graphics {
	    polygons: Point[][];
	    paths: Point[][];
	    polylines: Point[][];
	    points: Point[][];
	    drawStyle: IDrawStyle;
	    svg: Document;
	    src: string;
	    private quality;
	    /**
	     * create a Graphics from a svg file
	     * @param svgAssetID the ID of your SVG file
	     * @param qualityRatio the quality ratio (0 to 1) used to draw path elements
	     * @param drawStyle the style used to draw path elements :
	     *  fill?: { color?: number, alpha?: number };
	     *  stroke?: { lineWidth?: number, color?: number, alpha?: number };
	     */
	    constructor(svgAssetID: string, qualityRatio?: number, drawStyle?: IDrawStyle);
	    /**
	     * convert an SVGPolygonElement to a point array.
	     * @param polygons a list of SVGPolygonElement or SVGPolylineElement
	     */
	    private getPolygons;
	    /**
	     * convert an SVGPathElement to a point array.
	     * @param paths a list of SVGPathElement
	     */
	    private getPaths;
	    /**
	     * will draw all points
	     * @param points the points arrays to draw
	     * @param style	the style to use
	     */
	    private drawPoints;
	    /**
	     * convert points arrays to number arrays.
	     * @param points the point to convert to number arrays
	     */
	    private pointsToNumbersArray;
	}
}

declare module "@gdk/core-pixi/container/anchor" {
	import { Docking } from "@gdk/core-pixi/container/docking";
	import type { DockingType } from "@gdk/core-pixi/container/docking";
	export class Anchor extends Docking {
	    /**
	     * Constructor shortcut for Docking(dock, x, y, false)
	     * will perform a docking without using pivot compensation.
	     * @param width fixed width of the container
	     * @param height fixed height of the container
	     * @param x x offset of the container
	     * @param y y offset of the container
	     * @param dock the docking function to apply
	     */
	    constructor(dock?: DockingType, x?: number, y?: number);
	}
}

declare module "@gdk/core-pixi/container/utils" {
	import { Rectangle, Transform, Point } from "pixi.js";
	import type { Container, SystemRenderer } from "pixi.js";
	export class ContainerUtils {
	    /**
	     * This is used to avoid creating new rectangles when calling .getLocalBounds
	     */
	    static tempRectangle: Rectangle;
	    /**
	     * This is used to avoid creating new rectangles each time the function is applied.
	     */
	    static parentBounds: Rectangle;
	    /**
	     * This is used to avoid creating new rectangles each time the function is applied.
	     */
	    static bounds: Rectangle;
	    /**
	     * Returns the current parent bounds according to its configuration (bounds, no bounds, etc.).
	     * @param parent the parent reference.
	     * @param parentTransform the parent transform reference configured from its world transform.
	     * @param result the result where to store the bounds.
	     */
	    static refreshParentBounds(parent: any, parentTransform: Transform, result?: Rectangle): Rectangle;
	    /**
	     * Returns the current container's bounds according to its configuration (bounds, no bounds, etc.).
	     * @param container the container reference.
	     * @param transform the container transform reference configured from its world transform.
	     * @param result the result where to store the bounds.
	     */
	    static refreshBounds(container: any, transform: Transform, result?: Rectangle): Rectangle;
	    /**
	     * Recursively updates the transform of each container, needed to synchronize docking/resize with children.
	     * @param root the root container to update and update its children.
	     */
	    static recursivelyUpdateTransform(root: Container): void;
	    /**
	     * Get the real dimension of the container based (not relative to its children)
	     * The container must have docking bounds to work
	     * @param renderer: The renderer system provided by PIXIGame
	     * @param container: The actual container to get information about scale
	     * @return Point which represents the real dimension of the container in x axis and y axis
	     */
	    static getContainerDimensions(renderer: SystemRenderer, container: Container): Point;
	}
}

declare module "@gdk/core-pixi/accessibility/helper" {
	export class AccessibilityHelper {
	    /**
	     * Overrides the update function of the AccessibilityManager class of Pixi.JS.
	     * This override is mandatory to get accessibility working with resize and docking
	     * systems.
	     */
	    static overrideUpdate(): void;
	    /**
	     * Overrides the activate option to trigger an event on the activation of the accessibility.
	     * This is mandatory to set to visible any Containers that needs to be accessible.
	     * If the element is not visible it won't be accessible.
	     */
	    static overrideActivate(): void;
	    /**
	     * Overrides the deactivate option to trigger an event on the deactivation of the accessibility.
	     */
	    static overrideDeactivate(): void;
	    /**
	     * Creates a new notification DOM element that will be read by the OS narrator on the fly.
	     * @param message defines the message to be read by the OS narrator.
	     * @param delay defines the time expressed in seconds to wait until the notification is removed from the DOM.
	     */
	    static createNotification(message: string, delay?: number): Promise<void>;
	}
}

declare module "@gdk/core-pixi/components/clip" {
	import { Container, extras as Extra, Texture } from "pixi.js";
	import { Docking } from "@gdk/core-pixi/container/docking";
	export interface IClipOptionsOptional {
	    docking?: Docking;
	    speed?: number;
	    anchor?: number;
	    play?: boolean;
	    loop?: boolean;
	}
	export interface IClipFramesOptions extends IClipOptionsOptional {
	    frameNames: string[];
	    duration: number;
	}
	export interface IClipOptions extends IClipOptionsOptional {
	    prefix: string;
	    suffix: string;
	    in: number;
	    out: number;
	    duration: number;
	}
	export interface IAnimatedSpriteTextureTimeObject {
	    texture: Texture;
	    time: number;
	}
	export type textureTimedCollection = IAnimatedSpriteTextureTimeObject[];
	export class Clip extends Container {
	    base: Extra.AnimatedSprite;
	    private _frames;
	    private _frmIx;
	    private _opts;
	    private static _zero;
	    private static _frameNamesKey;
	    /**
	     * Constructor
	     * @param options refer to IClipOptions
	     */
	    constructor(options: IClipOptions | IClipFramesOptions);
	    /**
	     * play the base clip
	     */
	    play(): void;
	    /**
	     * stop the base clip
	     */
	    stop(): void;
	    /**
	     * go to required frameNumber and play if withPlay true or go to it and stop
	     *
	     * @param frameNumber set frame index
	     * @param withPlay let clip playing ot not
	     *
	     */
	    goto(frameNumber: number, withPlay?: boolean): void;
	    /**
	     * play a sequence from frameNumberIn to frameNumberOut then stop
	     *
	     * @param frameNumberIn set frame index to start from
	     * @param frameNumberOut set frame to play to
	     * @param cb set on complete callback
	     *
	     */
	    playSequence(frameNumberIn: number, frameNumberOut: number, cb?: () => void): void;
	    /**
	     * returns the frame duration in ms
	     * calculated for the global duration option and the number of frames
	     * defined in options
	     */
	    protected get frameDuration(): number;
	    /**
	     * hasFrameNames
	     * return true if frameNames is defined in options
	     *
	     * @returns boolean
	     */
	    private get _hasFrameNames();
	    /**
	     * isIClipFramesOptions
	     *
	     * return true if opts matches IClipFramesOptions interface
	     *
	     * @param any
	     * @returns boolean
	     */
	    private _isIClipFramesOptions;
	    /**
	     * load timed textures into frames
	     *
	     * @returns void
	     */
	    private _setFrames;
	    /**
	     * padTwo
	     *
	     * return left 0 padded 2 digits number as string
	     *
	     * @param number
	     * @returns string
	     */
	    private _padTwo;
	}
}

declare module "@gdk/core-pixi/loading/import/commonImporter" {
	import { Rectangle, Point } from "pixi.js";
	import type { IProjectRectangle, IProjectPoint } from "@gdk/core-pixi/loading/model";
	export class CommonImporter {
	    /**
	     * Import a rectangle from the given configuration
	     * @param config the rectangle's configuration
	     */
	    static importRectangle(config: IProjectRectangle): Rectangle;
	    /**
	     * Import a point from the given configuration
	     * @param config the point's configuration
	     */
	    static importPoint(config: IProjectPoint): Point;
	}
}

declare module "@gdk/core-pixi/loading/import/containerImporter" {
	import { Container, extras, mesh } from "pixi.js";
	import type { Sprite, Graphics } from "pixi.js";
	import type { IEditorDecoratorObject } from "@gdk/core-pixi/decorators/editor";
	import type { ILoaderDecoratorObject } from "@gdk/core-pixi/decorators/loader";
	import type { IProjectContainer, IProjectSprite, IProjectAnimatedSprite, IProjectTilingSprite, IProject, IProjectNineSlicePlane, IProjectGraphics, IProjectContainerTransform } from "@gdk/core-pixi/loading/model";
	import type { GamePixi } from "@gdk/core-pixi/gamePixi";
	export enum EContainerImporterMode {
	    /**
	     * Typically used by the editor.
	     */
	    Dev = "dev",
	    /**
	     * Production mode when importing a container.
	     */
	    Prod = "prod"
	}
	export class ContainerImporter {
	    /**
	     * Custom container creator. Should be use to create custom
	     * containers with custom types like ui.TextField etc.
	     */
	    static customContainerCreator: (config: IProjectContainer, container?: Container, project?: IProject) => Container;
	    /**
	     * Defines the mode when importing a container. Prod = import scripts etc. Dev = just create a new container.
	     */
	    static mode: EContainerImporterMode;
	    /**
	     * Custom container modeler. Once the container is created, just call
	     * this function to customize more the container (metadatas, etc.)
	     */
	    static customContainerCustomizer: (config: IProjectContainer, container: Container) => void;
	    /**
	     * Imports the given config by checking the type
	     * @param config the container configuration
	     * @param baseUrl the base url of the loader
	     * @param container the container reference. If not exists, will be created
	     */
	    static import<T extends Container>(config: IProjectContainer, baseUrl: string, container?: Container, project?: IProject): Container;
	    /**
	     * Import a container from the given configuration
	     * @param config the container configuration
	     * @param baseUrl the base url of the loader
	     * @param container the container reference. If not exists, will be created
	     */
	    static importContainer<T extends Container>(config: IProjectContainer, baseUrl: string, container: Container, project?: IProject, game?: GamePixi): T;
	    /**
	     * Gets the references from the loader for the given decorated properties of the given target.
	     * @param store the store containing the decorated properties informations.
	     * @param container the container being parsed.
	     * @param target the target object to put reference in it. (typically a game or a container).
	     */
	    static getFromLoaderDecorators(store: ILoaderDecoratorObject[], container: Container, target: GamePixi | Container): void;
	    /**
	     * Gets the container references for the given decorated properties of the given target.
	     * @param store the store containing the decorated properties informations.
	     * @param container the container being parsed.
	     * @param target the target object to put reference in it. (typically a game or a container).
	     */
	    static getFromEditorDecorators(store: IEditorDecoratorObject[], container: Container, target: GamePixi | Container): void;
	    /**
	     * Returns the newly created container in case a script is attached to.
	     * Starting from Editor vNext.
	     * @param config the container's configuration.
	     * @param baseUrl the base url of the loader
	     */
	    static getContainerFromScript(config: IProjectContainer, baseUrl: string): Container;
	    /**
	     * Configures the properties of the script attached to the container.
	     * @param config the container's configuration.
	     * @param baseUrl the base url of the loader
	     */
	    private static _configureScriptProperties;
	    /**
	     * Configures the given container according to the given configuration
	     * @param config the container configuration
	     * @param container the container to configure using the config object
	     * @param baseUrl the base url of the loader
	     */
	    static configureContainer(config: IProjectContainer, container: Container, baseUrl?: string): void;
	    /**
	     * Configures the given container according to the given transform configuration.
	     * @param config the container's transformation configuration.
	     * @param container the container to configure using the configuration object.
	     */
	    static configureContainerTransform(config: IProjectContainerTransform, container: Container): void;
	    /**
	     * Import a sprite from the given configuration
	     * @param config the sprite configuration
	     * @param baseUrl the base url of the loader
	     * @param sprite the sprite reference
	     */
	    static importSprite(config: IProjectSprite, baseUrl: string, sprite?: Sprite): Sprite;
	    /**
	     * Import an animated sprite from the given configuration
	     * @param config the animated sprite configuration
	     * @param baseUrl the base url of the loader
	     * @param sprite the animated sprite reference
	     */
	    static importAnimatedSprite(config: IProjectAnimatedSprite, baseUrl: string, sprite?: extras.AnimatedSprite): extras.AnimatedSprite;
	    /**
	     * Import a tiling sprite from the given configuration
	     * @param config the tiling sprite configuration
	     * @param baseUrl the base url of the loader
	     * @param sprite the tiling sprite reference
	     */
	    static importTilingSprite(config: IProjectTilingSprite, baseUrl: string, sprite?: extras.TilingSprite): extras.TilingSprite;
	    /**
	     * Import a nine slice plane from the given configuration
	     * @param config the nine slice plane configuration
	     * @param baseUrl the base url of the loader
	     * @param nineSlicePlane the nine slice plane reference
	     */
	    static importNineSlicePlane(config: IProjectNineSlicePlane, baseUrl: string, nineSlicePlane?: mesh.NineSlicePlane): mesh.NineSlicePlane;
	    /**
	     * Import a graphics from the given configuration
	     * @param config the graphics configuration
	     * @param baseUrl the base url of the loader
	     * @param graphics the graphics reference
	     */
	    static importGraphics(config: IProjectGraphics, baseUrl: string, graphics?: Graphics): Graphics;
	}
}

declare module "@gdk/core-pixi/decorators/editor" {
	export interface IEditorDecoratorObject {
	    /**
	     * Defines the path of the element to retrieve in the container's hierarchy.
	     */
	    path: string | symbol;
	    /**
	     * Defines the name of the property being marked @fromEditor.
	     */
	    propertyKey: string | symbol;
	}
	/**
	 * Defines the store of all @fromEditor decorators being used while importing a container.
	 * @see .containerImporter.ts
	 */
	export const editorStore: {
	    [ctorName: string]: IEditorDecoratorObject[];
	};
	/**
	 * Marks the property as comming from the editor.
	 * @param path defines the path (or name) of the element to retrieve in the container's hierarchy.
	 */
	export function fromEditor(path?: string | symbol): any;
}

declare module "@gdk/core-pixi/decorators/loader" {
	export interface ILoaderDecoratorObject {
	    /**
	     * Defines the path of the element to retrieve in the container's hierarchy.
	     */
	    name: string | symbol;
	    /**
	     * Defines the name of the property being marked @fromEditor.
	     */
	    propertyKey: string | symbol;
	}
	/**
	 * Defines the store of all @fromLoader decorators being used while importing a container.
	 * @see .containerImporter.ts
	 */
	export const loaderStore: {
	    [ctorName: string]: ILoaderDecoratorObject[];
	};
	/**
	 * Generates a sound member (decorator function).
	 * @param name the name of the sound to get in the loader.
	 */
	export function fromLoader(name: string): any;
}

declare module "@gdk/core-pixi/loading/import/textureImporter" {
	import { Texture, DisplayObject } from "pixi.js";
	import type { IProjectTexture } from "@gdk/core-pixi/loading/model";
	export class TextureImporter {
	    /**
	     * Import a texture from the given configuration
	     * @param config the texture's configuration
	     * @param baseUrl the base url of the loader
	     */
	    static importTexture(config: IProjectTexture, baseUrl: string, ...origins: Array<DisplayObject | string>): Texture;
	}
}

declare module "@gdk/core-pixi/loading/import/stateImporter" {
	import { State } from "@gdk/core";
	import { LoadedView } from "@gdk/core-pixi/view/loadedView";
	import type { IProjectView, IViewMap, IProject } from "@gdk/core-pixi/loading/model";
	export class StateImporter {
	    /**
	     * Imports a state from the given configuration
	     * @param viewsConfig the views configurations
	     * @param baseUrl the base Url of the loader
	     * @param viewMap the map containing the view constructors
	     * @param project the overall project configuration
	     */
	    static importState(viewsConfig: IProjectView[], baseUrl: string, viewMap: IViewMap, project: IProject): State;
	    /**
	     * Import a view from the given configuration
	     * @param view the view reference to configure
	     * @param config the configuration of the view to import
	     */
	    static importView(view: LoadedView, config: IProjectView, baseUrl: string, project: IProject): void;
	}
}

declare module "@gdk/core-pixi/loading/import/projectImporter" {
	import type { IProject, IViewMap } from "@gdk/core-pixi/loading/model";
	import type { GamePixi } from "@gdk/core-pixi/gamePixi";
	export class ProjectImporter {
	    /**
	     * Import the project from the given configuration
	     * @param game the game reference
	     * @param project the project configuration
	     * @param baseUrl the base url of the loader
	     * @param viewMap the map containing the view constructors
	     */
	    static importProject(game: GamePixi, project: IProject, baseUrl: string, viewMap?: IViewMap): void;
	}
}

declare module "@gdk/core-pixi/loading/export/commonExporter" {
	import type { Rectangle, Point, ObservablePoint, RoundedRectangle, Ellipse, Circle, Polygon } from "pixi.js";
	import type { IProjectRectangle, IProjectPoint, IProjectRoundedRectangle, IProjectEllipse, IProjectCircle, IProjectPolygon } from "@gdk/core-pixi/loading/model";
	export class CommonExporter {
	    /**
	     * Exports the given rectangle
	     * @param rect the rectangle to export
	     */
	    static exportRectangle(rect: Rectangle): IProjectRectangle;
	    /**
	     * Exports the given rounded rectangle
	     * @param rect the rounded rectangle to export
	     */
	    static exportRoundedRectangle(rect: RoundedRectangle): IProjectRoundedRectangle;
	    /**
	     * Exports the given ellipse
	     * @param ellipse the ellipse to export
	     */
	    static exportEllipse(ellipse: Ellipse): IProjectEllipse;
	    /**
	     * Exports the given circle
	     * @param circle the circle to export
	     */
	    static exportCircle(circle: Circle): IProjectCircle;
	    /**
	     * Exports the given polygon
	     * @param polygon the polygon to export
	     */
	    static exportPolygon(polygon: Polygon): IProjectPolygon;
	    /**
	     * Exports the given point
	     * @param point the point to export
	     */
	    static exportPoint(point: Point | ObservablePoint): IProjectPoint;
	}
}

declare module "@gdk/core-pixi/loading/export/containerExporter" {
	import { extras, Graphics, mesh, Sprite } from "pixi.js";
	import type { Container } from "pixi.js";
	import type { IProjectAnimatedSprite, IProjectContainer, IProjectContainerTransform, IProjectGraphics, IProjectNineSlicePlane, IProjectSprite, IProjectTilingSprite } from "@gdk/core-pixi/loading/model";
	export class ContainerExporter {
	    /**
	     * Export the given container
	     * @param container the container to export
	     * @param noChildren if to not export children
	     */
	    static export(container: Container, noChildren?: boolean): IProjectContainer;
	    /**
	     * Exports the given container
	     * @param container the container to export
	     * @param noChildren if to not export children
	     */
	    static exportContainer(container: Container, noChildren?: boolean): IProjectContainer;
	    /**
	     * Exports the given container's configuration.
	     * @param container the container to export its configuration.
	     */
	    static exportContainerConfiguration(container: Container): IProjectContainer;
	    /**
	     * Exports the transformation configuration of the given container.
	     * @param container the container to export its transformtion configuration.
	     */
	    static exportContainerTransforms(container: Container): IProjectContainerTransform;
	    /**
	     * Exports the given sprite
	     * @param sprite the sprite to export
	     * @param noChildren if to not export children
	     */
	    static exportSprite(sprite: Sprite, noChildren?: boolean): IProjectSprite;
	    /**
	     * Exports the given animated sprite
	     * @param sprite the animated sprite to export
	     * @param noChildren if to not export children
	     */
	    static exportAnimatedSprite(sprite: extras.AnimatedSprite, noChildren?: boolean): IProjectAnimatedSprite;
	    /**
	     * Exports the given tiling sprite
	     * @param sprite the tiling sprite to export
	     * @param noChildren if to not export children
	     */
	    static exportTilingSprite(sprite: extras.TilingSprite, noChildren?: boolean): IProjectTilingSprite;
	    /**
	     * Exports the given nine slice plane
	     * @param nineSlicePlane the nine slice plane to export
	     * @param noChildren if to not export children
	     */
	    static exportNineSlicePlane(nineSlicePlane: mesh.NineSlicePlane, noChildren?: boolean): IProjectNineSlicePlane;
	    /**
	     * Exports the given graphics
	     * @param graphics the graphics to export
	     * @param noChildren if to not export children
	     */
	    static exportGraphics(graphics: Graphics, noChildren?: boolean): IProjectGraphics;
	}
}

declare module "@gdk/core-pixi/loading/export/textureExporter" {
	import type { Texture } from "pixi.js";
	import type { IProjectTexture } from "@gdk/core-pixi/loading/model";
	export class TextureExporter {
	    /**
	     * Exports the given texture
	     * @param texture the texture to export
	     */
	    static exportTexture(texture: Texture): IProjectTexture;
	}
}

declare module "@gdk/core-pixi/loading/export/stateExporter" {
	import type { GamePixi } from "@gdk/core-pixi/gamePixi";
	import type { ContainerView } from "@gdk/core-pixi/view/containerView";
	import type { LoadedView } from "@gdk/core-pixi/view/loadedView";
	import type { IProjectView } from "@gdk/core-pixi/loading/model";
	export interface IViewConfig {
	    view: ContainerView | LoadedView;
	    name: string;
	}
	export class StateExporter {
	    /**
	     * Exports all available viewss
	     * @param game the game reference
	     */
	    static exportViews(game: GamePixi): IProjectView[];
	    /**
	     * Export the given view
	     * @param view the view to export
	     */
	    static exportView(view: IViewConfig): IProjectView;
	}
}

declare module "@gdk/core-pixi/loading/export/projectExporter" {
	import type { GamePixi } from "@gdk/core-pixi/gamePixi";
	import type { IProject } from "@gdk/core-pixi/loading/model";
	export class ProjectExporter {
	    /**
	     * Export the project
	     * @param game the game reference
	     */
	    static exportProject(game: GamePixi): IProject;
	    /**
	     * Returns the index of the view in its parent.
	     */
	    private static _getViewIndex;
	}
}

declare module "@gdk/core-pixi/proton/serialization" {
	import Proton from "proton-js";
	import type { ISerializedEmitterComponent, ISerializedEmitter } from "@gdk/core-pixi/proton/types";
	export class ProtonSerializer {
	    /**
	     * Serializes the given emitter.
	     * @param emitter defines the reference to the emitter to export.
	     */
	    static serializeEmitter(emitter: Proton.Emitter): ISerializedEmitter;
	    /**
	     * Serializes the given particle system.and returns its JSON representation.
	     * @param system defines the reference to the particles system to serialize.
	     */
	    static serializeSystem(system: Proton): ISerializedEmitter[];
	    /**
	     * Parses the emitters according the given list of JSON representations.
	     * @param config defines the array of JSON representatons of the Proton emitters.
	     */
	    static parseEmitters(config: ISerializedEmitter[], system?: Proton): Proton.Emitter[];
	    /**
	     * Parses the emitter according to the given JSON configuration.
	     * @param config defines the JSON representation of the Proton emitter.
	     */
	    static parseEmitter(config: ISerializedEmitter, system?: Proton): Proton.Emitter;
	    /**
	     * Parses the span according to the given JSON representation.
	     * @param span defines the JSON representation of the span.
	     */
	    static parseSpan(span: ISerializedEmitterComponent): Proton.Span;
	    /**
	     * Parses the component according to the given JSON representation.
	     * @param component defines the JSON representation of the component.
	     */
	    static parseComponent<T = any>(component: ISerializedEmitterComponent): T;
	}
}

declare module "@gdk/core-pixi/proton/types" {
	export enum ESerializedEmitterComponentType {
	    /**
	     * Defines a span component.
	     */
	    Span = "Span",
	    /**
	     * Defines a vector 2d component.
	     */
	    Vector2D = "Vector2D"
	}
	export interface ISerializedEmitterComponent {
	    /**
	     * Defines the type of the component.
	     */
	    type: ESerializedEmitterComponentType | string;
	    /**
	     * Defines the list of all arguments to pass in the component's constructor.
	     */
	    arguments?: any[];
	}
	export interface ISerializedEmitter {
	    /**
	     * Defines the Id of the emitter.
	     */
	    id: string;
	    /**
	     * Defines the name of the emitter.
	     */
	    name: string;
	    /**
	     * Defines the damping value of the emitter.
	     */
	    damping: number;
	    /**
	     * Defines the rate value of the emitteR.
	     */
	    rate: ISerializedEmitterComponent;
	    /**
	     * Defines the list of all initializers of the emitter.
	     */
	    initializers: ISerializedEmitterComponent[];
	    /**
	     * Defines the list of all behaviors of the emitter.
	     */
	    behaviors: ISerializedEmitterComponent[];
	}
}

declare module "@gdk/core-pixi/proton/protonContainer" {
	import { Container } from "pixi.js";
	import Proton from "proton-js";
	import type { CanvasRenderer, WebGLRenderer } from "pixi.js";
	import type { ISerializedEmitter } from "@gdk/core-pixi/proton/types";
	export enum EProtonContainerEvent {
	    /**
	     * Defines the key of the event raised when a particle has been created.
	     */
	    OnParticleCreated = "particleCreated",
	    /**
	     * Defines the key of the event raised when a particle is being updated.
	     */
	    OnParticleUpdate = "particleUpdate"
	}
	export class ProtonContainer extends Container {
	    /**
	     * Defines the default configuration of particle systems.
	     */
	    static readonly defaultConfig: ISerializedEmitter[];
	    /**
	     * Defines wether or not the particles emitters should be auto started once they are loaded.
	     */
	    autoStart: boolean;
	    private _system;
	    private _renderer;
	    /**
	     * @hidden
	     */
	    _config: ISerializedEmitter[];
	    /**
	     * Constructor.
	     * @param systemConfig defines the base configuration of the container.
	     */
	    constructor(systemConfig?: ISerializedEmitter[]);
	    /**
	     * Renders the scratch using the WebGL renderer.
	     * @param renderer the webgl renderer reference.
	     */
	    renderWebGL(renderer: WebGLRenderer): void;
	    /**
	     * Renders the scratch using the canvas renderer.
	     * @param renderer the canvas renderer reference.
	     */
	    renderCanvas(renderer: CanvasRenderer): void;
	    /**
	     * Loads the particles system of the container from the given JSON object.
	     * @param json defines the reference to the JSON object that defines the particles system.
	     */
	    loadFromJSON(json: ISerializedEmitter[]): void;
	    /**
	     * Appends the particles system of the container from the given JSON object.
	     * @param json defines the reference to the JSON object that defines the new particle system to append.
	     */
	    appendFromJSON(json: ISerializedEmitter[]): void;
	    /**
	     * Gets the particles system reference using Proton.
	     */
	    get system(): Proton;
	    /**
	     * Gets the  renderer used by Proton (here PIXIRenderer).
	     */
	    get renderer(): Proton.PIXIRenderer;
	    /**
	     * Gets the current config of all emitters.
	     */
	    get config(): ISerializedEmitter[];
	    /**
	     * Sets the current config of all emitters.
	     */
	    set config(config: ISerializedEmitter[]);
	    /**
	     * Stops all the emitters.
	     */
	    stopEmitters(): void;
	    /**
	     * Stops the given emitter.
	     */
	    stopEmitter(emitterOrId: Proton.Emitter | string): void;
	    /**
	     * Starts all the emitters in the given mode.
	     * @param mode defines the emission mode for the emitters.
	     */
	    startEmitters(mode?: "once"): void;
	    /**
	     * Starts the given emitter in the given mode.
	     * @param emitterOrId defines the reference to the emitter or the id of the emitter.
	     * @param mode defines the emission mode for the emitter.
	     */
	    startEmitter(emitterOrId: Proton.Emitter | string, mode?: "once"): void;
	    /**
	     * Returns, if exists, the reference to the Proton emitter.
	     * @param id defines the id of the emitter to get.
	     */
	    getEmitterById(id: string): Proton.Emitter;
	    /**
	     * Returns the index of the given emitter in the array of emitters in the particles system.
	     * @param emitterOrId defines the reference to the emitter or the id of the emitter.
	     */
	    getEmitterIndex(emitterOrId: Proton.Emitter | string): number;
	    /**
	     * Returns the reference, if exists, of the emitter or the emitter identified by the given Id.
	     */
	    private _getEmitterOrId;
	    /**
	     * Overrides the events of the proton renderer to catch them.
	     */
	    private _overrideEvents;
	    /**
	     * Exports the spine timeline.
	     */
	    export(): any;
	    /**
	     * Parses the proton container according to the given configuration.
	     * @param config the serialized data.
	     * @param baseUrl the base url of the loader.
	     * @param container the existing proton container reference.
	     */
	    static parse(config: any, baseUrl: string, container?: ProtonContainer): ProtonContainer;
	}
}

declare module "@gdk/core-pixi/assets/index" {
	export { AssetElement } from "@gdk/core-pixi/assets/assetElement";
	export { AssetStore } from "@gdk/core-pixi/assets/assetStore";
}

declare module "@gdk/core-pixi/assets/assetElement" {
	export class AssetElement<T> {
	    name: string;
	    id: string;
	    data: T;
	    type?: string;
	    /**
	     * Constructor
	     * @param name the name of the asset
	     * @param data the asset's data
	     * @param id the id of the asset. If not provided, an uuid v4 will be created
	     * @param type optional type typically used to filter assets
	     */
	    constructor(name: string, data: T, id?: string, type?: string);
	    /**
	     * Exports the asset element. This export function is needed as the
	     * user can extend the asset element to implement his own helper functions
	     */
	    export(): any;
	}
}

declare module "@gdk/core-pixi/assets/assetStore" {
	import type { Container } from "pixi.js";
	import { AssetElement } from "@gdk/core-pixi/assets/assetElement";
	import type { IAssetsRoot, IProjectContainer } from "@gdk/core-pixi/loading/model";
	import type { IStyles } from "@gdk/core-pixi/ui/baseui/text/textStyle";
	export class AssetStore {
	    static prefabs: Array<AssetElement<IProjectContainer>>;
	    static styles: Array<AssetElement<IStyles>>;
	    private static _baseUrl;
	    /**
	     * Returns the asset identified by the given Id
	     * @param id the id of the asset to find
	     */
	    static getAssetById(id: string): AssetElement<any>;
	    /**
	     * Instancate a prefab identified by the given id
	     * @param name the prefab name in order to retrieve configuration
	     * @param instance the base container instance to configure following the associated prefab configuration
	     */
	    static instanciatePrefab<T extends Container>(name: string, instance?: T): T;
	    /**
	     * Exports all the assets to an array of JSONs
	     */
	    static export(): any;
	    /**
	     * Parses the given assets to store into the assets store
	     * @param assets the assets to parse typically coming from a json project
	     */
	    static parse(assets: IAssetsRoot, baseUrl: string): void;
	    /**
	     * Clears the asset store by removing all assets
	     */
	    static clear(): void;
	}
}

declare module "@gdk/core-pixi/ui/baseui/text/textStyle" {
	import type { Font } from "opentype.js";
	export enum ELineJoin {
	    Miter = "miter",
	    Bevel = "bevel",
	    Round = "round"
	}
	export enum ELineCap {
	    Square = "square",
	    Butt = "butt",
	    Round = "round"
	}
	export enum EDisplayMode {
	    Inline = 0,
	    Block = 1
	}
	export enum EAlign {
	    Left = 0,
	    Right = 1,
	    Center = 2,
	    Justify = 3
	}
	export enum EGradientType {
	    Linear = 0,
	    LinearVertical = 1,
	    LinearHorizontal = 2,
	    Radial = 3
	}
	export interface IGradientSteps {
	    ratio: number;
	    color: string;
	}
	export enum EGradientBounds {
	    Text = 0,
	    Line = 1,
	    Word = 2,
	    Glyph = 3
	}
	export interface ILinearGradientStyle {
	    type: EGradientType;
	    bounds?: EGradientBounds;
	    angle?: number;
	    steps: IGradientSteps[];
	}
	export interface IRadialGradientStyle {
	    type: EGradientType;
	    bounds?: EGradientBounds;
	    startRatio?: number;
	    startCenter?: {
	        x: number;
	        y: number;
	    };
	    endRatio?: number;
	    endCenter?: {
	        x: number;
	        y: number;
	    };
	    steps: IGradientSteps[];
	}
	export interface ITextStyle {
	    fontName?: string;
	    fontSize?: number;
	    fill?: string | CanvasGradient | ILinearGradientStyle | IRadialGradientStyle;
	    fillStyle?: ILinearGradientStyle | IRadialGradientStyle;
	    stroke?: string | CanvasGradient | ILinearGradientStyle | IRadialGradientStyle;
	    strokeStyle?: ILinearGradientStyle | IRadialGradientStyle;
	    strokeOffsetX?: number;
	    strokeOffsetY?: number;
	    strokeWidth?: number;
	    interLine?: number;
	    shadowColor?: string;
	    shadowOffsetX?: number;
	    shadowOffsetY?: number;
	    shadowBlur?: number;
	    lineJoin?: ELineJoin;
	    lineCap?: ELineCap;
	    miterLimit?: number;
	    underlineDistance?: number;
	    underlineWeight?: number;
	}
	export interface IStyle extends ITextStyle {
	    font?: Font;
	    interactive?: boolean;
	}
	export interface IStyles {
	    default: IStyle;
	    [name: string]: IStyle;
	}
}

declare module "@gdk/core-pixi/decorators/index" {
	export * from "@gdk/core-pixi/decorators/serialize";
	export * from "@gdk/core-pixi/decorators/editor";
	export * from "@gdk/core-pixi/decorators/loader";
	export * from "@gdk/core-pixi/decorators/events";
}

declare module "@gdk/core-pixi/decorators/serialize" {
	/**
	 * Serializes the property has a point (x, y).
	 * @param sourceName optional name to retrieve when serializing/deserializing.
	 */
	export function serializeAsPoint(sourceName?: string): any;
	/**
	 * Serializes the property has a rectangme (x, y, width, height).
	 * @param sourceName optional name to retrieve when serializing/deserializing.
	 */
	export function serializeAsRectangle(sourceName?: string): any;
	/**
	 * Serializes the property has a texture (key in loader).
	 * @param sourceName optional name to retrieve when serializing/deserializing.
	 */
	export function serializeAsTexture(sourceName?: string): any;
}

declare module "@gdk/core-pixi/decorators/events" {
	import type { interaction } from "pixi.js";
	/**
	 * Tags the given class as event receiver to use @on decorators.
	 */
	export function EventReceiver(): any;
	/**
	 * Tags the given function to be called on the container receives the given event.
	 * @param eventName the name of the event to listen before calling
	 */
	export function onEvent(eventName: interaction.InteractionEventTypes | string): any;
}

declare module "@gdk/core-pixi/proton/parser/index" {
	import { EmitterParser } from "@gdk/core-pixi/proton/parser/emitterParser";
	export { EmitterParser };
}

declare module "@gdk/core-pixi/proton/parser/emitterParser" {
	import Proton from "proton-js";
	export class EmitterParser {
	    /**
	     * Parse Proton JSON
	     * @param  {Array<any>} json
	     * @returns Proton.Emitter
	     */
	    static parse(json: any[]): Proton.Emitter;
	    private static valueOrSpan;
	    private static body;
	    private static life;
	    private static mass;
	    private static position;
	    private static radius;
	    private static rate;
	    private static velocity;
	    private static alpha;
	    private static attraction;
	    private static collision;
	    private static color;
	    private static crossZone;
	    private static force;
	    private static gravity;
	    private static gravityWell;
	    private static randomDrift;
	    private static repulsion;
	    private static bancking;
	    private static rotate;
	    private static scale;
	    private static blendMode;
	}
}

declare module "@gdk/core-pixi/proton/parser2/index" {
	export * from "@gdk/core-pixi/proton/parser2/emitterParser";
	export * from "@gdk/core-pixi/proton/parser2/utils";
	export * from "@gdk/core-pixi/proton/parser2/types";
}

declare module "@gdk/core-pixi/proton/parser2/emitterParser" {
	import Proton from "proton-js";
	import type { IEmitterConfig } from "@gdk/core-pixi/proton/parser2/types";
	export class EmitterParser2 {
	    /**
	     * Parses the given emitters datas and returns an array containing the parsed emitters.
	     * @param datas the emitter datas to parse.
	     * @param system defines the reference to the particles system to configure.
	     */
	    static parse(datas: IEmitterConfig[], system?: Proton): Proton.Emitter[];
	    /**
	     * Parses the given emitter data and returns the new emitter reference.
	     * @param data the data of the emitter to parse.
	     */
	    static parseEmitter(data: IEmitterConfig, system?: Proton): Proton.Emitter;
	}
}

declare module "@gdk/core-pixi/proton/parser2/types" {
	/**
	 * Defines the definition of a span element (min, max)
	 */
	export interface ISpan {
	    Span: [number | string, number | string];
	}
	/**
	 * Defines the definition of a zone element.
	 */
	export interface IZone {
	    Zone: {
	        /**
	         * Defines the type of the zone.
	         */
	        type: string;
	        /**
	         * Defines the array of arguments for the zone.
	         */
	        args: Array<number | string>;
	    };
	}
	/**
	 * Defines the definition of a vector2d element (x, y).
	 */
	export interface IVector2D {
	    Vector2D: [number, number];
	}
	/**
	 * Defines the type of an argument that can be a number or a span.
	 */
	export type NumberOrSpan = number | ISpan;
	/**
	 * Defines the type of an argument that can be a string or a span.
	 */
	export type StringOrSpan = string | ISpan;
	/**
	 * Defines the possible options for initializes/behaviors.
	 */
	export interface IProtonConfigurators {
	    /**
	     * Defines the body of the particles.
	     * 	- texture name or array of the textures names randomly.
	     * 	- optional texture width.
	     * 	- optional texture height.
	     */
	    Body?: [string | string[], number?, number?];
	    /**
	     * Defines the radius of the particles.
	     * 	- can be a number (fixed radius).
	     * 	- can be an array of numbers or span for random radius.
	     */
	    Radius?: NumberOrSpan | NumberOrSpan[];
	    /**
	     * Defines the life of each particle.
	     * 	- can be a number (fixed life time).
	     * 	- can be an array of numbers or span for random life time.
	     */
	    Life?: number | ISpan;
	    /**
	     * Defines the rotation of each particle.
	     * 	- defines the rotation style (Velocity)
	     * 	- defines the rotation span (numbers)
	     * 	- defines the style (none or to)
	     */
	    Rotate?: [ISpan?, ISpan?, string?];
	    /**
	     * Defines the scale of each particle.
	     * 	- can be a number for fixed scale
	     * 	- can be an array of numbers or span for random scale.
	     */
	    Scale?: number | NumberOrSpan[];
	    /**
	     * Defines the color of each particle.
	     *  - can be a string or span for single color
	     *  - can be an array of string or span to random colors.
	     * 		- Color1 (string or span)
	     * 		- Color2 (string or span)
	     * 		- life (number)
	     * 		- easing (string)
	     */
	    Color?: StringOrSpan | [StringOrSpan, StringOrSpan?, number?, string?];
	    /**
	     * Defines the velocity of each particle.
	     * 	- can be a number of span
	     * 	- can be an array of arguments:
	     * 		- nuùber or span (rPan)
	     * 		- number of span (thaPan
	     * 		- type of velocity ("polar" or "vector")
	     */
	    Velocity?: NumberOrSpan | [NumberOrSpan, NumberOrSpan?, string?];
	    /**
	     * Defines the position of each particle.
	     * 	- takes a zone as parameter.
	     */
	    Position?: IZone;
	    /**
	     * Defines the alpha of each particle.
	     * 	- start alpha
	     * 	- end alpha
	     */
	    Alpha?: [NumberOrSpan?, NumberOrSpan?];
	    /**
	     * Defines the force of particles.
	     */
	    Force?: [number, number];
	    /**
	     * Defines the gravity value.
	     */
	    Gravity?: number;
	    /**
	     * Defines the attraction.
	     * 	- target position
	     * 	- force
	     * 	- radius
	     */
	    Attraction?: [IVector2D, number?, number?];
	    /**
	     * Custom configuration to customize particle.
	     */
	    [index: string]: any;
	}
	/**
	 * Defines the overall configuration type of an emitter.
	 */
	export interface IEmitterConfig {
	    /**
	     * Defines the id of the emitter.
	     */
	    id?: string;
	    /**
	     * Defines the name of the emitter.
	     */
	    name?: string;
	    /**
	     * Defines the rate of the emiiter. Can be mixed with numbers and spans.
	     */
	    Rate: number | [NumberOrSpan, NumberOrSpan];
	    /**
	     * List of available initializers. Initializes are functions called each time
	     * a particle is alive.
	     */
	    initializers: {
	        [key in keyof IProtonConfigurators]?: IProtonConfigurators[key];
	    };
	    /**
	     * List of available behaviors applied each frame by particle being animated by the
	     * emitter.
	     */
	    behaviors: {
	        [key in keyof IProtonConfigurators]?: IProtonConfigurators[key];
	    };
	}
}

declare module "@gdk/core-pixi/proton/parser2/utils" {
	import Proton from "proton-js";
	/**
	 * Defines the signature of a custom function used by the emitter parser.
	 */
	export type CustomProtonFunction = (...args: any[]) => any;
	export class ProtonUtils {
	    /**
	     * Defines all the available custom functions used to return custom components for the current emitter being parsed.
	     */
	    static readonly customFunctions: {
	        [propType: string]: CustomProtonFunction;
	    };
	    /**
	     * Adds a the given custom function used to parse custom components for the current emitter being parsed.
	     * @param propertyType the property type to check before calling the given custom function.
	     * @param fn the function to add to the available custom functions.
	     * @returns true if added, false if already exists.
	     * @see .customFunctions
	     */
	    static addCustomFunction(propertyType: string, fn: CustomProtonFunction): boolean;
	    /**
	     * Removes the given function from the custom functions used while parsing emitter.
	     * @param propertyType the function to remove from the custom functions.
	     * @returns true if removed, false if not found.
	     */
	    static removeCustomFunction(propertyType: string): boolean;
	    /**
	     * Returns
	     * @param propertyType the property type (i.e Span, Time, etc.) to build.
	     * @param args the arguments of the property.
	     */
	    static getProperty<T>(propertyType: string, args: any): T;
	    /**
	     * Returns the value of the given arguments (string, number, object or array).
	     * @param args the arguments of the property.
	     */
	    static getValue<T>(args: any): T;
	    /**
	     * Returns the object according to the given arguments.
	     * @param args the arguments of the property.
	     */
	    static getObject<T>(args: any): T;
	    /**
	     * Returns a Proton Span according to the given span arguments.
	     * @param args the arguments of the span (array or number or object).
	     */
	    static getSpan(args: any): Proton.Span;
	    /**
	     * Overrides the Proton.Util.setSpanValue function of Proton to enable b and c to be equal to 0.
	     */
	    private static _setSpanValue;
	}
}

declare module "@gdk/core-pixi/spine/index" {
	import "pixi-spine";
	export { Timeline, ITimelineOptions } from "@gdk/core-pixi/spine/timeline";
	export { ITimelineAnimationOptions, TimelineAnimation } from "@gdk/core-pixi/spine/timelineAnimation";
	export { TimelineEvent, ITimelineCallback, ETimelineEventsType, TimelineStartEvent, TimelineCompleteEvent, TimelineRepeatEvent, TimelineReverseCompleteEvent, TimelineUpdateEvent, TimelineAnimationEvent, TimelinePlayEvent, TimelinePauseEvent, TimelineResumeEvent, } from "@gdk/core-pixi/spine/timelineEvents";
	export { CustomAttachement } from "@gdk/core-pixi/spine/customAttachement";
}

declare module "@gdk/core-pixi/spine/timeline" {
	import { spine } from "pixi.js";
	import { TimelineMax } from "gsap";
	import type { Container, loaders, DisplayObject, interaction, Rectangle } from "pixi.js";
	import { TimelineAnimation } from "@gdk/core-pixi/spine/timelineAnimation";
	import type { TimelineEvent } from "@gdk/core-pixi/spine/timelineEvents";
	import type { ITimelineAnimationOptions } from "@gdk/core-pixi/spine/timelineAnimation";
	/**
	 * Represents timeline options
	 */
	export interface ITimelineOptions {
	    assetId: string;
	    ressource?: loaders.Resource;
	    skin?: string;
	    x?: number;
	    y?: number;
	    pauseOnAnimationEnd?: boolean;
	    paused?: boolean;
	    repeat?: number;
	    loop?: boolean;
	    yoyo?: boolean;
	    reverse?: boolean;
	    timeScale?: number;
	    delay?: number;
	    repeatDelay?: number;
	    animations?: ITimelineAnimationOptions | ITimelineAnimationOptions[];
	}
	export interface IInteractionEventProxy {
	    event: interaction.InteractionEventTypes;
	    function: (e: interaction.InteractionEvent) => void;
	    context?: any;
	}
	/**
	 * Represents timeline types
	 */
	export enum ETimelineType {
	    Timeline = "timeline",
	    Animation = "animation"
	}
	export class Timeline extends spine.Spine {
	    static MIN_UPDATE_TIME: number;
	    timeline: TimelineMax;
	    setupBound: Rectangle;
	    label: string;
	    pauseOnAnimationEnd: boolean;
	    animations: TimelineAnimation[];
	    parameters: ITimelineOptions;
	    availableAnimations: string[];
	    private _currentAnimation;
	    private previousTimeScale;
	    private currentHitArea;
	    private hitAreaContainers;
	    private _boundingBox;
	    private _previousTime;
	    private callbacks;
	    private hitAreasShapes;
	    private _spineHitArea;
	    static eventNamespace: string;
	    /**
	     * DEPRECATED : RETRO COMPATIBILITY ONLY, NOT NECESSARY ANYMORE !
	     */
	    static preloadedAtlasFinder(): (resource: loaders.Resource, next: () => void) => void;
	    /**
	     * Constructor
	     * @param options the timeline options
	     */
	    constructor(options: ITimelineOptions);
	    /**
	     * remove all callback listeners remove all animations and reset timeline.
	     */
	    clearTimeline(): void;
	    /**
	     * Remove all callback listeners.
	     */
	    clearCallbacks(): void;
	    /**
	     * will test if the animation exist in the spine file
	     * @param animationName
	     */
	    animationExist(animationName: string): boolean;
	    /**
	     * Clear then add animation(s) to the timeline.
	     */
	    setAnimations(animations?: ITimelineAnimationOptions | ITimelineAnimationOptions[]): void;
	    private listAvaibleAnimations;
	    /**
	     * Create an animation from options
	     * @param options the animation options
	     */
	    createAnimationFromOptions(options: ITimelineAnimationOptions): TimelineAnimation;
	    /**
	     * Add an animation at the end of the timeline
	     * @param animationOrOptions: the animation animation or animation options
	     */
	    pushAnimation(animationOrOptions: TimelineAnimation | ITimelineAnimationOptions): void;
	    /**
	     * Insert an animation in the timeline
	     * @param index: the index to insert at
	     * @param animation: the timeline animation
	     */
	    insertAnimation(index: number, animation: TimelineAnimation): void;
	    /**
	     * Create a timeline from options
	     * @param options: the timeline options
	     */
	    createTimeline(options: ITimelineOptions): void;
	    /**
	     * Set the SpineTimelineAnimation to play
	     * @param animation: the animation to set
	     */
	    set currentAnimation(animation: TimelineAnimation);
	    /**
	     * Returns the TimelineAnimation witch is currently playing.
	     */
	    get currentAnimation(): TimelineAnimation;
	    /**
	     * Returns the TimelineAnimation witch will be the next one to play.
	     */
	    get nextAnimation(): TimelineAnimation;
	    /**
	     * Returns the TimelineAnimation witch was the previous one to play
	     */
	    get previousAnimation(): TimelineAnimation;
	    /**
	     * Returns a SpineTimelineAnimation by it's index.
	     */
	    getAnimation(index: number): TimelineAnimation;
	    /**
	     * define Slot content (attachement) by name
	     */
	    setSlotAttachementByName(slotName: string, displayObject?: DisplayObject): boolean;
	    /**
	     * define Slot content (attachement) by id
	     */
	    setSlotAttachementByIndex(slotIndex: number, displayObject?: DisplayObject): boolean;
	    private findAttachementInSkins;
	    /**
	     * Returns a slotContainer by it's index.
	     */
	    getSlotContainerByIndex(index: number): Container;
	    /**
	     * Returns a slotContainer by it's name.
	     */
	    getSlotContainerByName(name: string): Container;
	    /**
	     * will return the animation with provided label.
	     * @param label the label of the animation we are looking for.
	     */
	    getAnimationByLabel(label: string): TimelineAnimation;
	    /**
	     * will return all animations with provided name.
	     * @param name the name of the animations we are looking for.
	     */
	    getAnimationsByName(name: string): TimelineAnimation[];
	    /**
	     * Add a callback for all event
	     */
	    onAll(callback: (e?: TimelineEvent) => void): Timeline;
	    /**
	     * Add a callback for Animation Event event
	     */
	    onAnimationEvent(callback: (e?: TimelineEvent) => void): Timeline;
	    /**
	     * Add a callback for Timeline Play event
	     */
	    onPlay(callback: (e?: TimelineEvent) => void): Timeline;
	    /**
	     * Add a callback for Timeline Pause event
	     */
	    onPause(callback: (e?: TimelineEvent) => void): Timeline;
	    /**
	     * Add a callback for Timeline Resume event
	     */
	    onResume(callback: (e?: TimelineEvent) => void): Timeline;
	    /**
	     * Add a callback for Timeline Start event
	     */
	    onStart(callback: (e?: TimelineEvent) => void): Timeline;
	    /**
	     * Add a callback for Timeline Complete event
	     */
	    onComplete(callback: (e?: TimelineEvent) => void): Timeline;
	    /**
	     * Add a callback for Timeline Repeat event
	     */
	    onRepeat(callback: (e?: TimelineEvent) => void): Timeline;
	    /**
	     * Add a callback for Timeline Update event
	     */
	    onUpdate(callback: (e?: TimelineEvent) => void): Timeline;
	    /**
	     * Add a callback for Timeline Reverse Complete event
	     */
	    onReverseComplete(callback: () => void): Timeline;
	    /**
	     * Add a callback for each Animation Start event
	     */
	    onAnimationStart(callback: (e?: TimelineEvent) => void): Timeline;
	    /**
	     * Add a callback for Timeline Repeat event
	     */
	    onAnimationLoop(callback: (e?: TimelineEvent) => void): Timeline;
	    /**
	     * Add a callback for Timeline Repeat event
	     */
	    onAnimationReverseLoop(callback: (e?: TimelineEvent) => void): Timeline;
	    /**
	     * Add a callback for each Animation Complete event
	     */
	    onAnimationComplete(callback: (e?: TimelineEvent) => void): Timeline;
	    /**
	     * Add a callback for each Animation Repeat event
	     */
	    onAnimationRepeat(callback: (e?: TimelineEvent) => void): Timeline;
	    /**
	     * Add a callback for each Animation Reverse Complete event
	     */
	    onAnimationReverseComplete(callback: (e?: TimelineEvent) => void): Timeline;
	    /**
	     * Play timeline.
	     * @param from the time (or label) from which the animation should begin playing
	     * (if none is defined, it will begin playing from wherever the playhead currently is).
	     * @param supressEvent if true (the default), no events or callbacks will be triggered
	     * when the playhead moves to the new position defined in the from parameter.
	     */
	    play(from?: number | string, supressEvent?: boolean): void;
	    /**
	     * Play next animation in timeline.
	     * @param toLabel if true (false is the default), will go directly to the next label
	     * @param supressEvent if true (the default), no events or callbacks will be triggered
	     * when the playhead moves to the new position defined in the from parameter.
	     */
	    playNext(toLabel?: boolean, supressEvent?: boolean): void;
	    /**
	     * Play previous animation in timeline.
	     * @param toLabel if true (false is the default), will go directly to the next label
	     * @param supressEvent if true (the default), no events or callbacks will be triggered
	     * when the playhead moves to the new position defined in the from parameter.
	     */
	    playPrevious(toLabel?: boolean, supressEvent?: boolean): void;
	    /**
	     * Reverse timeline.
	     * @param from the time (or label) from which the animation should begin playing
	     * (if none is defined, it will begin playing from wherever the playhead currently is).
	     * @param supressEvent if true (the default), no events or callbacks will be triggered
	     * when the playhead moves to the new position defined in the from parameter.
	     */
	    reverse(from?: number | string, supressEvent?: boolean): void;
	    /**
	     * Pause timeline.
	     * @param easeTime time to actualy get paused.
	     */
	    pause(at?: number | string, supressEvent?: boolean): void;
	    /**
	     * Resumes playing without altering direction (forward or reversed).
	     * @param easeTime time to actualy get resumed.
	     */
	    resume(from?: number | string, supressEvent?: boolean): void;
	    /**
	     * Set the timeline paused status.
	     * @param position jumps to a specific time (or label) without affecting
	     * whether or not the instance is paused or reversed.
	     * @param supressEvent if true (the default), no events or callbacks will be triggered
	     * when the playhead moves to the new position defined in the from parameter.
	     */
	    seek(position: string | number, supressEvent?: boolean): void;
	    /**
	     * Toogle between play and pause status.
	     * @param easeTime time to actualy get toogled.
	     */
	    tooglePlay(from?: number | string, supressEvent?: boolean): void;
	    /**
	     * Returns the timeline paused status.
	     */
	    get paused(): boolean;
	    /**
	     * Sets the timeline timescale.
	     */
	    set timeScale(value: number);
	    /**
	     * Returns the timeline timescale.
	     */
	    get timeScale(): number;
	    /**
	     * Returns the timeline type
	     */
	    get type(): ETimelineType;
	    /**
	     * will set the skeletton skin by it's name (if that skin exist)
	     * proxy for : skeleton.setSkin(null) && skeleton.setSkinByName(name)
	     * @param name
	     */
	    setSkinByName(name: string): void;
	    /**
	     * will trim the provided string to find the label
	     * @param str the string from witch you need the label
	     */
	    private extractLabel;
	    /**
	     * will try to find and set the currentanimation from provided number or string
	     */
	    private setCurrentAnimationFrom;
	    /**
	     * Check if the coordinates are contained in at least one of Spine hitAreas.
	     * @param x coordinate
	     * @param y coordinate
	     * @returns a boolean
	     */
	    isContainedInAnimationHitAreas(x: number, y: number): boolean;
	    private addAnimationListeners;
	    /**
	     * (internal) will replace the containsPoint Method
	     * by one wich will return false if there is spineHitArea
	     */
	    private containsPointOverride;
	    private updateBoundingBoxes;
	    private newHitArea;
	    private createShape;
	    private float32ArrayToPolygon;
	    private clearAnimationsCallbacks;
	    private initViewport;
	    private onTimelineUpdate;
	    private emitCallback;
	    private easeTo;
	    /**
	     * if set to true, this will display the bounds, the center, the pivot and all hitAreas.
	     */
	    set showBoundingBox(value: boolean);
	    get showBoundingBox(): boolean;
	    get spineHitArea(): boolean;
	    set spineHitArea(value: boolean);
	    /**
	     * Pause & destrop timeline
	     */
	    destroy(): void;
	    /**
	     * Exports the timeline
	     */
	    export(): any;
	    /**
	     * Parses the textfield
	     * @param config the serialized data
	     * @param baseUrl the base url of the loader
	     */
	    static parse(config: any, baseUrl: string, timeline?: Timeline): Timeline;
	    /**
	     * Configures the slot containers of the given timeline. I.E: import custom children of slot containers
	     * @param config the serialized data
	     * @param baseUrl the base url of the loader
	     * @param timeline the timeline object containing the slots to configure
	     */
	    static parseSlotContainers(config: any, baseUrl: string, timeline: Timeline): void;
	}
}

declare module "@gdk/core-pixi/spine/timelineAnimation" {
	import "pixi-spine";
	import { TweenMax } from "gsap";
	import type { spine } from "pixi.js";
	import { ETimelineType } from "@gdk/core-pixi/spine/timeline";
	import type { TimelineEvent } from "@gdk/core-pixi/spine/timelineEvents";
	import type { Timeline } from "@gdk/core-pixi/spine/timeline";
	/**
	 * Represents the timeline animation options
	 */
	export interface ITimelineAnimationOptions {
	    name: string;
	    label?: string;
	    layer?: number;
	    delay?: number;
	    repeatDelay?: number;
	    loop?: boolean;
	    repeat?: number;
	    timeScale?: number;
	    paused?: boolean;
	    pauseAtEnd?: boolean;
	}
	export class TimelineAnimation {
	    name: string;
	    label: string;
	    entry: spine.core.TrackEntry;
	    tween: TweenMax;
	    layer: number;
	    repeat: number;
	    delay: number;
	    loop: boolean;
	    repeatDelay: number;
	    pauseAtEnd: boolean;
	    events: spine.core.Event[];
	    startTime: number;
	    endTime: number;
	    private _index;
	    private _animation;
	    private _timeline;
	    private _time;
	    private _callbacks;
	    /**
	     * Constructor
	     * @param timeline the parent timeline
	     * @param options options for this animation
	     */
	    constructor(timeline: Timeline, options: ITimelineAnimationOptions);
	    /**
	     * Configures the timeline
	     * @param options options for this animation
	     */
	    configure(options: ITimelineAnimationOptions): void;
	    /**
	     * Remove all callback listeners
	     */
	    clearCallbacks(): void;
	    /**
	     * Returns the current time
	     */
	    get time(): number;
	    /**
	     * Sets the current time
	     * @param value: the current time in seconds
	     */
	    set time(value: number);
	    /**
	     * Set index value
	     * @param value number to set as index
	     */
	    set index(value: number);
	    /**
	     * Returns the current time
	     */
	    get index(): number;
	    /**
	     * Returns the animation timeScale
	     */
	    get timeScale(): number;
	    /**
	     * Sets the animation timeScale
	     * @param value: the timeScale ratio
	     */
	    set timeScale(value: number);
	    /**
	     * Returns the timeline type
	     */
	    get type(): ETimelineType;
	    /**
	     * Add a callback for that Animation
	     * @param callback the callback to add
	     */
	    onEvent(callback: (e?: TimelineEvent) => void): TimelineAnimation;
	    /**
	     * Add a callback for that Animation Start event.
	     * @param callback the callback to add
	     */
	    onStart(callback: (e?: TimelineEvent) => void): TimelineAnimation;
	    /**
	     * Add a callback for that Animation Complete event.
	     * @param callback the callback to add
	     */
	    onComplete(callback: (e?: TimelineEvent) => void): TimelineAnimation;
	    /**
	     * Add a callback for that Animation Update event.
	     * @param callback the callback to add
	     */
	    onRepeat(callback: (e?: TimelineEvent) => void): TimelineAnimation;
	    /**
	     * Add a callback for that Animation Loop event.
	     * @param callback the callback to add
	     */
	    onLoop(callback: (e?: TimelineEvent) => void): TimelineAnimation;
	    /**
	     * Add a callback for that Animation Reverse Loop event.
	     * @param callback the callback to add
	     */
	    onReverseLoop(callback: (e?: TimelineEvent) => void): TimelineAnimation;
	    /**
	     * Add a callback for that Animation Update event.
	     * @param callback the callback to add
	     */
	    onUpdate(callback: (e?: TimelineEvent) => void): TimelineAnimation;
	    /**
	     * Add a callback for that Animation Reverse Complete event.
	     * @param callback the callback to add
	     */
	    onReverseComplete(callback: (e?: TimelineEvent) => void): TimelineAnimation;
	    private addEventCallback;
	    private _emitEvent;
	    /**
	     * Exports TimelineAnimation.
	     */
	    export(): ITimelineAnimationOptions;
	}
}

declare module "@gdk/core-pixi/spine/timelineEvents" {
	import type { Timeline, ETimelineType } from "@gdk/core-pixi/spine/timeline";
	import type { TimelineAnimation } from "@gdk/core-pixi/spine/timelineAnimation";
	/**
	 * All enum types for timeline events
	 */
	export enum ETimelineEventsType {
	    All = "all",
	    Start = "start",
	    Play = "play",
	    Pause = "pause",
	    Resume = "resume",
	    Complete = "complete",
	    Update = "update",
	    Repeat = "repeat",
	    Loop = "loop",
	    ReversePlay = "reverse_play",
	    ReverseLoop = "reverse_loop",
	    ReverseComplete = "reverse_complete",
	    AnimationEvent = "event"
	}
	/**
	 * Represents a timeline callback
	 */
	export interface ITimelineCallback {
	    type: ETimelineEventsType;
	    emitter: ETimelineType;
	    callback: (e?: TimelineEvent) => void;
	}
	export class TimelineEvent {
	    private _emitter;
	    private _type;
	    private _params?;
	    /**
	     * Constructor
	     * @param emitter the event emitter
	     * @param type the event type
	     * @param params the event's params
	     */
	    constructor(emitter: TimelineAnimation | Timeline, type: ETimelineEventsType, params?: any);
	    /**
	     * Returns the event type
	     */
	    get type(): ETimelineEventsType;
	    /**
	     * Returns the emitter
	     */
	    get emitter(): TimelineAnimation | Timeline;
	    /**
	     * Returns the event params
	     */
	    get params(): any;
	    /**
	     * Format toString() for ease of use
	     */
	    toString(): {
	        emitter: TimelineAnimation | Timeline;
	        type: ETimelineEventsType;
	        params?: any;
	    };
	}
	export class TimelineCompleteEvent extends TimelineEvent {
	    constructor(emitter: Timeline | TimelineAnimation, params?: any);
	}
	export class TimelineStartEvent extends TimelineEvent {
	    constructor(emitter: Timeline | TimelineAnimation, params?: any);
	}
	export class TimelineRepeatEvent extends TimelineEvent {
	    constructor(emitter: Timeline | TimelineAnimation, params?: any);
	}
	export class TimelineLoopEvent extends TimelineEvent {
	    constructor(emitter: Timeline | TimelineAnimation, params?: any);
	}
	export class TimelineReverseLoopEvent extends TimelineEvent {
	    constructor(emitter: Timeline | TimelineAnimation, params?: any);
	}
	export class TimelineReverseCompleteEvent extends TimelineEvent {
	    constructor(emitter: Timeline | TimelineAnimation, params?: any);
	}
	export class TimelineUpdateEvent extends TimelineEvent {
	    constructor(emitter: Timeline | TimelineAnimation, params?: any);
	}
	export class TimelinePlayEvent extends TimelineEvent {
	    constructor(emitter: Timeline | TimelineAnimation, params?: any);
	}
	export class TimelineReversePlayEvent extends TimelineEvent {
	    constructor(emitter: Timeline | TimelineAnimation, params?: any);
	}
	export class TimelinePauseEvent extends TimelineEvent {
	    constructor(emitter: Timeline | TimelineAnimation, params?: any);
	}
	export class TimelineResumeEvent extends TimelineEvent {
	    constructor(emitter: Timeline | TimelineAnimation, params?: any);
	}
	export class TimelineAnimationEvent extends TimelineEvent {
	    constructor(emitter: Timeline | TimelineAnimation, params?: any);
	}
}

declare module "@gdk/core-pixi/spine/customAttachement" {
	import { Container } from "pixi.js";
	export class CustomAttachement extends Container {
	    /**
	     * update tint on each children
	     */
	    updateChildren(): void;
	}
}

declare module "@gdk/core-pixi/spine2/index" {
	export * from "@gdk/core-pixi/spine2/timeline";
	export * from "@gdk/core-pixi/spine2/button";
	export * from "@gdk/core-pixi/spine2/pushButton";
	export * from "@gdk/core-pixi/spine2/toggleButton";
	export * from "@gdk/core-pixi/spine2/radioButton";
	export * from "@gdk/core-pixi/spine2/checkButton";
	export * from "@gdk/core-pixi/spine2/logo";
	export * from "@gdk/core-pixi/spine2/types";
}

declare module "@gdk/core-pixi/spine2/timeline" {
	import { spine } from "pixi.js";
	import { TimelineMax } from "gsap";
	import type { Container, WebGLRenderer, CanvasRenderer, Rectangle } from "pixi.js";
	import type { ISpineTimelineSequence } from "@gdk/core-pixi/spine2/types";
	/**
	 * @experimental
	 * Defines the main spine timeline class used to create, and play user-defined sequences containing
	 * all the available animations of the current spine.
	 */
	export class SpineTimeline extends spine.Spine {
	    /**
	     * Defines the minimum update time to apply transforms on spines skeletons.
	     */
	    static minUpdateTime: number;
	    /**
	     * GSAP TimelineMax reference used to control the overall animation instead of using the pixi.js ticker.
	     */
	    timelineMax: TimelineMax;
	    /**
	     * Keep asset id used to retrieve the spine datas in the file loader.
	     */
	    readonly assetId: string;
	    /**
	     * Sequences dictionary. The SpineTimeline is set to work with sequences. Each sequence contains a list of animations
	     * and can be looped. Animations are not intended to be looped but the sequence itself is done to.
	     * @example myTimeline.addSequence("mySequence", { loop: false, animations: [{ name: "enter" }, { name: "idle", repeatCount: 2 }] });
	     * @example myTimeline.play("mySequence", "enter"); // Plays mySequence starting from "enter".
	     * @example myTimeline.play("mySequence"); // Plays mySequence starting from the first animation of the sequence (here "enter").
	     * @example myTimeline.play(); // Plays the "default" sequence starting from the first animation of the default sequence.
	     */
	    sequences: {
	        [index: string]: ISpineTimelineSequence;
	    };
	    private _currentTime;
	    private _lastTime;
	    private _currentSequence;
	    private _currentAnimation;
	    private _needsUpdate;
	    private _stopped;
	    private _isDestroyed;
	    private _skeletonBounds;
	    private _setUpBounds;
	    private _stopCallbackRef;
	    private _resolveCompleteFn;
	    /**
	     * Constructor.
	     * @param assetId the id of the spine datas in the core-loader.
	     */
	    constructor(assetId: string);
	    /**
	     * Inits the timeline.
	     */
	    private _initSpine;
	    /**
	     * Creates the TimelineMax instance.
	     */
	    protected createTimeline(): void;
	    /**
	     * Renders the scratch using the WebGL renderer.
	     * @param renderer the webgl renderer reference.
	     */
	    renderWebGL(renderer: WebGLRenderer): void;
	    /**
	     * Renders the scratch using the canvas renderer.
	     * @param renderer the canvas renderer reference.
	     */
	    renderCanvas(renderer: CanvasRenderer): void;
	    /**
	     * Syncs the pixi-spine skinning transforms with the current timeline's progress.
	     * @param force specifies if the sync should be forced or tested before applied.
	     */
	    protected syncSkinning(force?: boolean, dt?: number): void;
	    /**
	     * Adds a new sequence to the sequences dictionary.
	     * @param sequenceName the name (identifier) of the sequence to add.
	     * @param animations the array of animations available in the sequence being added.
	     * @see .sequences
	     */
	    addSequence(sequenceName: string, sequence: ISpineTimelineSequence): void;
	    /**
	     * Gets the sequence identified by the given name.
	     * @param sequenceName the name of the sequence to retrieve.
	     */
	    getSequence(sequenceName: string): ISpineTimelineSequence;
	    /**
	     * Removes the sequence identified by the given name.
	     * @param sequenceName the name of the sequence to remove.
	     */
	    removeSequence(sequenceName: string): void;
	    /**
	     * Gets the current sequence being used to play its animations.
	     */
	    get currentSequence(): string;
	    /**
	     * Gets the current animation being played in the current sequence.
	     */
	    get currentAnimation(): string;
	    /**
	     * Gets the current timescale of the TimelineMax. Default is 1.
	     */
	    get timeScale(): number;
	    /**
	     * Sets the current timescale of the TimelineMax. Default is 1.
	     */
	    set timeScale(scale: number);
	    /**
	     * Stops the timeline
	     */
	    stop(): void;
	    /**
	     * Moves the timeline's track head to the given position.
	     * @param position the position in terms of seconds.
	     */
	    seek(position: number | string): void;
	    /**
	     * Plays a direct animation without taking care of the current timeline configuration.
	     * @param animationName the name of the animation to play.
	     * @param loop wether or not the animation should be played looped.
	     * @param reversed defines wether or not the animation is played in reversed mode.
	     * @returns a resolved promise in case of looping. Else, a promise resolved when animation finished.
	     */
	    playDirect(animationName: string, loop?: boolean, reversed?: boolean): Promise<void>;
	    /**
	     * Plays the timeline.
	     * @param sequenceName the name of the sequence to play. Default value is "default".
	     * @param from the name of the animation in sequence where to start the timeline.
	     * @param reversed defines wether or not the animation is played in reversed mode.
	     */
	    play(sequenceName?: string, from?: string, reversed?: boolean): Promise<void>;
	    /**
	     * Reverses the currently playing timeline. If the timeline is paused, it is automatically playing in the reversed mode.
	     * @example typically used when the game needs to rewind an animation linked to an action.
	     */
	    reverse(): void;
	    /**
	     * Sets wether or not the timeline is reversed.
	     * @param reversed a boolean indicating that the timeline is reversed or not.
	     */
	    reversed(reversed: boolean): void;
	    /**
	     * Pauses the timeline.
	     */
	    pause(): void;
	    /**
	     * Resumes the timeline.
	     */
	    resume(): void;
	    /**
	     * Sets the spine to the given animation default pose.
	     * @param sequenceName the name of the sequence containing the given animation.
	     * @param animationName the animation to set its default pose.
	     */
	    setPose(sequenceName?: string, animationName?: string): void;
	    /**
	     * Gets the original bounds computed while instantiating spine timeline.
	     */
	    get setupBounds(): Rectangle;
	    /**
	     * Resets the current spine to the setup bounds.
	     */
	    resetToSetupBounds(): void;
	    /**
	     * Sets the given skin to the spine.
	     * @param skinName the name of the skin to set.
	     */
	    setSkinByName(skinName: string): void;
	    /**
	     * Returns wether or not the current spine has a skin identified by the given name.
	     * @param skinName the name of the skin to test if exists.
	     */
	    hasSkin(skinName: string): boolean;
	    /**
	     * Returns the first slot identified by the given name.
	     * @param slotName the name of the slot to find.
	     */
	    getSlotContainerByName(slotName: string): Container;
	    /**
	     * Destroys the spine timeline. This must be overriden as we need to kill some resources such
	     * as the timeline etc.
	     */
	    destroy(): void;
	    /**
	     * Destroys the timeline.
	     */
	    private _destroy;
	    /**
	     * Updates the spine's tracks and the spine's transforms.
	     * @param force specifies if the tracks and transforms should be updated in any case.
	     * @param dt specifies the delta time between the previous frame and current frame. Used to hack pixi-spine and force update using an Epsilon.
	     */
	    private _updateTracksAndTransforms;
	    /**
	     * Creates all the tween max laels.
	     * @param sequenceName the name of the sequence being used.
	     */
	    private _createLabelsFromSequence;
	    /**
	     * Starts the given animation.
	     */
	    private _startAnimation;
	    /**
	     * Called on a sequence has been complete (normal or reverse).
	     */
	    private _onSequenceComplete;
	    /**
	     * Called on an animation finished.
	     */
	    private _onAnimationComplete;
	    /**
	     * Stops the timeline and tracks, notify awaiters and clear waiting events.
	     */
	    private _stop;
	    /**
	     * Returns the name of the current animation being mounted in the state.
	     */
	    private _getMountedStateAnimation;
	    /**
	     * Removes the current skin's attachment before the new one is applied.
	     * This function exists only because some spines don't really use the skin system and go further by using
	     * empty slots etc.
	     */
	    private _removeCurrentSkin;
	    /**
	     * Checks wether or not the given sequence exists. If doesn't exists, the error is logged and returns false.
	     * Else, retruns true.
	     * @param sequenceName the name of the sequence to check if exists.
	     */
	    private _checkSequence;
	    /**
	     * Updates the hit areas to determine if the skeleton bounds should be used or not.
	     */
	    private _updateHitArea;
	    /**
	     * Exports the spine timeline.
	     */
	    export(): any;
	    /**
	     * Parses the spine timeline according to the given configuration.
	     * @param config the serialized data.
	     * @param baseUrl the base url of the loader.
	     * @param timeline the existing timeline reference.
	     */
	    static parse(config: any, baseUrl: string, timeline?: SpineTimeline): SpineTimeline;
	}
}

declare module "@gdk/core-pixi/spine2/types" {
	import type { Ease } from "gsap";
	/**
	 * @experimental
	 * Defines all the available events sent from the instantiated
	 * pineTimeline objects.
	 */
	export enum ESpineTimelineEvent {
	    Start = "start",
	    StartAnimation = "animationStart",
	    Complete = "complete",
	    AnimationComplete = "animationComplete",
	    Pause = "pause",
	    Stop = "stop",
	    Resume = "resume",
	    Repeat = "repeat",
	    Event = "event"
	}
	/**
	 * @experimental
	 * Defines all the available properties that define an animation playable
	 * by the SpineTimeline instances.
	 */
	export interface ISpineTimelineAnimation {
	    /**
	     * The name of the animation in the spine datas.
	     */
	    name: string;
	    /**
	     * Number of times the animation will be repreated. Default is 0.
	     */
	    repeat?: number;
	    /**
	     * Delay in terms of seconds before the animation repeats.
	     */
	    repeatDelay?: number;
	    /**
	     * Delay in term of seconds where the animation will start.
	     */
	    delay?: number;
	    /**
	     * Optional easing function that can be used while playing the animation.
	     */
	    ease?: Ease;
	    /**
	     * Defines wether or not the animation should be inverted (from animation duration to 0).
	     * @example typically used for example: "enter", "idle", "inveted enter".
	     */
	    inverted?: boolean;
	    /**
	     * Optional custom label to call myTimeline.play("myCustomLabel");
	     */
	    label?: string;
	}
	/**
	 * @experimental
	 * Defines the properties available that define a sequence playable by
	 * the SpineTimeline instances.
	 * @example: myTimeline.addSequence("sequenceName", { animations: [...], loop: true });
	 */
	export interface ISpineTimelineSequence {
	    /**
	     * The array of animations available in the sequence. All these animatons will be played in the order.
	     */
	    animations: ISpineTimelineAnimation[];
	    /**
	     * If the sequence should be looped. Default value is "false".
	     */
	    loop?: boolean;
	    /**
	     * Sets or gets wether or not the sequence should be exported. Typically useful for specialized
	     * components like SpineButton to don't export custom "events" sequence.
	     */
	    doNotExport?: boolean;
	}
}

declare module "@gdk/core-pixi/spine2/button" {
	import type { ITrackableObject } from "@gdk/core";
	import { SpineTimeline } from "@gdk/core-pixi/spine2/timeline";
	import { TextField } from "@gdk/core-pixi/ui/index";
	import type { IStyles } from "@gdk/core-pixi/ui/index";
	import type { ISpineTimelineAnimation } from "@gdk/core-pixi/spine2/types";
	/**
	 * @experimental
	 * Defines an object defining a range in interval [min, max]
	 */
	export interface ISpineTimelineButtonRange {
	    /**
	     * The minimum value of the range.
	     */
	    min: number;
	    /**
	     * The maximum value of the range.
	     */
	    max: number;
	}
	/**
	 * @experimental
	 * Defines all possible animations for spine button and the related names.
	 */
	export interface ISpineTimelineButtonAnimations {
	    enter?: string;
	    exit?: string;
	    disable?: string;
	    disableLoop?: string;
	    idle?: string;
	    idleLoop?: string;
	    over?: string;
	    overLoop?: string;
	    out?: string;
	    down?: string;
	    downLoop?: string;
	    up?: string;
	    callToAction?: string;
	}
	/**
	 * @experimental
	 * Defines the new SpineButton that uses the newly created SpineTimeline features.
	 * This class implements the features of a simple/classic button. See SpineTimelinePushButton etc.
	 * for more advanced buttons.
	 */
	export class SpineTimelineButton extends SpineTimeline implements ITrackableObject {
	    /**
	     * Defines the optional name of the object to be tracked.
	     * If unset, a default value will be taken by the tracker. For example,
	     * the name of the object (button, scratch, etc.).
	     */
	    trackingName: string;
	    /**
	     * Labels dictionary.
	     */
	    labels: {
	        [index: string]: TextField;
	    };
	    /**
	     * Styles object used by the labels to define the labels styles.
	     */
	    styles: IStyles;
	    /**
	     * Sets or gets wether or not looping on "idleLoop" is required.
	     */
	    loopOnIdle: boolean;
	    /**
	     * Sets or gets wether or not looping on "overLoop" is required.
	     */
	    loopOnOver: boolean;
	    /**
	     * Sets or gets wether or not looping on "downLoop" is required.
	     */
	    loopOnDown: boolean;
	    /**
	     * Sets or gets wether or not looping on "disableLoop" is required.
	     */
	    loopOnDisable: boolean;
	    /**
	     * Defines all possible animations for the spine button and their related names in the spine file.
	     */
	    animationsNames: ISpineTimelineButtonAnimations;
	    /**
	     * Sets or gets wether or not the button is down/pushed.
	     * @hidden
	     */
	    _isDown: boolean;
	    /**
	     * Sets or gets wether or not the pointer is over the button.
	     * @hidden
	     */
	    _isOver: boolean;
	    private _label;
	    private _enabled;
	    private _sequence;
	    private _callToActionEnabled;
	    private _callToActionDelay;
	    private _callToActionTimer;
	    /**
	     * @hidden
	     */
	    _trackPointerId: number;
	    /**
	     * Constructor.
	     * @param assetId the id of the spine datas in the core-loader.
	     * @param styles the styles of the buttons.
	     */
	    constructor(assetId: string, styles: IStyles);
	    /**
	     * Gets wether or not the button is enabled.
	     */
	    get enabled(): boolean;
	    /**
	     * Sets wether or not the button is enabled. If "true", the enabling animation will be played.
	     */
	    set enabled(value: boolean);
	    /**
	     * Gets the current label of the button.
	     */
	    get label(): string;
	    /**
	     * Sets the current label of the button.
	     */
	    set label(value: string);
	    /**
	     * Gets wether or not the call to action feature is enabled.
	     */
	    get callToActionEnabled(): boolean;
	    /**
	     * Sets wether or not the call to action feature is enabled.
	     */
	    set callToActionEnabled(enabled: boolean);
	    /**
	     * Gets the current call to action delay in seconds.
	     */
	    get callToActionDelay(): ISpineTimelineButtonRange;
	    /**
	     * Sets the current call to action delay in seconds.
	     */
	    set callToActionDelay(delay: ISpineTimelineButtonRange);
	    /**
	     * Shows the button by playing the "enter" animation.
	     */
	    show(): Promise<void>;
	    /**
	     * Hides the button by playing the "exit" animation.
	     */
	    hide(): Promise<void>;
	    /**
	     * Updates the labels and centers the pivot.
	     */
	    updateLabels(): void;
	    /**
	     * Resets the button.
	     */
	    reset(): void;
	    /**
	     * Binds all the events of the button.
	     */
	    private _bindEvents;
	    /**
	     * Registers the event on pointer down.
	     */
	    protected onPointerDown(): void;
	    /**
	     * Registers the event on pointer over.
	     */
	    protected onPointerOver(): void;
	    /**
	     * Registers the event on pointer out.
	     */
	    protected onPointerOut(): void;
	    /**
	     * Registers the event on pointer up.
	     */
	    protected onPointerUp(): void;
	    /**
	     * Registers the event on pointer up outside.
	     */
	    protected onPointerUpOutside(): void;
	    /**
	     * Tracks the click event
	     */
	    protected trackClick(): void;
	    /**
	     * Configures and plays the button's sequence using the given animations array.
	     * @param animations the animations to play.
	     */
	    playAnimation(animations: ISpineTimelineAnimation[]): Promise<void>;
	    /**
	     * Creates all the labels.
	     */
	    private _createLabels;
	    /**
	     * Inits the call to action timers by killing the previous timer.
	     */
	    protected resetCallToAction(): void;
	    /**
	     * Exports the spine timeline button.
	     */
	    export(): any;
	    /**
	     * Parses the spine timeline button according to the given configuration.
	     * @param config the serialized data.
	     * @param baseUrl the base url of the loader.
	     * @param button the existing button reference.
	     */
	    static parse(config: any, baseUrl: string, button?: SpineTimelineButton): SpineTimelineButton;
	}
}

declare module "@gdk/core-pixi/ui/index" {
	export * from "@gdk/core-pixi/ui/baseui/index";
	export * from "@gdk/core-pixi/ui/spine/index";
	export * from "@gdk/core-pixi/ui/scratch/index";
	export * from "@gdk/core-pixi/ui/scratch2/index";
	export * from "@gdk/core-pixi/ui/scroll/index";
	export * from "@gdk/core-pixi/ui/events/index";
}

declare module "@gdk/core-pixi/ui/baseui/index" {
	export { Button, IButtonStyle } from "@gdk/core-pixi/ui/baseui/ui/button";
	export { ToggleButton } from "@gdk/core-pixi/ui/baseui/ui/toggleButton";
	export { Popup, IPopupStyle } from "@gdk/core-pixi/ui/baseui/ui/popup";
	export { TextArea } from "@gdk/core-pixi/ui/baseui/text/textArea";
	export { ELineJoin, ELineCap, EAlign, IStyle, IStyles, ITextStyle, EGradientType, EGradientBounds, IGradientSteps, } from "@gdk/core-pixi/ui/baseui/text/textStyle";
	export { TextField, ITextFieldOptions, ILink, EHitAreaLevel } from "@gdk/core-pixi/ui/baseui/text/textField";
	export { FontLoader } from "@gdk/core-pixi/ui/baseui/loaders/fontLoader";
	export { ScrollContainer, IScrollContainerOptions, EScrollbarAlign } from "@gdk/core-pixi/ui/baseui/ui/scrollContainer";
	export { ScrollBar, IScrollBarOptions } from "@gdk/core-pixi/ui/baseui/ui/scrollBar";
	export { NineSliceContainer, INineSliceContainerOptions } from "@gdk/core-pixi/ui/baseui/ui/ninesliceContainer";
	export { MouseWheelEvent, IMouseWheelEventOptions } from "@gdk/core-pixi/ui/baseui/ui/mouseWheelEvent";
	export { DraggEvent, IDraggEventOptions, ISwipeEventData } from "@gdk/core-pixi/ui/baseui/ui/draggEvent";
	export { Stackable, IStackableOptions, IStackableTween } from "@gdk/core-pixi/ui/baseui/ui/stackable";
	export { StackedContainer } from "@gdk/core-pixi/ui/baseui/ui/stackedContainer";
	export { CustomPointer, IPointerMoveEvent } from "@gdk/core-pixi/ui/baseui/ui/customPointer";
	export { Helpers } from "@gdk/core-pixi/ui/baseui/ui/helpers";
	export { SymbolSprite, SymbolSpriteError } from "@gdk/core-pixi/ui/baseui/ui/symbolSprite";
	export * from "@gdk/core-pixi/ui/baseui/ui/table";
	export * from "@gdk/core-pixi/ui/baseui/ui/tableCell";
	export * from "@gdk/core-pixi/ui/baseui/ui/cssLikeMargin";
}

declare module "@gdk/core-pixi/ui/baseui/ui/button" {
	import { Container, Sprite, Texture, Rectangle, mesh, Point } from "pixi.js";
	import type { ITrackableObject } from "@gdk/core";
	import { TextArea } from "@gdk/core-pixi/ui/baseui/text/textArea";
	import type { IStyles, IStyle } from "@gdk/core-pixi/ui/baseui/text/textArea";
	export interface IButtonStyle<ITextStates extends IButtonTextStates = IButtonTextStates> {
	    idleTexture?: string | Texture;
	    overTexture?: string | Texture;
	    clickedTexture?: string | Texture;
	    disabledTexture?: string | Texture;
	    textStates?: ITextStates;
	}
	export interface IButtonTextStates {
	    idle?: IStyle | IStyles;
	    hover?: IStyle | IStyles;
	    down?: IStyle | IStyles;
	    highlighted?: IStyle | IStyles;
	    disabled?: IStyle | IStyles;
	}
	export class Button extends Container implements ITrackableObject {
	    /**
	     * Defines the optional name of the object to be tracked.
	     * If unset, a default value will be taken by the tracker. For example,
	     * the name of the object (button, scratch, etc.).
	     */
	    trackingName: string;
	    idleTexture?: Texture;
	    overTexture?: Texture;
	    clickedTexture?: Texture;
	    disabledTexture?: Texture;
	    backgroundSprite: Sprite;
	    backgroundNineSlice: mesh.NineSlicePlane;
	    text: TextArea;
	    textStates: IButtonTextStates;
	    nineSliceMinSize: Point;
	    nineSlicePadding: Rectangle;
	    protected textStyle: IStyles;
	    protected onPointerOverCallback: () => void;
	    protected onPointerOutCallback: () => void;
	    protected onPointerDownCallback: () => void;
	    protected onMouseUpCallback: () => void;
	    protected onTouchEndCallback: () => void;
	    protected onPointerUpOutsideCallback: () => void;
	    protected onPointerTapCallback: () => void;
	    protected _enabled: boolean;
	    protected _isNineSlice: boolean;
	    protected _state: string;
	    /**
	     * Constructor
	     * @param style: the button style
	     * @param textStyle: (optional) style applied to the RichText field
	     * @param text: (optional) Text to display in the richtext field
	     */
	    constructor(style?: IButtonStyle, textStyle?: IStyle | IStyles, text?: string);
	    set state(state: string);
	    get state(): string;
	    protected stateToTextStyle(state: string): IStyle | IStyles;
	    protected stateToTexture(state: string): Texture | null;
	    /**
	     * Gets the current text of the button's textfield
	     */
	    get label(): string;
	    /**
	     * Sets the current text of the button's textfield
	     */
	    set label(label: string);
	    /**
	     * Gets the sprite background when button.isNineSlice is set to "false" or
	     * gets the nine slice background when button.isNineSlice is set to "true"
	     */
	    get background(): Sprite | mesh.NineSlicePlane;
	    /**
	     * Returns the current background's texture
	     */
	    get backgroundTexture(): Texture;
	    /**
	     * Sets the current background's texture
	     */
	    set backgroundTexture(texture: Texture);
	    /**
	     * Returns if the button is disabled or not
	     */
	    get enabled(): boolean;
	    /**
	     * Sets if the button is disabled
	     */
	    set enabled(enabled: boolean);
	    /**
	     * Gets wether or not the button is set to nine slice mode
	     */
	    get isNineSlice(): boolean;
	    /**
	     * Sets wether or not the button is set to nine slice mode
	     */
	    set isNineSlice(enabled: boolean);
	    /**
	     * Binds the events to the button (hover, clicked, etc.)
	     */
	    bindEvents(): void;
	    /**
	     * Unbinds the events
	     */
	    unBindEvents(): void;
	    protected _onPointerOver(): void;
	    protected _onPointerOut(): void;
	    protected _onPointerDown(): void;
	    protected _onMouseUp(): void;
	    protected _onTouchEnd(): void;
	    protected _onPointerUpOutside(): void;
	    protected _onPointerTap(): void;
	    protected _updateTextStyle(state: IStyle | IStyles): void;
	    protected _updateTexture(texture: Texture): void;
	    /**
	     * Export the button
	     */
	    export(): any;
	    /**
	     * Parses the textfield
	     * @param config the serialized data
	     * @param baseUrl the base url of the loader
	     * @param button the already created button
	     */
	    static parse(config: any, baseUrl: string, button?: Button): Button;
	}
}

declare module "@gdk/core-pixi/ui/baseui/text/textArea" {
	import { TextField } from "@gdk/core-pixi/ui/baseui/text/textField";
	import { IStyle, IStyles, EAlign } from "@gdk/core-pixi/ui/baseui/text/textStyle";
	import type { ITextFieldOptions } from "@gdk/core-pixi/ui/baseui/text/textField";
	export { IStyle, IStyles, EAlign };
	export class TextArea extends TextField {
	    /**
	     * Constructor
	     * @param text the text of the text field
	     * @param style the style of the text field
	     * @param canvas the optional existing canvas
	     */
	    constructor(text: string, styles: IStyle | IStyles, options?: ITextFieldOptions, canvas?: HTMLCanvasElement);
	}
}

declare module "@gdk/core-pixi/ui/baseui/text/textField" {
	import { Sprite, Rectangle, Point } from "pixi.js";
	import type OpenType from "opentype.js";
	import type { CanvasRenderer, WebGLRenderer, DestroyOptions } from "pixi.js";
	import { IStyle, IStyles, EAlign } from "@gdk/core-pixi/ui/baseui/text/textStyle";
	import { Text } from "@gdk/core-pixi/ui/baseui/text/text";
	import { Line } from "@gdk/core-pixi/ui/baseui/text/line";
	import { Word } from "@gdk/core-pixi/ui/baseui/text/word";
	import { Glyph } from "@gdk/core-pixi/ui/baseui/text/glyph";
	import type { IToken } from "@gdk/core-pixi/ui/baseui/text/tools/tokenizer";
	export { IStyle, IStyles, EAlign };
	export interface IUpdateOptions {
	    font?: string;
	    style?: IStyle;
	    text?: string;
	    noUpdate?: boolean;
	    noUpdateCanvas?: boolean;
	    noUpdateTexture?: boolean;
	    yOffset?: number;
	    xOffset?: number;
	    Text?: Text;
	}
	export interface ITextFieldOptions {
	    align?: EAlign;
	    padding?: Rectangle;
	    interLine?: number;
	    wordWrap?: boolean;
	    noUpdate?: boolean;
	}
	export enum EDrawPass {
	    Stroke = 0,
	    Fill = 1,
	    Debug = 2
	}
	export enum EHitAreaLevel {
	    Text = 0,
	    Line = 1,
	    Word = 2,
	    Glyph = 3
	}
	export interface ILink {
	    hitAreas: Rectangle[];
	    token: IToken;
	}
	export class TextField extends Sprite {
	    canvas: HTMLCanvasElement;
	    context: CanvasRenderingContext2D;
	    hitAreaLevel: EHitAreaLevel;
	    centerPivotOnceUpdated: boolean;
	    /**
	     * Sets or gets wether or not the textfield is frozen. If true, the textfield will not be updated
	     * when the .update function is called. Typically used when parsing the textfield.
	     * @hidden
	     */
	    _isFrozen: boolean;
	    protected _align: EAlign;
	    protected _text: string;
	    protected _styles: IStyles;
	    protected _width: number;
	    protected _height: number;
	    protected fixedWidth: number;
	    protected fixedHeight: number;
	    protected fonts: {
	        [index: string]: OpenType.Font;
	    };
	    protected composedText: Text;
	    protected hitAreas: Rectangle[];
	    protected links: {
	        [index: string]: ILink;
	    };
	    protected hooveredLink: IToken;
	    protected hasLinks: boolean;
	    private _resolution;
	    private _options;
	    private _debug;
	    private _hitAreaPoint;
	    private _i18nKey;
	    private _transform;
	    private _keepCanvasReference;
	    private _waitingBase64Texture;
	    static defaultLineHeight: number;
	    static cachedFonts: {
	        [index: string]: OpenType.Font;
	    };
	    static defaultTags: IStyles;
	    /**
	     * Constructor
	     * @param text the text of the text field
	     * @param style the style of the text field
	     * @param canvas the optional existing canvas
	     */
	    constructor(text: string, styles: IStyle | IStyles, options?: ITextFieldOptions, canvas?: HTMLCanvasElement);
	    /**
	     * Freeze a text to lock update when chaining multiple text changes that launch update
	     */
	    freeze(): void;
	    /**
	     * Unfreeze a text and launch the update to get the text result.
	     * @param options defines the optional options to pass to the update function called automatically.
	     */
	    unfreeze(options?: IUpdateOptions): void;
	    /**
	     * Destroys the textfield
	     */
	    destroy(options?: boolean | DestroyOptions): void;
	    /**
	     * Update the font cache taking the current applied
	     * styles
	     */
	    updateFontCache(): void;
	    /**
	     * Returns wether or not the canvas reference should be kept.
	     */
	    get keepCanvasReference(): boolean;
	    /**
	     * Sets wether or not the canvas reference shold be kept.
	     */
	    set keepCanvasReference(keep: boolean);
	    /**
	     * Returns the text alignment
	     */
	    get align(): EAlign;
	    /**
	     * Sets the text alignment
	     */
	    set align(value: EAlign);
	    /**
	     * Returns the current text
	     */
	    get text(): string;
	    /**
	     * Sets the current text
	     */
	    set text(value: string);
	    /**
	     * Returns the text"s width
	     */
	    get width(): number;
	    /**
	     * Sets the width of the text
	     */
	    set width(width: number);
	    /**
	     * Returns the text"s height
	     */
	    get height(): number;
	    set height(height: number);
	    /**
	     * Returns the text styles
	     */
	    get styles(): IStyles;
	    /**
	     * Sets the text styles
	     */
	    set styles(styles: IStyles);
	    /**
	     * Returns the padding value
	     */
	    get padding(): Rectangle;
	    /**
	     * Sets the padding value
	     */
	    set padding(value: Rectangle);
	    /**
	     * Returns the interline value
	     */
	    get interLine(): number;
	    /**
	     * Sets the interline value
	     */
	    set interLine(value: number);
	    /**
	     * Returns if the text is word-wrapped
	     */
	    get wordWrap(): boolean;
	    /**
	     * Sets if the text is word-wrapped
	     */
	    set wordWrap(enabled: boolean);
	    /**
	     * Gets the associated i18n key
	     */
	    get i18nKey(): string | null;
	    /**
	     * Sets the new associated i18n key
	     */
	    set i18nKey(key: string | null);
	    /**
	     * Updates the textfield
	     */
	    update(options?: IUpdateOptions): void;
	    private _removeCanvas;
	    /**
	     * Override pixi calculateBounds() method
	     * because we don"t get our bounds from texture quads but from our composed Text
	     */
	    calculateBounds(): void;
	    /**
	     * Override pixi containsPoint(point :Point) method
	     * because we might want to get glyph hitTest
	     * @param point: the point to test
	     */
	    containsPoint(point: Point): boolean;
	    /**
	     * Returns the link"s hit area
	     * @param point the point of the click
	     */
	    protected getLinkHit(point: Point): ILink;
	    /**
	     * Get all glyph and save them in this.glyphs
	     */
	    protected updateGlyphs(): void;
	    /**
	     * Applies the word wrap on the text
	     * @param wordWrap: if word wrap is enabled
	     * @param previousWord: the previous word (before "word")
	     * @param word: the current word
	     */
	    protected applyWordWrap(wordWrap: boolean, previousWord: Word, word: Word): number;
	    /**
	     * slit all glyphs into lines / stles and store them in this.lines
	     */
	    protected composeText(): void;
	    private _justifyLine;
	    private _drawPass;
	    private _drawLine;
	    private _drawWord;
	    private _getLineHorizontalAlignement;
	    protected drawGlyph(pass: number, glyph: Glyph, line: Line, word: Word): void;
	    /**
	     * get the bounds rectangle
	     * @param type: type of bounds wanted
	     * @param line: Line element used to compute bounds
	     * @param word: Word element used to compute bounds
	     * @param glyph: Glyph element used to compute bounds
	     * @returns the bounds
	     */
	    private _getBoundsByType;
	    /**
	     * get the fill style
	     * @param rect: the bounds where that style apply
	     * @param style: the style parametres
	     * @returns the canvasGradient
	     */
	    private _getFillStyle;
	    /**
	     * create a linear gradient
	     * @param rect: the gradient bounds
	     * @param style: the gradient style
	     * @returns the canvasGradient
	     */
	    private _createLinearGradient;
	    /**
	     * create a radial gradient
	     * @param rect: the gradient bounds
	     * @param style: the gradient style
	     * @returns the canvasGradient
	     */
	    private _createRadialGradient;
	    /**
	     * get the origin point in textfield for a given rectangle
	     * @param rect: the rectangle to get origin from
	     * @returns the origin point in textfield for that rectangle
	     */
	    private _getGradientOrigin;
	    /**
	     * limit an angle between min and max
	     * @param degrees: angle to limit
	     * @param min: minimum limit
	     * @param max: maximum limit
	     * @returns limited angle
	     */
	    private _trimAngle;
	    /**
	     * convert an angle in degrees to radians
	     * @param degrees: angle to convert in radian
	     * @returns converted radians angle
	     */
	    private _degToRad;
	    /**
	     * move and rotate a point
	     * @param origin {Point} the origin position
	     * @param angle the angle in degrees
	     * @param length the distance to move
	     * @returns {Point} transformed
	     */
	    private _lineToAngle;
	    /**
	     * Adds the given glyph to the availalbe links
	     * @param glyph the glyph to add
	     * @param hitArea the hit area of the glyph
	     */
	    protected addLink(glyph: Glyph, hitArea: Rectangle): void;
	    /**
	     * Apply a style to the context
	     * @param pass: the pass number
	     * @param style: the style to applied
	     */
	    protected applyRenderPassStyle(pass: number, style: IStyle): void;
	    /**
	     * Define context shadow style
	     * @param style: the style to take the shadow parameters
	     */
	    protected drawShadow(style?: IStyle): void;
	    /**
	     * Draw the underline
	     * @param glyphX the x position
	     * @param glyphY the y position
	     * @param Glyph the glyph to underline
	     * @param style the Style to use
	     */
	    protected drawUnderline(glyphX: number, lineY: number, glyph: Glyph, style: IStyle): void;
	    /**
	     * Draw a rectangle into context for debug purpose
	     * @param rectangle the Rectangle to draw
	     * @param style the Style to use
	     */
	    protected drawDebugRectangle(rect: Rectangle, style: IStyle): void;
	    /**
	     * Draw a simple rectangle into context
	     * @param rectangle the Rectangle to draw
	     */
	    private _drawRectangle;
	    private _onLinkEvent;
	    /**
	     * Render text with WebGL
	     * @param renderer the pixi.js renderer (WebGLRenderer)
	     * @override PIXI.Sprite.renderWebGL
	     */
	    renderWebGL(renderer: WebGLRenderer): void;
	    /**
	     * Render text with Canvas renderer
	     * @param renderer the pixi.js renderer (CanvasRenderer)
	     * @override PIXI.Sprite.renderCanvas
	     */
	    renderCanvas(renderer: CanvasRenderer): void;
	    /**
	     * This function is Path.prototype.draw
	     */
	    protected drawPath(path: OpenType.Path): void;
	    /**
	     * Updates the texture"s size
	     */
	    protected updateTextureSize(): void;
	    /**
	     * Updates the cached fonts
	     * @param style the style containing the font name
	     */
	    protected getFont(style: IStyle): OpenType.Font;
	    /**
	     * Helper to show debug
	     * @param show show debug or not
	     * @param styles the style to applied
	     */
	    showDebug(show: boolean, styles?: {}): void;
	    get resolution(): number;
	    /**
	     * Returns the number of pixels by unit
	     * @param value the value to convert
	     * @param style the style to use
	     */
	    static unitToPx(value: number, style: IStyle): number;
	    /**
	     * Returns the number of unit by pixels
	     * @param value the value to convert
	     * @param style the style to use
	     */
	    static pxToUnit(value: number, style: IStyle): number;
	    /**
	     * Export the textfield
	     */
	    export(): any;
	    /**
	     * Parses the textfield
	     * @param config the serialized data
	     * @param baseUrl the base url of the loader
	     * @param textfield the optional existing textfield instance
	     */
	    static parse(config: any, baseUrl: string, textfield?: TextField): TextField;
	}
}

declare module "@gdk/core-pixi/ui/baseui/text/text" {
	import type { Rectangle } from "pixi.js";
	import { EAlign } from "@gdk/core-pixi/ui/baseui/text/textField";
	import type { Word } from "@gdk/core-pixi/ui/baseui/text/word";
	import type { Line } from "@gdk/core-pixi/ui/baseui/text/line";
	import type { Glyph } from "@gdk/core-pixi/ui/baseui/text/glyph";
	export class Text {
	    align: EAlign;
	    lines: Line[];
	    words: Word[];
	    glyphs: Glyph[];
	    x: number;
	    y: number;
	    width: number;
	    height: number;
	    interLine: number;
	    padding: Rectangle;
	    leading: number;
	    canvasX: number;
	    canvasY: number;
	    maxLineWidth: number;
	    minLineX: number;
	    baseline: number;
	    /**
	     * Constructor
	     */
	    /**
	     * Add the given line to the text
	     * @param line the line to add
	     */
	    pushLine(line: Line): void;
	    /**
	     * Add the given word to the text
	     * @param word the word to add
	     */
	    pushWord(word: Word): Word;
	    /**
	     * Add the given glyph to the text
	     * @param glyph the glyph to add
	     */
	    pushGlyph(glyph: Glyph): void;
	}
}

declare module "@gdk/core-pixi/ui/baseui/text/word" {
	import { Rectangle } from "pixi.js";
	import type { Glyph } from "@gdk/core-pixi/ui/baseui/text/glyph";
	import type { Line } from "@gdk/core-pixi/ui/baseui/text/line";
	export class Word {
	    x: number;
	    y: number;
	    width: number;
	    maxHeight: number;
	    glyphs: Glyph[];
	    text: string;
	    nextGlyph: Glyph;
	    line: Line;
	    baseline: number;
	    /**
	     * Constructor
	     * @param previousWord the word before "this" one
	     */
	    constructor(previousWord?: Word);
	    /**
	     * Add the given glyph to the word
	     * @param glyph the glyph to add
	     */
	    pushGlyph(glyph: Glyph): void;
	    /**
	     * Returns the bounds of the word
	     */
	    getBounds(): Rectangle;
	}
}

declare module "@gdk/core-pixi/ui/baseui/text/glyph" {
	import { Rectangle } from "pixi.js";
	import type OpenType from "opentype.js";
	import type { IStyle } from "@gdk/core-pixi/ui/baseui/text/textStyle";
	import type { Word } from "@gdk/core-pixi/ui/baseui/text/word";
	import type { IToken } from "@gdk/core-pixi/ui/baseui/text/tools/tokenizer";
	export enum EGlyphType {
	    Null = 0,
	    Character = 1,
	    Space = 2,
	    NewLine = 3
	}
	export class Glyph {
	    x: number;
	    interLine: number;
	    width: number;
	    height: number;
	    yMax: number;
	    yMin: number;
	    ascender: number;
	    maxHeight: number;
	    leading: number;
	    kerning: number;
	    openTypeGlyph: OpenType.Glyph;
	    style: IStyle;
	    text: string;
	    word: Word;
	    type: EGlyphType;
	    token: IToken;
	    /**
	     * Constructor
	     * @param char: the glyph's char
	     * @param style the glyph's style
	     * @param previousGlyph: the glyph just before "this"
	     */
	    constructor(char: string, style: IStyle, previousGlyph: Glyph);
	    /**
	     * Returns the glyph's bounds
	     */
	    getBounds(): Rectangle;
	}
}

declare module "@gdk/core-pixi/ui/baseui/text/tools/tokenizer" {
	export enum ETokenType {
	    EndOfInput = 0,
	    Other = 1,
	    TagOpen = 4,
	    TagClose = 5
	}
	export interface IToken {
	    type: string;
	    content: string;
	    attributes: {
	        [index: string]: string;
	    };
	}
	export class Tokenizer {
	    toParse: string;
	    pos: number;
	    size: number;
	    currentString: string;
	    private _canBeTag;
	    /**
	     * Constructor
	     * @param str the string to tokenize
	     */
	    constructor(str: string);
	    /**
	     * Returns the next character
	     */
	    read(): string;
	    /**
	     * Peeks the current character
	     */
	    peek(): string;
	    /**
	     * Increment position in string to parse
	     */
	    forward(): void;
	    /**
	     * Returns if at end of string to parse
	     */
	    isEnd(): boolean;
	    /**
	     * Returns the next token (tag or other)
	     */
	    getNextToken(): ETokenType;
	    /**
	     * Returns the next tag
	     */
	    getNextTag(): IToken;
	}
}

declare module "@gdk/core-pixi/ui/baseui/text/line" {
	import { Rectangle } from "pixi.js";
	import { EAlign } from "@gdk/core-pixi/ui/baseui/text/textField";
	import type { Text } from "@gdk/core-pixi/ui/baseui/text/text";
	import type { Word } from "@gdk/core-pixi/ui/baseui/text/word";
	export class Line {
	    x: number;
	    y: number;
	    width: number;
	    height: number;
	    maxHeight: number;
	    align: EAlign;
	    words: Word[];
	    baseline: number;
	    leading: number;
	    underline: number;
	    previousLine: Line;
	    baselineOffset: number;
	    text: string;
	    /**
	     * Constructor
	     * @param composedText: the composed text reference of the line
	     * @param previousLine: the line before "this" one
	     */
	    constructor(composedText: Text, previousLine?: Line);
	    /**
	     * Add the given word to the line
	     * @param word the word to add
	     */
	    pushWord(word: Word): void;
	    /**
	     * Returns the line's bounds
	     */
	    getBounds(): Rectangle;
	}
}

declare module "@gdk/core-pixi/ui/baseui/ui/toggleButton" {
	import { Texture } from "pixi.js";
	import type { IButtonStyle, IButtonTextStates } from "@gdk/core-pixi/ui/baseui/ui/button";
	import { Button } from "@gdk/core-pixi/ui/baseui/ui/button";
	import type { IStyles, IStyle } from "@gdk/core-pixi/ui/baseui/text/textArea";
	export interface IToggleButtonStyle extends IButtonStyle<IToggleButtonTextStates> {
	    overClickedTexture?: string | Texture;
	}
	export interface IToggleButtonTextStates extends IButtonTextStates {
	    hoverClicked?: IStyle | IStyles;
	}
	export class ToggleButton extends Button {
	    protected static instances: ToggleButton[];
	    /**
	     * Texture displayed when mouse over the button, and button is checked.
	     */
	    overClickedTexture?: Texture;
	    protected _groupName: null | string;
	    protected _checked: boolean;
	    constructor(style?: IToggleButtonStyle, textStyle?: IStyle | IStyles, text?: string);
	    /**
	     * Change this button state (checked -> not checked and vice versa)
	     */
	    toggle(): void;
	    /**
	     * Change the state status of this button.
	     */
	    set checked(checked: boolean);
	    /**
	     * Return the checked status of this button.
	     */
	    get checked(): boolean;
	    protected _onPointerOver(): void;
	    protected _onPointerOut(): void;
	    protected _onPointerDown(): void;
	    protected _onMouseUp(): void;
	    protected _onTouchEnd(): void;
	    protected _onPointerUpOutside(): void;
	    protected onAddedOrRemoved(): void;
	    protected stateToTextStyle(state: string): IStyle | IStyles;
	    /**
	     * Serialize this component.
	     */
	    export(): any;
	    /**
	     * Unserialize a toggle button
	     *
	     * @param config the serialized data
	     * @param baseUrl the base url of the loader
	     * @param button the already created ToggleButton
	     */
	    static parse(config: any, baseUrl: string, button?: ToggleButton): ToggleButton;
	    /**
	     * Destroy this component.
	     */
	    destroy(): void;
	    /**
	     * Set the group name of this button (null if no group).
	     */
	    set groupName(groupName: string | null);
	    /**
	     * Return the group name of this button (null if no group).
	     */
	    get groupName(): null | string;
	    protected isAccountableAsRadio: () => boolean;
	    /**
	     * Apply rules related to radio group to the given group.
	     * @param groupName: name of the group of which we check constraints
	     * @param checked: if set, keep this button as checked in case several buttons are checked
	     */
	    static enforceRadioConstraints(groupName: string, checked?: ToggleButton): void;
	    /**
	     * Return the instance of ToggleButton that is checked for the given group.
	     * @returns: checked button if one, null if no button checked
	     */
	    static getChecked(groupName: string): null | ToggleButton;
	}
}

declare module "@gdk/core-pixi/ui/baseui/ui/popup" {
	import { Container, Sprite, mesh } from "pixi.js";
	import type { Texture } from "pixi.js";
	import { Button } from "@gdk/core-pixi/ui/baseui/ui/button";
	import type { IButtonStyle } from "@gdk/core-pixi/ui/baseui/ui/button";
	export interface IPopupStyle {
	    /**
	     * The background texture reference or the texture name
	     */
	    backgroundTexture?: string | Texture;
	    /**
	     * The close button reference of the style of the button
	     */
	    closeButtonStyle?: IButtonStyle | Button;
	}
	export class Popup extends Container {
	    /**
	     * The background sprite reference when the popup's background is using a sprite
	     */
	    backgroundSprite: Sprite;
	    /**
	     * The background nine slice reference when the popup's background is using a nine slice plane
	     */
	    backgroundNineSlice: mesh.NineSlicePlane;
	    /**
	     * The top-right button used to close the popup
	     */
	    closeButton: Button;
	    /**
	     * Gets wether or not the popup's background is using a nine slice plane
	     */
	    protected _isNineSlice: boolean;
	    /**
	     * Constructor
	     * @param style the style of the popup
	     */
	    constructor(style?: IPopupStyle);
	    /**
	     * Gets the sprite background when button.isNineSlice is set to "false" and returns the nine slice background
	     * when button.isNineSlice is set to "true"
	     */
	    get background(): Sprite | mesh.NineSlicePlane;
	    /**
	     * Gets the current texture of the background
	     */
	    get backgroundTexture(): Texture;
	    /**
	     * Sets the current texture of the background
	     */
	    set backgroundTexture(texture: Texture);
	    /**
	     * Gets wether or not the button is set to nine slice mode
	     */
	    get isNineSlice(): boolean;
	    /**
	     * Sets wether or not the button is set to nine slice mode
	     */
	    set isNineSlice(enabled: boolean);
	    /**
	     * Gets the current width of the popup
	     */
	    get width(): number;
	    /**
	     * Sets the current width of the popup. Should be used only when isNineSlice is set to "true"
	     */
	    set width(width: number);
	    /**
	     * Gets the current height of the popup
	     */
	    get height(): number;
	    /**
	     * Sets the current height of the popup. Should be used only when isNineSlice is set to "true"
	     */
	    set height(height: number);
	    /**
	     * Export the popup
	     */
	    export(): any;
	    /**
	     * Parses the textfield
	     * @param config the serialized data
	     * @param baseUrl the base url of the loader
	     * @param popup the already created popup
	     */
	    static parse(config: any, baseUrl: string, popup?: Popup): Popup;
	}
}

declare module "@gdk/core-pixi/ui/baseui/loaders/fontLoader" {
	import type { ILoader } from "@gdk/core";
	import type { Font } from "opentype.js";
	export interface IFileType {
	    data: Font;
	    family?: string;
	    filename: string;
	}
	export interface IStringDictionary<T> {
	    [key: string]: T;
	}
	export class FontLoader implements ILoader {
	    extensions: string[];
	    private _baseUrl;
	    static fonts: {
	        [index: string]: IFileType;
	    };
	    static fontMapNames: IStringDictionary<IStringDictionary<string>>;
	    /**
	     * Returns the associated font giving a family + sub family
	     * @param fontFamily The font family
	     * @param fontSubfamily The font sub family
	     */
	    static getFontFamily(fontFamily: string, fontSubfamily?: string): Font;
	    /**
	     * Returns the base url of the loader
	     */
	    get baseUrl(): string;
	    /**
	     * Sets the base url of the loader
	     */
	    set baseUrl(url: string);
	    /**
	     * Add the given file to the files to load
	     * @param filename the file to add
	     */
	    add(filename: string, key?: string): void;
	    /**
	     * Clears the files to load dictionary
	     */
	    clear(): void;
	    /**
	     * Returns the resource identified by the given key
	     * @param key the key of the value to get
	     */
	    get<T>(key: string): T;
	    /**
	     * Load all files previously added
	     * @param callback called when all files loaded
	     * @param progress called when a file has been loaded
	     * @param error called when an error happens
	     */
	    load(callback: () => void, progress?: (filename?: string) => void, error?: (file: string) => void): void;
	    private _createInstance;
	}
}

declare module "@gdk/core-pixi/ui/baseui/ui/scrollContainer" {
	/// <reference types="gsap" />
	import { Container, Rectangle, Point } from "pixi.js";
	import type { DisplayObject, WebGLRenderer, CanvasRenderer } from "pixi.js";
	import { DockingBounds } from "@gdk/core-pixi/container/dockingBounds";
	import { ScrollBar } from "@gdk/core-pixi/ui/baseui/ui/scrollBar";
	export interface IScrollContainerOptions {
	    scrollX?: boolean;
	    scrollY?: boolean;
	    dragScrolling?: boolean;
	    wheelScrolling?: boolean;
	    softness?: number;
	    radius?: number;
	    expandMask?: number;
	    showDebug?: boolean;
	    width?: number;
	    height?: number;
	}
	export enum EScrollbarAlign {
	    Before = 0,
	    After = 1
	}
	export class ScrollContainer extends Container {
	    expandMask: number;
	    radius: number;
	    innerContainer: Container;
	    innerBounds: Rectangle;
	    scrollBars: ScrollBar[];
	    innerDockingBounds: DockingBounds;
	    private _width;
	    private _height;
	    private _lastWidth;
	    private _lastHeight;
	    private _innerMask;
	    private _debugMask;
	    private _shouldScrollX;
	    private _shouldScrollY;
	    private _scrollX;
	    private _scrollY;
	    private _dragScrolling;
	    private _wheelScrolling;
	    private _softness;
	    private _animating;
	    private _scrolling;
	    private _boundCached;
	    private _containerStart;
	    private _targetPosition;
	    private _lastPosition;
	    private Position;
	    private Speed;
	    private _stop;
	    private _lastTime;
	    private _canvas;
	    private _showDebug;
	    private _positionTween;
	    private _draggScroll;
	    private _wheelScroll;
	    /**
	     * create a ScrollContainer element with specified options
	     */
	    constructor(options?: IScrollContainerOptions);
	    /**
	     * attach a scrollbar to that scroll container
	     * @param scrollBar {ScrollBar} the scrollbar to attach.
	     * @param align {Align} the alignement (Before or After) of that scrollbar.
	     */
	    attachScrollbar(scrollbar: ScrollBar, align?: EScrollbarAlign): void;
	    /**
	     * override container.addChild() method to prevent adding child oustide of innerContainer.
	     * @param child {T extends DisplayObject} the child to addChild in innerContainer
	     * @param additionalChildren {DisplayObject[]} (optional) additional children to addChild in innerContainer
	     */
	    addChild<T extends DisplayObject>(child: T, ...additionalChildren: DisplayObject[]): T;
	    /**
	     * will scroll to given ratio
	     * @param vertical {boolean} set if it's scrolling on vertical axis
	     * @param ratio {number} the ratio to scroll to 0 to 1
	     * @param duration {number} (default 1) the time in seconds it take to scroll
	     * @param ease {gsap.Ease} (default Cubic.easeInOut) the easing function used to scroll.
	     */
	    scrollTo(vertical: boolean, ratio: number, duration?: number, ease?: gsap.Ease): void;
	    /**
	     * will scroll to given position
	     * @param position {Point} the position to scroll to
	     * @param duration {number} (default 1) the time in seconds it take to scroll
	     * @param ease {gsap.Ease} (default Cubic.easeInOut) the easing function used to scroll.
	     */
	    scrollToPosition(position: Point, duration?: number, ease?: gsap.Ease): void;
	    /**
	     * Render text with WebGL
	     * @param renderer the pixi.js renderer (WebGLRenderer)
	     * @override PIXI.Sprite.renderWebGL
	     */
	    renderWebGL(renderer: WebGLRenderer): void;
	    /**
	     * Render text with Canvas renderer
	     * @param renderer the pixi.js renderer (CanvasRenderer)
	     * @override PIXI.Sprite._renderCanvas
	     */
	    renderCanvas(renderer: CanvasRenderer): void;
	    /**
	     * get the height
	     */
	    get height(): number;
	    /**
	     * set the height
	     * @param value {number} the new height
	     */
	    set height(value: number);
	    /**
	     * get the width
	     */
	    get width(): number;
	    /**
	     * set the width
	     * @param value {number} the new width
	     */
	    set width(value: number);
	    /**
	     * Returns the inner bounds (from inner container)
	     * @param force to to calculate inner bounds
	     */
	    getInnerBounds(force?: boolean): Rectangle;
	    protected initialize(): void;
	    protected update(): void;
	    protected setScrollPosition(speed?: Point): void;
	    protected updateScrollPosition(delta: number): void;
	    protected updateDirection(bounds: Rectangle, direction: string, delta: number): void;
	    protected updateScrollBars(): void;
	    protected initScrolling(): void;
	    protected onTick(): void;
	    protected initDragScroll(): void;
	    private _forceScrollTo;
	    private _stopTween;
	    private redrawMask;
	    /**
	     * Export the scroll container
	     */
	    export(): any;
	    /**
	     * Parses the scroll container
	     * @param config the serialized data
	     * @param baseUrl the base url of the loader
	     * @param container the existing scroll container
	     */
	    static parse(config: any, baseUrl: string, container?: ScrollContainer): ScrollContainer;
	}
}

declare module "@gdk/core-pixi/ui/baseui/ui/scrollBar" {
	import { Rectangle } from "pixi.js";
	import { EScrollbarAlign } from "@gdk/core-pixi/ui/baseui/ui/scrollContainer";
	import { Slider } from "@gdk/core-pixi/ui/baseui/ui/slider";
	import type { ISliderOptions } from "@gdk/core-pixi/ui/baseui/ui/slider";
	import type { ScrollContainer } from "@gdk/core-pixi/ui/baseui/ui/scrollContainer";
	export interface IScrollBarOptions extends ISliderOptions {
	    margin: Rectangle;
	    scrollingContainer: ScrollContainer;
	    align: EScrollbarAlign;
	}
	export class ScrollBar extends Slider {
	    autohide: boolean;
	    toogleVisibilityDuration: number;
	    margin: Rectangle;
	    scrollingContainer: ScrollContainer;
	    scaleRatio: number;
	    private _hidden;
	    private _align;
	    /**
	     * create a Scrollbar element with specified options
	     * @param options the creation options
	     */
	    constructor(options: IScrollBarOptions);
	    /**
	     * will align the scrollbar size and position to the scroll-container content size and position.
	     */
	    alignToContainer(): void;
	    /**
	     * Gets the width of the scroll bar
	     */
	    get width(): number;
	    /**
	     * Sets the width of the scrollbar. Then resizes the handle and the track meshes
	     */
	    set width(value: number);
	    /**
	     * Gets the height of the scroll bar
	     */
	    get height(): number;
	    /**
	     * Sets the height of the scrollbar. Then resizes the handle and the track meshes
	     */
	    set height(value: number);
	    /**
	     * initialize Events handlers
	     */
	    protected initialize(): void;
	    private _resizeTrack;
	    private _resizeHandle;
	    /**
	     * toogle alpha 0 / 1 at given speed
	     * @param hidden {boolean} will alpha goes to 0 ?
	     * @param duration {number} the duration of the toogle tween.
	     */
	    private _toggleHidden;
	    /**
	     * Exports the scroll bar
	     */
	    export(): any;
	    /**
	     * Parses the scroll bar
	     * @param config the serialized data
	     * @param baseUrl the base url of the loader
	     */
	    static parse(config: any, baseUrl: string, scrollContainer?: ScrollContainer): ScrollBar;
	}
}

declare module "@gdk/core-pixi/ui/baseui/ui/slider" {
	import { Container } from "pixi.js";
	import type { WebGLRenderer, CanvasRenderer } from "pixi.js";
	export interface ISliderOptions {
	    track: PIXI.mesh.NineSlicePlane;
	    handle: PIXI.mesh.NineSlicePlane;
	    minValue?: number;
	    maxValue?: number;
	    decimals?: number;
	    vertical?: boolean;
	    onValueChange?: () => void;
	    onValueChanging?: () => void;
	    value?: number;
	}
	export class Slider extends Container {
	    vertical: boolean;
	    track: PIXI.mesh.NineSlicePlane;
	    handle: PIXI.mesh.NineSlicePlane;
	    decimals: number;
	    minValue: number;
	    maxValue: number;
	    protected pValue: number;
	    protected pOnValueChange: (newValue: number) => void;
	    protected pOnValueChanging: (newValue: number) => void;
	    private _disabled;
	    private _canvas;
	    protected _width: number;
	    protected _height: number;
	    private _trackWidth;
	    private _trackHeight;
	    private _handleWidth;
	    private _handleHeight;
	    private _handleDraggEvent;
	    private _trackDraggEvent;
	    /**
	     * create a Slider element with specified options
	     */
	    constructor(options: ISliderOptions);
	    /**
	     * Render text with WebGL
	     * @param renderer the pixi.js renderer (WebGLRenderer)
	     * @override PIXI.Sprite.renderWebGL
	     */
	    renderWebGL(renderer: WebGLRenderer): void;
	    /**
	     * Render text with Canvas renderer
	     * @param renderer the pixi.js renderer (CanvasRenderer)
	     * @override PIXI.Sprite._renderCanvas
	     */
	    renderCanvas(renderer: CanvasRenderer): void;
	    /**
	     * @param value sets the scroll value
	     */
	    set value(val: number);
	    /**
	     * gets the scroll value
	     */
	    get value(): number;
	    /**
	     * sets the onValueChange callback.
	     * will be triggered after a scroll value update.
	     */
	    set onValueChange(val: (newValue: number) => void);
	    /**
	     * gets the onScrollRatioChange callback.
	     */
	    get onValueChange(): (newValue: number) => void;
	    /**
	     * sets the onValueChanging callback.
	     * will be triggered while scroll value is updated.
	     */
	    set onValueChanging(val: (newValue: number) => void);
	    /**
	     * gets the onValueChanging callback.
	     */
	    get onValueChanging(): (newValue: number) => void;
	    /**
	     * is the slider disabled (not interactive)
	     */
	    get disabled(): boolean;
	    /**
	     * set the slider disable (not interactive) or not
	     */
	    set disabled(val: boolean);
	    get width(): number;
	    get height(): number;
	    /**
	     * perform an update
	     */
	    protected update(soft?: boolean): void;
	    /**
	     * initialize Events handlers
	     */
	    protected initialize(): void;
	}
}

declare module "@gdk/core-pixi/ui/baseui/ui/ninesliceContainer" {
	import { Container, Rectangle, mesh } from "pixi.js";
	import type { DisplayObject, BaseTexture, CanvasRenderer, WebGLRenderer } from "pixi.js";
	import { DockingBounds } from "@gdk/core-pixi/container/dockingBounds";
	export interface ISize {
	    width: number;
	    height: number;
	}
	export interface INineSliceContainerOptions {
	    backgroundTexture: string | number | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | BaseTexture;
	    slice?: Rectangle | number;
	    padding?: Rectangle | number;
	    minSize?: ISize;
	}
	export class NineSliceContainer extends Container {
	    minSize: ISize;
	    innerDockingBounds: DockingBounds;
	    private _background;
	    private _container;
	    private _padding;
	    private _slice;
	    private _previousSize;
	    private _innerBounds;
	    private _boundCached;
	    /**
	     * constructor
	     * @param options the nine slice container options :
	     * {
	     *   backgroundTexture:string | number | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | BaseTexture;
	     *   slice?: Rectangle | number;
	     *   padding?: Rectangle | number;
	     *   minSize?: Size;
	     * }
	     */
	    constructor(options: INineSliceContainerOptions);
	    /**
	     * Render text with WebGL
	     * @param renderer the pixi.js renderer (WebGLRenderer)
	     * @override PIXI.Sprite.renderWebGL
	     */
	    renderWebGL(renderer: WebGLRenderer): void;
	    /**
	     * Render text with Canvas renderer
	     * @param renderer the pixi.js renderer (CanvasRenderer)
	     * @override PIXI.Sprite._renderCanvas
	     */
	    renderCanvas(renderer: CanvasRenderer): void;
	    /**
	     * add some contents
	     * @param child the child to add
	     */
	    addContent<T extends DisplayObject>(child: T): T;
	    /**
	     * add some contents at given index
	     * @param child the child to add
	     * @param index the index to add at
	     */
	    addContentAt<T extends DisplayObject>(child: T, index: number): T;
	    /**
	     * get content at given index
	     * @param index the index where the content should be.
	     */
	    getContentAt<T extends DisplayObject>(index: number): T;
	    /**
	     * get content by name
	     * @param name the name of the content to get.
	     */
	    getContentByName<T extends DisplayObject>(name: string): T;
	    /**
	     * get the index of provided content
	     * @param child the content we need need the index of.
	     */
	    getContentIndex(child: DisplayObject): number;
	    /**
	     * the padding between the background and the content
	     * @param value could be a rectangle or a number
	     */
	    set padding(value: Rectangle | number);
	    /**
	     * @returns the padding between the background and the content
	     */
	    get padding(): Rectangle | number;
	    /**
	     * the nine slice settings
	     * @param value could be a rectangle or a number
	     */
	    set slice(value: Rectangle | number);
	    /**
	     * @returns the nine slice settings
	     */
	    get slice(): Rectangle | number;
	    /**
	     * the background texture
	     * @param texture {string | number | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | BaseTexture}
	     */
	    set background(texture: string | number | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | BaseTexture);
	    /**
	     * Returns the background nine slice mesh
	     */
	    getBackground(): mesh.NineSlicePlane;
	    /**
	     * return the container children
	     */
	    get contents(): DisplayObject[];
	    /**
	     * return the container
	     */
	    get container(): Container;
	    private _getInnerBounds;
	    /**
	     * update background size according content size + padding
	     */
	    private _updateSize;
	    /**
	     * Exports the nine slice container
	     */
	    export(): any;
	    /**
	     * Parses the nine slice container
	     * @param config the serialized data
	     * @param baseUrl the base url of the loader
	     */
	    static parse(config: any, baseUrl: string): NineSliceContainer;
	}
}

declare module "@gdk/core-pixi/ui/baseui/ui/mouseWheelEvent" {
	import { Point } from "pixi.js";
	import type { DisplayObject } from "pixi.js";
	export interface IMouseWheelEventOptions {
	    target: DisplayObject;
	}
	export class MouseWheelEvent {
	    static LINE_HEIGHT: number;
	    static PAGE_HEIGHT: number;
	    onMouseWheel: (e: PIXI.interaction.InteractionEvent, delta: Point) => void;
	    private _bound;
	    private _preventDefault;
	    private _delta;
	    private _options;
	    private _target;
	    private _previousWheelTarget;
	    /**
	     * create an mouse wheel event listener from given options
	     * will listen mouseOver on target, then listen wheel event and dispatch delta until mouseOut
	     */
	    constructor(options?: IMouseWheelEventOptions);
	    /**
	     * get current mouse wheel target (the one mouse is over)
	     */
	    private get _currentWheelTarget();
	    /**
	     * set current mouse wheel target
	     */
	    private set _currentWheelTarget(value);
	    private _startEvent;
	    private _setPreviousWheelTarget;
	    private _resetPreviousWheelTarget;
	    private _isCurrentWheelTarget;
	    private _onMouseWheel;
	    static currentWheelTargetID: string;
	}
}

declare module "@gdk/core-pixi/ui/baseui/ui/draggEvent" {
	import { Point } from "pixi.js";
	import type { DisplayObject } from "pixi.js";
	export interface IDraggEventOptions {
	    target: DisplayObject;
	    canvas: HTMLCanvasElement;
	    dragThreshold?: number;
	    dragRestrictAxis?: string;
	    stopPropagation?: boolean;
	    preventDefault?: boolean;
	}
	export interface ISwipeEventData {
	    start: Point;
	    end: Point;
	    offset: Point;
	    elapsed: number;
	    pixelsPerSecond: Point;
	    target: DisplayObject;
	}
	export class DraggEvent {
	    static currentScrollTargetID: string;
	    onDragStart: (e: PIXI.interaction.InteractionEvent) => void;
	    onDragMove: (e: PIXI.interaction.InteractionEvent, offset: Point, position: Point) => void;
	    onDragEnd: (e: PIXI.interaction.InteractionEvent) => void;
	    onPress: (e: PIXI.interaction.InteractionEvent, isPressed: boolean, position: Point) => void;
	    stopPropagation: boolean;
	    preventDefault: boolean;
	    private _id;
	    private _bound;
	    private _cancel;
	    private _dragging;
	    private _start;
	    private _offset;
	    private _mouse;
	    private _movementX;
	    private _movementY;
	    private _options;
	    private _target;
	    private _canvas;
	    private _startTime;
	    /**
	     * create an drag event listener from given options
	     * will listen mouseDown or touchstart on target,
	     * then listen move event and dispatch delta until mouseUp or touchEnd
	     */
	    constructor(options?: IDraggEventOptions);
	    private _emitSwipe;
	}
}

declare module "@gdk/core-pixi/ui/baseui/ui/stackable" {
	import { Container } from "pixi.js";
	import type { Ease } from "gsap";
	/**
	 * Interface for Stackable component initialization.
	 * @property {Container[]} stack   An exisiting container Array to transfer to the Stackable stack.
	 * @property {string} direction         The direction to where the stacks grows.
	 * @property {number} spacing           The amount of space in pixels between stack elements.
	 */
	export interface IStackableOptions<T extends Container> {
	    stack?: T[];
	    direction?: "up" | "down" | "left" | "right";
	    spacing?: number;
	    operationTween?: IStackableTween;
	    operationOffset?: IStackableOffset;
	}
	export interface IStackableTween {
	    duration: number;
	    ease: Ease;
	    fade: boolean;
	}
	export interface IStackableOffset {
	    parralel: number;
	    perpendicular: number;
	}
	/**
	 * @class A stack of containers that updates itself when changed.
	 */
	export class Stackable<T extends Container> extends Container {
	    private _stack;
	    private _spacing;
	    private _direction;
	    operationTween: IStackableTween;
	    operationOffset: IStackableOffset;
	    private static DEFAULT_TWEEN;
	    /**
	     * Constructs a new Stackable component.
	     * @param {IStackableOptions} options Options object to initialize.
	     */
	    constructor(options?: IStackableOptions<T>);
	    /**
	     * Re-stack the elements together.
	     * Called by public functions that modify the stack.
	     */
	    private _update;
	    private _getGrowthDimension;
	    private _getGrowthDirection;
	    private _getPerpendicularDirection;
	    private _offsetToVector;
	    /**
	     * Pushes a container on top of the stack.
	     * @param container An existing container to push on the stack.
	     */
	    push(container: T, tween?: boolean, cb?: (T: T) => void): void;
	    /**
	     * Removes the last container of the stack and returns it.
	     * @returns The container that was removed.
	     */
	    pop(tween?: boolean, cb?: (T: T) => void): T;
	    /**
	     * Insert a new container at the specified index.
	     * @param container An existing container to insert in the stack.
	     * @param index The index to where the container is inserted.
	     */
	    insertAt(container: T, index: number, tween?: boolean, cb?: (T: T) => void): void;
	    /**
	     * Removes a container from the stack at the specified index.
	     * @param index The index from where the container is removed.
	     * @returns The removed container.
	     */
	    removeAt(index: number, tween?: boolean, cb?: (T: T) => void): T;
	    /**
	     * Returns the element from the stack from the specified index.
	     * @param index
	     */
	    getElementAt(index: number): T;
	    /**
	     * Returns the stack of containers.
	     * @returns
	     */
	    get stack(): T[];
	    /**
	     * Sets a new stack of containers, replacing the existing one.
	     * @param stack
	     */
	    set stack(stack: T[]);
	    /**
	     * Sets the direction to where the stack grows.
	     * @param direction
	     */
	    set direction(direction: "up" | "down" | "left" | "right");
	    /**
	     * Gets the direction to where the stack grows.
	     * @returns
	     */
	    get direction(): "up" | "down" | "left" | "right";
	    /**
	     * Sets the spacing between each element of the stack.
	     * @param value
	     */
	    set spacing(value: number);
	    /**
	     * Gets the spacing between each element of the stack.
	     * @returns
	     */
	    get spacing(): number;
	}
}

declare module "@gdk/core-pixi/ui/baseui/ui/stackedContainer" {
	/**
	 * Helper class for Stackable, used to store container offsets in the stack.
	 */
	export class StackedContainer<T> {
	    container: T;
	    offset: number;
	    constructor(container: T);
	}
}

declare module "@gdk/core-pixi/ui/baseui/ui/customPointer" {
	import { Container, Point } from "pixi.js";
	import type { CanvasRenderer, WebGLRenderer, interaction } from "pixi.js";
	export interface ICustomPointerOptions {
	    debug: boolean;
	}
	/**
	 * Custom pointer configuration
	 * TODO : add other optionnal properties (onMove...)
	 */
	export interface ICustomPointerConfig {
	    element: Container;
	    pivot?: Point;
	    scale?: number;
	    allowGlobalInteractionEvents?: boolean;
	    onMove?: (target: Container, datas: IPointerMoveEvent) => void;
	    onDown?: (target: Container, datas: IPointerEvent) => void;
	}
	export interface IPointerEvent {
	    position: Point;
	    localPosition: Point;
	    data: interaction.InteractionData;
	}
	export interface IPointerMoveEvent extends IPointerEvent {
	    previous: Point;
	    delta: Point;
	    distance: number;
	    time: number;
	    speed: number;
	    angle: {
	        radian: number;
	        degree: number;
	    };
	}
	export class CustomPointer extends Container {
	    /**
	     * callback called when the pointer moved Over a target
	     */
	    onOver: (target: Container) => void;
	    /**
	     * callback called when the pointer moved Out a target
	     */
	    onOut: (target: Container) => void;
	    /**
	     * callback called when the pointer is pressed on a target
	     */
	    onDown: (target: Container, datas: IPointerEvent) => void;
	    /**
	     * callback called when the pointer is released
	     */
	    onUp: (target: Container) => void;
	    /**
	     * callback called when the pointer moved over a target
	     */
	    onMove: (target: Container, datas: IPointerMoveEvent) => void;
	    /**
	     * Sets wether or not the native pointer icon should be hidden or not
	     */
	    hideNativePointer: boolean;
	    /**
	     * Sets wether or not global interaction events are allowed or are closed to the current target container.
	     */
	    allowGlobalInteractionEvents: boolean;
	    /**
	     * method called when the pointer need to be shown
	     * should be overriten
	     */
	    onShow: () => void;
	    /**
	     * method called when the pointer need to be hidden
	     * should be overriten
	     */
	    onHide: () => void;
	    private _pointerIcon;
	    private _renderer;
	    private previousPosition;
	    private _targets;
	    private _currentTarget;
	    private previousTime;
	    private _degrees;
	    /**
	     * Constructor
	     * @param config rendering options for custom pointer
	     */
	    constructor(config?: ICustomPointerConfig);
	    /**
	     * sets the pointer icon scale and pivot (and more)
	     * @param config the new configuration of the custom pointer
	     */
	    setConfig(config: ICustomPointerConfig): void;
	    /**
	     * Resets the custom pointer
	     */
	    reset(): void;
	    /**
	     * override PIXI renderCanvas Method to get the renderer;
	     * @param renderer {CanvasRenderer} the renderer i want to get
	     */
	    renderCanvas(renderer: CanvasRenderer): void;
	    /**
	     * override PIXI renderWebGL Method to get the renderer;
	     * @param renderer {WebGLRenderer} the renderer i want to get
	     */
	    renderWebGL(renderer: WebGLRenderer): void;
	    /**
	     * add a target to watch and where the pointer need's to appear.
	     * @param target the target to watch.
	     */
	    addTarget(target: Container): void;
	    /**
	     * remove a target from the watch list
	     * @param target the target to remove.
	     */
	    removeTarget(target: Container): void;
	    set globalPointerVisibility(pValue: boolean);
	    private set renderer(value);
	    private _onDown;
	    private _onUp;
	    private _onOut;
	    private _onOver;
	    private _radian2degrees;
	    private _getTargetFromInteration;
	    private _onMove;
	    private set currentTarget(value);
	    private get currentTarget();
	}
}

declare module "@gdk/core-pixi/ui/baseui/ui/helpers" {
	import type { DisplayObject, interaction } from "pixi.js";
	export class Helpers {
	    /**
	     * Linearly interpolates between start and stop by amt
	     * @param start the start value
	     * @param stop the end value
	     * @param amt the interpolation value between the two values
	     */
	    static Lerp(start: number, stop: number, amt: number): number;
	    /**
	     * will release an interaction event in interaction manager.
	     * @param e the pixi interaction event to release
	     */
	    static releaseInteraction(e: interaction.InteractionEvent): void;
	    /**
	     * will emit an event with bubbling
	     * @param displayObject the display object at the origin of event.
	     * @param eventString event name
	     * @param eventData event datas.
	     */
	    static bubbleEmit(displayObject: DisplayObject, eventString: string, eventData: any): void;
	    /**
	     * Returns num rounded with decimals
	     * @param num number to round
	     * @param decimals number of decimals
	     */
	    static Round(num: number, decimals: number): number;
	    /**
	     * Cap value between min and max
	     * @param value value to cap
	     * @param min min value
	     * @param max max value
	     */
	    static Cap(value: number, min: number, max: number): number;
	    /**
	     * Returns an object of properties name depending of vertical parameter
	     * @param vertical vertical or horizontal
	     */
	    static getAxis(vertical: boolean): {
	        position: string;
	        size: string;
	        _position: string;
	        _size: string;
	    };
	    /**
	     * Convert number to hexadecimal string
	     * @param c number to convert
	     */
	    static componentToHex(c: number): string;
	    /**
	     * Convert rgb values to hexadecimal string
	     * @param r red value
	     * @param g green value
	     * @param b blue value
	     */
	    static rgbToHex(r: number, g: number, b: number): string;
	    /**
	     * Convert rgb values to number
	     * @param r red value
	     * @param g green value
	     * @param b blue value
	     */
	    static rgbToNumber(r: number, g: number, b: number): number;
	    /**
	     * Convert number to rgb components
	     * @param c number to convert
	     */
	    static numberToRgb(c: number): {
	        r: number;
	        g: number;
	        b: number;
	    };
	    /**
	     * convert hexadecimal value to rgb components
	     * @param hex hexadecimal values
	     */
	    static hexToRgb(hex: string | number): {
	        r: number;
	        g: number;
	        b: number;
	    };
	}
}

declare module "@gdk/core-pixi/ui/baseui/ui/symbolSprite" {
	import { Texture, Sprite } from "pixi.js";
	import type { IProjectContainer, IProjectSymbolSprite } from "@gdk/core-pixi/loading/model";
	export class SymbolSpriteError extends Error {
	}
	export class SymbolSprite extends Sprite {
	    static readonly instances: SymbolSprite[];
	    protected readonly _frames: {
	        [frameId: string]: Texture;
	    };
	    protected _defaultFrameId?: string;
	    protected _frameId?: string;
	    protected _sealed: boolean;
	    constructor(frames?: {
	        [frameId: string]: Texture;
	    }, sealed?: boolean, defaultFrameId?: string);
	    /**
	     * Position this SymbolSprite to the specified frame.
	     * Raise a SymbolSpriteError if frame is not registered.
	     */
	    goto(frameId: string): void;
	    getFrame(frameId: string): Texture;
	    protected throwIfNoFrame(frameId: string): void;
	    /**
	     * Register a texture
	     */
	    add(key: string, texture: Texture): void;
	    remove(frameId: string): void;
	    protected throwIfSealed(): void;
	    /**
	     * Return registered frames, by id.
	     */
	    get frames(): {
	        [frameId: string]: Texture;
	    };
	    get defaultFrameId(): string | undefined;
	    set defaultFrameId(frameId: string);
	    get frameId(): string | undefined;
	    /**
	     * Return symbol signature, a sha256 signature of ordered frame ids.
	     */
	    get signature(): string;
	    get sealed(): boolean;
	    seal(): void;
	    export(): IProjectContainer & IProjectSymbolSprite;
	    static parse(config: IProjectSymbolSprite, baseUrl: string, sprite?: SymbolSprite): SymbolSprite;
	}
}

declare module "@gdk/core-pixi/ui/baseui/ui/table" {
	import { Container } from "pixi.js";
	import { CSSLikeMargin } from "@gdk/core-pixi/ui/baseui/ui/cssLikeMargin";
	import { TableCell } from "@gdk/core-pixi/ui/baseui/ui/tableCell";
	export interface ITableOptions<T extends Container> {
	    margin?: CSSLikeMargin;
	    rows?: T[][];
	    fixedWidth?: number;
	    fixedColumnsWidth?: number[];
	    fixedHeight?: number;
	    fixedRowsHeight?: number[];
	}
	export class Table<T extends Container> extends Container {
	    protected margin: CSSLikeMargin;
	    protected cells: Array<Array<TableCell<T>>>;
	    protected column: number;
	    protected row: number;
	    protected fixedWidth: number;
	    protected fixedColumnsWidth: number[];
	    protected fixedHeight: number;
	    protected fixedRowsHeight: number[];
	    constructor(options?: ITableOptions<T>);
	    /**
	     * Set the fixed width
	     * @param fixedWidth
	     */
	    setFixedWidth(fixedWidth: number): void;
	    /**
	     * Set the fixed columns width
	     * @param fixedColumnsWidth
	     */
	    setFixedColumnsWidth(fixedColumnsWidth: number[]): void;
	    /**
	     * Set the fixed rows height
	     * @param fixedRowsHeight
	     */
	    setFixedRowsHeight(fixedRowsHeight: number[]): void;
	    /**
	     * Push new rows to the table
	     * @param rows
	     */
	    push(...rows: T[][]): void;
	    /**
	     * Add new rows at the top of the table
	     * @param rows
	     */
	    unshift(...rows: T[][]): void;
	    /**
	     * Pop the last row
	     */
	    pop(): Array<TableCell<T>>;
	    /**
	     * shift the first row
	     */
	    shift(): Array<TableCell<T>>;
	    /**
	     * Get a part of the table rows
	     * @param start
	     * @param end
	     */
	    slice(start?: number, end?: number): Array<Array<TableCell<T>>>;
	    /**
	     * Replace a part of the table rows
	     * @param start
	     * @param end
	     * @param rows
	     */
	    splice(start?: number, end?: number, ...rows: T[][]): Array<Array<TableCell<T>>>;
	    /**
	     * Get a column
	     * @param id
	     */
	    getColumn(id: number): Array<TableCell<T>>;
	    /**
	     * Get a row
	     * @param id
	     */
	    getRow(id: number): Array<TableCell<T>>;
	    /**
	     * Draw the table
	     */
	    draw(): void;
	    private updateSize;
	}
}

declare module "@gdk/core-pixi/ui/baseui/ui/cssLikeMargin" {
	export type CSSLikeMarginOptions = [number] | [number, number] | [number, number, number] | [number, number, number, number];
	export class CSSLikeMargin extends Array<number> {
	    constructor(options?: CSSLikeMarginOptions);
	    /**
	     * Get the top margin
	     */
	    get top(): number;
	    /**
	     * Set the top margin
	     */
	    set top(value: number);
	    /**
	     * Get the right margin
	     */
	    get right(): number;
	    /**
	     * Set the right margin
	     */
	    set right(value: number);
	    /**
	     * Get the bottom margin
	     */
	    get bottom(): number;
	    /**
	     * Set the bottom margin
	     */
	    set bottom(value: number);
	    /**
	     * Get the left margin
	     */
	    get left(): number;
	    /**
	     * Set the left margin
	     */
	    set left(value: number);
	    /**
	     * Get the total horizontal margin
	     */
	    get horizontal(): number;
	    /**
	     * Get the total vertical margin
	     */
	    get vertical(): number;
	    /**
	     * Clone the margin
	     */
	    clone(): CSSLikeMargin;
	}
}

declare module "@gdk/core-pixi/ui/baseui/ui/tableCell" {
	import { Container } from "pixi.js";
	import { CSSLikeMargin } from "@gdk/core-pixi/ui/baseui/ui/cssLikeMargin";
	export interface ITableCellOptions<T extends Container> {
	    content?: T;
	    margin?: CSSLikeMargin;
	    width?: number;
	    height?: number;
	    fixedWidth?: number;
	    fixedHeight?: number;
	}
	export class TableCell<T extends Container> extends Container {
	    protected content: T;
	    protected margin: CSSLikeMargin;
	    protected cellWidth: number;
	    protected cellHeight: number;
	    protected fixedWidth: number;
	    protected fixedHeight: number;
	    constructor(options: ITableCellOptions<T>);
	    /**
	     * Update the cell options
	     * @param options
	     */
	    updateOptions(options: ITableCellOptions<T>): void;
	    /**
	     * get the cell content
	     */
	    getContent(): T;
	    /**
	     * get the cell width
	     */
	    getWidth(): number;
	    /**
	     * get the cell height
	     */
	    getHeight(): number;
	    /**
	     * Get the cell fixed Width
	     */
	    getFixedWidth(): number;
	    /**
	     * get The cell fixed height
	     */
	    getFixedHeight(): number;
	    /**
	     * Draw the cell
	     */
	    draw(): void;
	}
}

declare module "@gdk/core-pixi/ui/spine/index" {
	export { SpineButton, TimelineInteractiveEvent, ISpineButtonParams, ISpineButtonAnimation, } from "@gdk/core-pixi/ui/spine/spineButton";
	export { SpineLogo, ISpineLogoParams } from "@gdk/core-pixi/ui/spine/spineLogo";
	export * from "@gdk/core-pixi/ui/spine/spineScratch";
}

declare module "@gdk/core-pixi/ui/spine/spineButton" {
	import type { WebGLRenderer, CanvasRenderer } from "pixi.js";
	import { Timeline } from "@gdk/core-pixi/spine/timeline";
	import { TextField } from "@gdk/core-pixi/ui/index";
	import type { ITimelineOptions } from "@gdk/core-pixi/spine/timeline";
	import type { ITimelineAnimationOptions } from "@gdk/core-pixi/spine/timelineAnimation";
	import type { IStyle, IStyles } from "@gdk/core-pixi/ui/index";
	export interface ISpineButtonParams extends ITimelineOptions {
	    label?: {
	        style: IStyle | IStyles;
	    };
	    skin?: string;
	    enable: boolean;
	    lockOnClick?: boolean;
	    animations?: ISpineButtonAnimation[];
	    callToAction?: {
	        label?: string;
	        minDelay: number;
	        maxDelay: number;
	    };
	}
	export interface ISpineButtonAnimation extends ITimelineAnimationOptions {
	    name: string;
	    event?: string | string[];
	    next?: string;
	    delay?: number;
	}
	export enum TimelineInteractiveEvent {
	    pointermove = "pointermove",
	    pointerdown = "pointerdown",
	    pointerleave = "pointerleave",
	    pointerenter = "pointerenter",
	    pointerover = "pointerover",
	    pointercancel = "pointercancel",
	    pointerup = "pointerup",
	    pointerupoutside = "pointerupoutside",
	    pointerout = "pointerout",
	    pointertap = "pointertap",
	    mousemove = "mousemove",
	    mousedown = "mousedown",
	    mouseout = "mouseout",
	    mouseover = "mouseover",
	    mouseup = "mouseup",
	    click = "click",
	    rightclick = "rightclick",
	    touchstart = "touchstart",
	    touchcancel = "touchcancel",
	    touchend = "touchend",
	    touchmove = "touchmove",
	    tap = "tap"
	}
	export interface IMap<T> {
	    [K: string]: T;
	}
	export class SpineButton extends Timeline {
	    labels: IMap<TextField>;
	    parameters: ISpineButtonParams;
	    private _enabled;
	    private _isOver;
	    private _isDown;
	    private _currentLabel;
	    private _interactionManager;
	    private ctaTimer;
	    private renderer;
	    static DEFAULT_STATES: ISpineButtonAnimation[];
	    /**
	     * Constructor
	     * @param options: spine button options
	     */
	    constructor(options: ISpineButtonParams);
	    /**
	     * Sets if the button is enabled
	     */
	    set enabled(value: boolean);
	    /**
	     * Returns if the button is enabled
	     */
	    get enabled(): boolean;
	    /**
	     * Sets the label's text
	     */
	    set label(value: string);
	    /**
	     * Gets the current label's text
	     */
	    get label(): string;
	    /**
	     * get pointer down status
	     */
	    get isDown(): boolean;
	    /**
	     * get pointer over status
	     */
	    get isOver(): boolean;
	    /**
	     * get pointer canceled status
	     */
	    set lockOnClick(value: boolean);
	    /**
	     * get pointer canceled status
	     */
	    get lockOnClick(): boolean;
	    private initLabel;
	    private buildLabel;
	    private initInteractionsProxies;
	    private initCTA;
	    private playCTA;
	    private resetCTA;
	    private getRandomBetween;
	    private getInteractionByName;
	    private proxyInteraction;
	    /**
	     * Render text with WebGL
	     * @param renderer the pixi.js renderer (WebGLRenderer)
	     * @override PIXI.Sprite.renderWebGL
	     */
	    renderWebGL(renderer: WebGLRenderer): void;
	    /**
	     * Render text with Canvas renderer
	     * @param renderer the pixi.js renderer (CanvasRenderer)
	     * @override PIXI.Sprite._renderCanvas
	     */
	    renderCanvas(renderer: CanvasRenderer): void;
	    private onInteractionEvent;
	    private onUserInteraction;
	    private cloneInteractionEventData;
	    /**
	     * will track the click, release the interaction, and disable the button, then set the button state to downLoop.
	     * @param e the interaction event
	     */
	    private triggerClick;
	    private trackClick;
	    /**
	     * Exports the current spine button
	     */
	    export(): any;
	    /**
	     * Parses the spine button
	     * @param config the serialized data
	     * @param baseUrl the base url of the loader
	     */
	    static parse(config: any, baseUrl: string, spineButton?: SpineButton): SpineButton;
	}
}

declare module "@gdk/core-pixi/ui/spine/spineLogo" {
	import { Amount } from "@gdk/core";
	import { Point } from "pixi.js";
	import type { ICurrencyOptions } from "@gdk/core";
	import type { Container } from "pixi.js";
	import { TextField } from "@gdk/core-pixi/ui/baseui/index";
	import { Timeline } from "@gdk/core-pixi/spine/index";
	import type { IStyle, IStyles } from "@gdk/core-pixi/ui/baseui/index";
	import type { ITimelineOptions, ITimelineAnimationOptions } from "@gdk/core-pixi/spine/index";
	export interface ISpineLogoParams extends ITimelineOptions {
	    stake?: {
	        id?: string;
	        style?: IStyle | IStyles;
	        value?: Amount | string;
	        options?: ICurrencyOptions;
	        offset?: Point;
	    };
	}
	export class SpineLogo extends Timeline {
	    stakeContainer: Container;
	    stakeTextfield: TextField;
	    parameters: ISpineLogoParams;
	    private _stakeValue;
	    /**
	     * Create a SpineLogo
	     * @param parameters {ISpineLogoParams} the spine logo settings inherrited from Timeline
	     * the only mendatory parametre is the spine animation "assetId".
	     */
	    constructor(parameters: ISpineLogoParams);
	    /**
	     * will start the logo animation
	     */
	    show(): void;
	    /**
	     * set stake value
	     * @param value{Amount|string} the value can be an Amount or a string
	     * if the stake is undefined or null the stake container will be hidden.
	     */
	    set stake(value: Amount | string);
	    get stake(): Amount | string;
	    /**
	     * set the stake container visibility
	     */
	    set stakeContainerVisibility(value: boolean);
	    /**
	     * Spine logo default animation sequence
	     * start with "enter" followed by 2 "idle" and finish with an "exit"
	     */
	    static DEFAULT_SEQUENCE: ITimelineAnimationOptions[];
	    /**
	     * Spine logo default animation sequence for home
	     * start with "enter", then loop on idle. Exit has to be called after.
	     */
	    static DEFAULT_HOME_SEQUENCE: ITimelineAnimationOptions[];
	    /**
	     * Exports the current game logo
	     */
	    export(): any;
	    /**
	     * Parses the spine logo
	     * @param config the serialized data
	     * @param baseUrl the base url of the loader
	     */
	    static parse(config: any, baseUrl: string, spineLogo?: SpineLogo): SpineLogo;
	}
}

declare module "@gdk/core-pixi/ui/spine/spineScratch" {
	import { Container } from "pixi.js";
	import { Timeline } from "@gdk/core-pixi/spine/timeline";
	import { Scratch } from "@gdk/core-pixi/ui/scratch/scratch";
	import { Scratch2 } from "@gdk/core-pixi/ui/scratch2/index";
	import type { ITimelineOptions } from "@gdk/core-pixi/spine/timeline";
	import type { ITimelineAnimationOptions } from "@gdk/core-pixi/spine/timelineAnimation";
	import type { IScratchOptions } from "@gdk/core-pixi/ui/scratch/scratch";
	import type { IScratch2Options } from "@gdk/core-pixi/ui/scratch2/index";
	/**
	 * Define a spineScratch.
	 * It extends the ITimelineOptions and add an array of IScratchSlotOptions
	 */
	export interface ISpineScratchOptions extends ITimelineOptions {
	    /**
	     * Define the scratchable areas you want in the SpineScratch.
	     */
	    scratchSlotsOptions: IScratchSlotOptions[];
	    /**
	     * Define the symbols below the scratchable areas.
	     */
	    symbolSlotsOptions: ISymbolSlotOptions[];
	}
	/**
	 * Define a scratchable area in a SpineScratch.
	 * It extends the IScratchOptions for the configuration of the scratch.
	 */
	export interface IScratchSlotOptions {
	    /**
	     * Name of the slot which will host the Scratch.
	     */
	    slotName: string;
	    /**
	     * @deprecated, use scratch2 instead.
	     * Scratch or definition of the scratch to place in the slot.
	     */
	    scratch?: IScratchOptions | Scratch;
	    /**
	     * Scratch2 or definition of the scratch2 to place in the slot.
	     */
	    scratch2?: IScratch2Options | Scratch2;
	    /**
	     * When content is a Timeline which contains spine defined hitareas,
	     * the scratch will use them as hitarea.
	     */
	    useContentTimelineHitArea?: boolean;
	}
	/**
	 * Define a symbol in a SpineScratch.
	 */
	export interface ISymbolSlotOptions {
	    /**
	     * Name of the slot which will host the Symbol.
	     */
	    slotName: string;
	    /**
	     * Symbol or definition of the symbol to place in the slot.
	     */
	    symbol: ITimelineOptions | Timeline;
	}
	/**
	 * Container of a Scratch.
	 */
	export interface IScratchSlot {
	    slotName: string;
	    scratch: Scratch | Scratch2;
	    content: Container;
	    useContentTimelineHitArea: boolean;
	}
	/**
	 * Container of a symbol.
	 */
	export interface ISymbolSlot {
	    slotName: string;
	    symbol: Timeline;
	}
	export enum ESpineScratchEvent {
	    ReadyToScratch = "readytoscratch",
	    AllScratchsRevealed = "allscratchsrevealed",
	    Exited = "exited"
	}
	/**
	 * @experimental
	 * Timeline with scratchable content and timeline symbols.
	 */
	export class SpineScratch extends Timeline {
	    static DEFAULT_SEQUENCE: ITimelineAnimationOptions[];
	    scratchSlots: IScratchSlot[];
	    symbolSlots: ISymbolSlot[];
	    /**
	     * Instantiate a SpineScratch.
	     * @param parameters ITimelineOptions for the base animation.
	     * @param scratchOptions Array of IScratchSlotOptions to define the scratchables zones in the Timeline.
	     */
	    constructor(parameters: ISpineScratchOptions);
	    /**
	     * Play the "enter" animation of the Timeline.
	     */
	    enter(): void;
	    /**
	     * Play the "exit" animation of the Timeline.
	     */
	    exit(): void;
	    /**
	     * Call the auto method of each scratch in the SpineScratch.
	     */
	    auto(): void;
	    /**
	     * Stop the animation, hide the container and reset the scratchs.
	     */
	    reset(): void;
	    private _resetScratchs;
	    /**
	     * Enable the scratchs.
	     */
	    enableScratchs(): void;
	    /**
	     * Disable the scratchs.
	     */
	    disableScratchs(): void;
	    /**
	     * Wait for the SpineScratch to play the enter animation and then to enable the scratchs.
	     */
	    waitToBeReadyToScratch(): Promise<void>;
	    /**
	     * Wait for all the scratchs to be revealed.
	     */
	    waitForAllScratchsRevealed(): Promise<void>;
	    /**
	     * Wait for the SpineScratch to finish the exit animation.
	     */
	    waitForExited(): Promise<void>;
	    private _waitFor;
	    private _listenForScratchsRevealation;
	    private _setupAnimations;
	    private _onAnimationStart;
	    private _onAnimationComplete;
	    private _setupSymbols;
	    private _setupSymbol;
	    private _getSymbol;
	    private _setupScratchs;
	    private _setupScratch;
	    private _prepareScratchSlot;
	    private _setupScratchContentTimelineHitArea;
	    /**
	     * @deprecated
	     */
	    private _prepareScratch;
	    private _prepareScratch2;
	    /**
	     * @deprecated
	     */
	    private _getScratch;
	    private _getScratch2;
	    /**
	     * Export SpineScratch component for editor games.
	     */
	    export(): any;
	    /**
	     * Parse SpineScratch component for editor games.
	     * @param config SpineScratch configuration
	     * @param baseUrl the baseUrl
	     * @param spineScratch optionnal instance of the SpineScratch
	     */
	    static parse(config: any, baseUrl: string, spineScratch?: SpineScratch): SpineScratch;
	}
}

declare module "@gdk/core-pixi/ui/scratch/scratch" {
	import { Container, Sprite } from "pixi.js";
	import type { CanvasRenderer, WebGLRenderer } from "pixi.js";
	import { ParticlesMaskRenderer } from "@gdk/core-pixi/ui/scratch/particlesMaskRenderer";
	import type { Scratchable } from "@gdk/core-pixi/ui/scratch/scratchable";
	import type { IScratchSounds } from "@gdk/core-pixi/ui/scratch/scratchSolver";
	import type { ScratchPath } from "@gdk/core-pixi/ui/scratch/scratchPath";
	/**
	 * the options available for this scratch component.
	 */
	export interface IScratchOptions {
	    content: Sprite | Container;
	    invert?: boolean;
	    clamp?: boolean;
	    revealRatio?: number;
	    revealCompleteRatio?: number;
	    autoPath?: ScratchPath;
	    emitterDatas?: any[];
	    emitterRevealDatas?: any[];
	    sounds?: IScratchSounds;
	    resolution?: number;
	    disableCacheAsBitmap?: boolean;
	    alwaysUpdateTransform?: boolean;
	}
	export class Scratch extends Container implements Scratchable {
	    renderer: ParticlesMaskRenderer;
	    stopped: boolean;
	    options: IScratchOptions;
	    onReady: () => void;
	    onReveal: () => void;
	    onRevealComplete: () => void;
	    onScratch: () => void;
	    private _proton;
	    private _scratchEmitter;
	    private _revealEmitter;
	    private _isAuto;
	    private _rectZone;
	    private _autoRevealTimeline;
	    private _renderedThatFrame;
	    private _pixiRenderer;
	    private _isWebgl;
	    /**
	     * will build a Scratch Container
	     * @param props scratch settings
	     */
	    constructor(props: IScratchOptions);
	    private oncePreRender;
	    private oncePostRender;
	    private hideContent;
	    private onPreRender;
	    private onPostRender;
	    /**
	     * switch the scratch in performance mode (frame by frame mask).
	     */
	    modePerformance(): void;
	    /**
	     * return true if this scratch was updated by mouse/touch or by particle update
	     */
	    get active(): boolean;
	    /**
	     * return ther TweenMax globalTimeScale
	     */
	    get globalTimeScale(): number;
	    /**
	     * stops the particles system
	     */
	    stop(): void;
	    private stopScratchEmitter;
	    private stopRevealEmitter;
	    /**
	     * start auto reveal.
	     */
	    auto(): void;
	    /**
	     * get reveal ratio
	     */
	    getProgress(): number;
	    /**
	     * reset scratch.
	     */
	    reset(): void;
	    /**
	     * perform a proton particle update()
	     */
	    update(): void;
	    /**
	     * catch (canvas) renderer
	     */
	    renderCanvas(renderer: CanvasRenderer): void;
	    /**
	     * catch (WebGL) renderer
	     */
	    renderWebGL(renderer: WebGLRenderer): void;
	    /**
	     * EmitterParser.parse() temporary fix.
	     */
	    private _parse;
	    /**
	     * inits proton and particules emiters
	     */
	    private _initParticules;
	    /**
	     * add a proton custom behavior for radius property
	     */
	    private _addScaleBehavior;
	    /**
	     * add a proton custom behavior for radius property
	     */
	    private _addCustumRadiusBehavior;
	    private _addRotateInitializer;
	    private _valueOrSpan;
	    /**
	     * get Proton.Body from texture
	     */
	    private _createParticuleSprite;
	    /**
	     * gets the number of active particules
	     */
	    get particulesCount(): number;
	    /**
	     * Sets if the scratch is enabled
	     */
	    set enabled(value: boolean);
	    /**
	     * gets if the scratch is enabled
	     */
	    get enabled(): boolean;
	    /**
	     * gets if the scratch is revealed
	     */
	    get isRevealed(): boolean;
	    /**
	     * gets if the scratch is in auto mode
	     */
	    get isAuto(): boolean;
	    /**
	     * sets the revealed pixel ratio to trigger auto mode
	     * @param value {number} the ratio
	     */
	    set revealRatio(value: number);
	    /**
	     * return the revealed pixel ratio to trigger auto mode
	     */
	    get revealRatio(): number;
	    /**
	     * sets the revealed pixel ratio to trigger auto mode completion
	     * @param value {number} the ratio
	     */
	    set revealCompleteRatio(value: number);
	    /**
	     * return the revealed pixel ratio to trigger auto mode completion
	     */
	    get revealCompleteRatio(): number;
	    /**
	     * sets the auto scratch path
	     * @param path {ScratchPath} the path
	     */
	    set autoPath(path: ScratchPath);
	    /**
	     * return the auto scratch path
	     */
	    get autoPath(): ScratchPath;
	    /**
	     * sets the emitter datas from JSON to change the scratch emitter settings
	     * @param datas {object} the protton emmitter settings to parse
	     */
	    set emitterDatas(datas: any[]);
	    /**
	     * sets the reveal emitter datas from JSON to change the auto scratch emitter settings
	     * @param datas {object} the protton emmitter settings to parse
	     */
	    set revealEmitterDatas(datas: any[]);
	    /**
	     * Exports the scratch component
	     */
	    export(): any;
	    /**
	     * Parses the scratch component
	     * @param config the configuration of the scratch component
	     * @param baseUrl the base url of the loader
	     */
	    static parse(config: any, baseUrl: string): Scratch;
	}
}

declare module "@gdk/core-pixi/ui/scratch/particlesMaskRenderer" {
	import Proton from "proton-js";
	import { Sprite, Container } from "pixi.js";
	import type { SystemRenderer, WebGLRenderer, CanvasRenderer } from "pixi.js";
	/**
	 * Scratch renderer options
	 */
	export interface IScratchRendererOptions {
	    content: Container | Sprite;
	    revealRatio: number;
	    revealCompleteRatio: number;
	    invert: boolean;
	    clamp: boolean;
	    resolution: number;
	    alwaysUpdateTransform: boolean;
	}
	export class ParticlesMaskRenderer extends Proton.CanvasRenderer {
	    name: string;
	    output: Container;
	    updated: boolean;
	    revealRatio: number;
	    revealed: boolean;
	    revealComplete: boolean;
	    pixiRenderer: SystemRenderer;
	    stopped: boolean;
	    onReveal: () => void;
	    onRevealComplete: () => void;
	    onScratch: () => void;
	    onFirstRenderComplete: () => void;
	    element: HTMLCanvasElement;
	    oneClick: boolean;
	    content: Container | Sprite;
	    clampValue: number;
	    private _scratchStep;
	    private _scratchDistance;
	    private _protonCanvas;
	    private _protonContext;
	    private _outputCanvas;
	    private _outputContext;
	    private _rendertexture;
	    private _isWebgl;
	    private _outputTexture;
	    private _resolution;
	    private _revealRatio;
	    private _revealCompleteRatio;
	    private activeParticulesCount;
	    private _canvasCompositeOperation;
	    private _resetting;
	    private scratchStepDistance;
	    private _debugDiv;
	    private _invert;
	    private _clamp;
	    private _mask;
	    private _alwaysUpdateTransform;
	    isDirty: boolean;
	    /**
	     * will instanciate a proton canvas and will use it to draw mask
	     * @param options mask renderer settings
	     */
	    constructor(options: IScratchRendererOptions);
	    /**
	     * Gets wether or not the particle mask render is set to invert mode
	     */
	    get invert(): boolean;
	    /**
	     * Sets wether or not the particle mask render is set to invert mode
	     */
	    set invert(value: boolean);
	    /**
	     * Gets wether or not clamping is enabled
	     */
	    get clamp(): boolean;
	    set clamp(value: boolean);
	    /**
	     * Resizes the renderer (this and output canvas)
	     * @param width the new width
	     * @param height the new height
	     */
	    resize(width: number, height: number): void;
	    /**
	     * on particle update callback (emited by Proton)
	     */
	    onParticleUpdate(particle: Proton.particle): void;
	    /**
	     * on proton update callback (emited by Proton)
	     */
	    onProtonUpdate(): void;
	    /**
	     * canvas render
	     */
	    renderCanvas(renderer: CanvasRenderer): void;
	    /**
	     * webgl render
	     */
	    renderWebGL(renderer: WebGLRenderer): void;
	    /**
	     * will perform a render of the output context
	     */
	    renderOutput(): void;
	    /**
	     * clear canvas and textures (reset image datas)
	     */
	    clear(): void;
	    /**
	     * on particle created callback (emited by Proton)
	     */
	    onParticleCreated(particle: any): void;
	    /**
	     * on particle death callback (emited by Proton)
	     */
	    onParticleDead(particle: any): void;
	    /**
	     * will force reveal (fill, render, pixeldetection, events...)
	     */
	    forceReveal(): void;
	    /**
	     * stops the renderer
	     */
	    stop(): void;
	    /**
	     * will perform a frame by frame update
	     * @param distance the distance traveled by the pointer since last updateFame.
	     */
	    updateFrame(distance: number): void;
	    /**
	     * resets the renderer
	     */
	    reset(): void;
	    set cacheAsBitmap(value: boolean);
	    get cacheAsBitmap(): boolean;
	    /**
	     * render output texture
	     */
	    private _renderOutput;
	    /**
	     * image data copy (faster than drawing or rendering canvas)
	     */
	    private _copyImageData;
	    /**
	     * first render after creation
	     */
	    private _firstRender;
	    /**
	     * fill canvas and textures when complete
	     */
	    private _fill;
	    /**
	     * copy image data and test if
	     */
	    private _updateImageData;
	    /**
	     * test if reveal is complete
	     */
	    private completionTest;
	}
}

declare module "@gdk/core-pixi/ui/scratch/scratchable" {
	import { Container } from "pixi.js";
	export abstract class Scratchable extends Container {
	    static REVEAL_EVENT: string;
	    static FULL_REVEAL_EVENT: string;
	    static AUTO_EVENT: string;
	    isRevealed: boolean;
	    isAuto: boolean;
	    auto: () => void;
	    getProgress: () => number;
	    reset: () => void;
	}
}

declare module "@gdk/core-pixi/ui/scratch/scratchSolver" {
	import type { Howl } from "howler";
	import type { Scratch } from "@gdk/core-pixi/ui/scratch/scratch";
	export interface IScratchSounds {
	    scratch: IScratchSoundsInstance;
	    reveal: IScratchSoundsInstance;
	    win?: IScratchSoundsInstance;
	    lose?: IScratchSoundsInstance;
	}
	export interface IScratchSoundsInstance {
	    id?: number;
	    name?: string;
	    instance?: Howl;
	    solo?: boolean;
	}
	export enum ESounds {
	    Scratch = "scratch",
	    Reveal = "reveal",
	    Win = "win",
	    Lose = "lose"
	}
	export class ScratchSolver {
	    private _scratchs;
	    private _currentScratch;
	    private _numberOfPasses;
	    private _scratchsCount;
	    private _maxSimultaneousUpdates;
	    private _maxUpdateRatio;
	    private _sounds;
	    private _oneClick;
	    private _particulesCount;
	    /**
	     * will be instanciated by get instance
	     */
	    private constructor();
	    private benchmark;
	    /**
	     * resets all registered scrach
	     */
	    resetAll(): void;
	    /**
	     * register a new scratch
	     */
	    add(scratch: Scratch): void;
	    /**
	     * update handler
	     */
	    private _update;
	    private _adaptativeScratchRatio;
	    /**
	     * will compute maxSimultaneousUpdates from max update ratio
	     */
	    private _updateMaxSimultaneousUpdates;
	    /**
	     * will switch to performance mode
	     */
	    private _modePerformance;
	    /**
	     * returns active scratchs
	     */
	    private _getActiveScratchs;
	    private _playSound;
	    private _stopSound;
	    /**
	     * define maxUpdate ratio
	     */
	    set maxUpdateRatio(value: number);
	    private static _instance;
	    /**
	     * get singleton instance
	     */
	    static get instance(): ScratchSolver;
	    /**
	     * get all registered scratchs
	     */
	    static get scratchs(): Scratch[];
	    /**
	     * Register scratch sound
	     * @param sounds sound to register
	     */
	    static registerSounds(sounds: IScratchSounds): void;
	    /**
	     * Play scratch sound
	     * @param soundName name of the sound to play
	     */
	    static playSound(soundName: string): void;
	}
}

declare module "@gdk/core-pixi/ui/scratch/scratchPath" {
	import { Container } from "pixi.js";
	import { SVGGraphics } from "@gdk/core-pixi/svg/SVGGraphics";
	import type { IDrawStyle } from "@gdk/core-pixi/svg/SVGGraphics";
	export interface IScratchPathOptions {
	    assetID: string;
	    resolution?: number;
	    duration: number;
	    drawStyle?: IDrawStyle;
	}
	export interface IPathPoint {
	    x: number;
	    y: number;
	}
	export class ScratchPath extends Container {
	    duration: number;
	    svg: SVGGraphics;
	    values: IPathPoint[];
	    private _width;
	    private _height;
	    private _resolution;
	    /**
	     * will build create an SVG, and extract points arrays from it.
	     * this will be used as a travelable path.
	     * @param options IScratchPathOptions { duration: number, svg: SVGGraphics, values: IPathPoint[] }
	     */
	    constructor(options: IScratchPathOptions);
	    /**
	     * define the size of the svg shape and scale all the points.
	     * will be called by the Scratch to fit on it.
	     * @param width the desired width of the shape
	     * @param height the desired height of the shape
	     * @param resolution the scale ratio of the scratch.
	     */
	    setSize(width: number, height: number, resolution: number): void;
	}
}

declare module "@gdk/core-pixi/ui/scratch2/index" {
	export * from "@gdk/core-pixi/ui/scratch2/scratch2";
	export * from "@gdk/core-pixi/ui/scratch2/types";
	export * from "@gdk/core-pixi/ui/scratch2/renderers/index";
	export * from "@gdk/core-pixi/ui/scratch2/zone";
	export * from "@gdk/core-pixi/ui/scratch2/scratch2Presets";
}

declare module "@gdk/core-pixi/ui/scratch2/scratch2" {
	import { RenderTexture, Container } from "pixi.js";
	import type { Howl } from "howler";
	import type { ITrackableObject } from "@gdk/core";
	import type { WebGLRenderer, CanvasRenderer } from "pixi.js";
	import { CustomPointer } from "@gdk/core-pixi/ui/baseui/ui/customPointer";
	import { Scratch2Zone } from "@gdk/core-pixi/ui/scratch2/zone";
	import type { IEmitterConfig } from "@gdk/core-pixi/proton/parser2/index";
	import type { IScratch2Options, AbstractScratch2Renderer } from "@gdk/core-pixi/ui/scratch2/types";
	import type { IPointerEvent } from "@gdk/core-pixi/ui/baseui/ui/customPointer";
	import type { ScratchPath } from "@gdk/core-pixi/ui/scratch/scratchPath";
	export class Scratch2 extends Container implements ITrackableObject {
	    /**
	     * Defines the optional name of the object to be tracked.
	     * If unset, a default value will be taken by the tracker. For example,
	     * the name of the object (button, scratch, etc.).
	     */
	    trackingName: string;
	    /**
	     * The scratchable content container being rendered over the container to be hidden by the scratch.
	     */
	    content: Container;
	    /**
	     * The current scratch options used to configure/customize the scratch.
	     */
	    options: IScratch2Options;
	    /**
	     * The renderer being used to render the scratch mask.
	     */
	    renderer: AbstractScratch2Renderer;
	    /**
	     * Sets wether or not the optimizations should be disabled. Configuration will not be exported and must be set carefuly.
	     */
	    disableOptimizations: boolean;
	    /**
	     * Defines the increment value while traversing the scratch's pixels to determine if it should be revealed or not.
	     */
	    pixelIncrementValue: number;
	    /**
	     * Defines the zones to reveal. This is used mainly to save performances (draw calls). Only one scratch that can define multiple zones.
	     */
	    zones: Scratch2Zone[];
	    /**
	     * Defines if the scratch component should be able to scratch outside of the zones.
	     */
	    scratchOnlyZones: boolean;
	    /**
	     * Defines if the global auto-scratch should be triggered once all zones have been revealed complete.
	     * Means that once all zones are revealed complete, the global auto-scratch will not be triggered if property is set to "true".
	     * The basic steps for scratch that contains zones is:
	     * 	- scratch each zone
	     * 	- auto reveal zone once reveal ratio is reached for the zone
	     * 	- once all zones have been auto-revealed, auto-reveal the overall scratch.
	     * Setting this property to "true", removes the last step.
	     */
	    enableAutoScratchOnlyOnZones: boolean;
	    /**
	     * Sets wether or not the scratch should force reveal the revealed zone on the auto-mode has finished.
	     */
	    forceRevealZoneOnAutoDone: boolean;
	    /**
	     * Optional callback called once the scratch component is ready to be rendered.
	     */
	    onReady: () => void;
	    /**
	     * Optional callback called on the scratch is being revealed.
	     */
	    onReveal: () => void;
	    /**
	     * Optional callback called on the given scratch zone is being revealed.
	     * @param zone in case of multiple zones, the given zone reference represents the zone being revealed.
	     */
	    onRevealZone: (zone: Scratch2Zone) => void;
	    /**
	     * Optional callback called once the scratch has been completely revealed.
	     */
	    onRevealComplete: () => void;
	    /**
	     * Optional callback called once the given scratch zone has been completely revealed.
	     * @param zone in case of multiple zones, the given zone reference represents the zone that has been revealed.
	     */
	    onRevealCompleteZone: (zone: Scratch2Zone) => void;
	    /**
	     * Optional callback called on the user is scratching the component
	     * @param zone in case of multiple zones, the given zone reference represents the zone being scratched.
	     */
	    onScratch: (zone?: Scratch2Zone) => void;
	    /**
	     * Defines the optional callback called on the ratio of scratched content changed on the scratch.
	     * @param oldRatio defines the old ratio before update.
	     * @param newRatio: defines the new ratio of the scratched content.
	     */
	    onRatioChange: (oldRatio: number, newRatio: number) => void;
	    /**
	     * The render texture used to store the scratch's mask data (pixels).
	     */
	    scratchRenderTexture: RenderTexture;
	    /**
	     * Defines the auto path that renderers will use to scratch the content when in auto mode.
	     * Typically used by the @ParticlesScratchRenderer and @DefaultScratchRenderer.
	     */
	    autoPath: ScratchPath;
	    /**
	     * Defines the auto path that renderers will use to scratch the content of a zone when in auto mode.
	     * Typically used by the @ParticlesScratchRenderer and @DefaultScratchRenderer.
	     */
	    zoneAutoPath: ScratchPath;
	    /**
	     * The render texture used to store the content's data (pixels)
	     * Only used while using the canvas renderer to perform composite operations.
	     */
	    protected contentRenderTexture: RenderTexture;
	    /**
	     * Custom pointer reference used to calculate pointer position, direction etc.
	     */
	    protected pointer: CustomPointer;
	    private _firstRender;
	    private _isReady;
	    private _isWebGL;
	    private _isDirty;
	    private _shouldBeCleared;
	    private _shouldCheckComplete;
	    private _pixiRenderer;
	    private _maskSprite;
	    private _maskFilter;
	    private _maskCanvas;
	    private _maskContext;
	    private _progress;
	    private _oldProgress;
	    private _isComplete;
	    private _lastCompleteTime;
	    private _clampingEnabled;
	    private _lastPerformanceTime;
	    private _performanceAverageTime;
	    private _performanceElapsedTime;
	    private _performanceFramesCount;
	    private _isAuto;
	    private _defaultZone;
	    private _debugZonesGraphics;
	    private _debugZonesColors;
	    private _zonesToForceReveal;
	    private _scratchPreset;
	    private _autoPreset;
	    private _autoZonePreset;
	    private _cursor;
	    private static _autoZones;
	    /**
	     * Sound reference used to be played on the user is scratching a Scratch2 component.
	     */
	    static scratchSound: Howl;
	    /**
	     * Sound reference used to be played on a Scratch2 component is being revealed.
	     */
	    static revealSound: Howl;
	    private static _scratchSoundTimeoutId;
	    /**
	     * Constructor.
	     * @param options the options used to configure/customize the newly scratch being created.
	     */
	    constructor(options: IScratch2Options);
	    /**
	     * Gets the scratch preset that particles renderer (optimal scratch renderer) uses when scratching.
	     * @see Scratch2Presets to change scratch preset.
	     */
	    get scratchPreset(): IEmitterConfig;
	    /**
	     * Sets the scratch preset that particles renderer (optimal scratch renderer) uses when scratching.
	     * @see Scratch2Presets to change scratch preset.
	     */
	    set scratchPreset(preset: IEmitterConfig);
	    /**
	     * Gets the auto preset that particles renderer (optimal scratch renderer) uses when auto-scratching.
	     * @see Scratch2Presets to change scratch preset.
	     */
	    get autoPreset(): IEmitterConfig;
	    /**
	     * Sets the auto preset that particles renderer (optimal scratch renderer) uses when auto-scratching.
	     * @see Scratch2Presets to change preset.
	     */
	    set autoPreset(preset: IEmitterConfig);
	    /**
	     * Gets the auto preset that particles renderer (optimal scratch renderer) uses when auto-scratching a zone.
	     * @see Scratch2Presets to change preset.
	     */
	    get autoZonePreset(): IEmitterConfig;
	    /**
	     * Gets the auto preset that particles renderer (optimal scratch renderer) uses when auto-scratching a zone.
	     * @see Scratch2Presets to change preset.
	     */
	    set autoZonePreset(preset: IEmitterConfig);
	    /**
	     * Sets the new cursor being used by the scratch.
	     */
	    setCursor(cursor: string): void;
	    /**
	     * Renders the scratch using the WebGL renderer.
	     * @param renderer the webgl renderer reference.
	     */
	    renderWebGL(renderer: WebGLRenderer): void;
	    /**
	     * Renders the scratch using the canvas renderer.
	     * @param renderer the canvas renderer reference.
	     */
	    renderCanvas(renderer: CanvasRenderer): void;
	    /**
	     * Stops the scratch component. Typically used to pause in auto-mode etc.
	     */
	    stop(): void;
	    /**
	     * Sets the new renderer of the scratch component.
	     * @param renderer the new renderer to use while rendering scratch.
	     */
	    setRenderer(renderer: AbstractScratch2Renderer): void;
	    /**
	     * Resizes the scratch renderer being used as a mask for the content.
	     * @param width the new width of the scratch (default: content.width).
	     * @param height the new height of the scrach (default: content.height).
	     */
	    resizeMask(width?: number, height?: number): void;
	    /**
	     * Gets wether or not the scratch component has been revealed.
	     */
	    get isRevealed(): boolean;
	    /**
	     * Gets wether or not the scratch component is in auto mode.
	     */
	    get isAuto(): boolean;
	    /**
	     * Gets the current progression of the scratch component in the interval [0,1].
	     * 0 = never scratched
	     * 1 = fully scratched (revealed)
	     */
	    get progress(): number;
	    /**
	     * Reveals the result by hiding the scratchable content.
	     */
	    reveal(): void;
	    /**
	     * Forces the reveal by hiding the scratchable content.
	     * @param zone the optional zone that must be instant revealed.
	     */
	    forceReveal(zone?: Scratch2Zone): void;
	    /**
	     * Automatically reveals the scratch component by animating the scratch movement.
	     * @param zone the zone to automatically reveal. @see .zones.
	     */
	    auto(zone?: Scratch2Zone): Promise<void>;
	    /**
	     * Resets the scratch component
	     */
	    reset(): void;
	    /**
	     * Returns if the scratch is complete according to the reveal ratio.
	     * @param pixels the pixels array to test
	     * @param force wether or not the check is forced. Typically used by the .stop function.
	     * @param doNotNotify wether or not the check should notify if the scratch is complete or not. (typically used by the .stop function).
	     */
	    isComplete(renderer: CanvasRenderer | WebGLRenderer, force?: boolean, doNotNotify?: boolean): void;
	    /**
	     * Flags the scratch as dirty.
	     * Setting as dirty will enable the completion test and disable caching to update the frame.
	     */
	    setDirty(zone?: Scratch2Zone): void;
	    /**
	     * Returns the current clamping value. If 0.0, then clamping is disabled.
	     */
	    get clampValue(): number;
	    /**
	     * Sets the clamp value. If 0.0, then clamping is disabled.
	     */
	    set clampValue(value: number);
	    /**
	     * Gets wether or not the scratch is in inverted mode.
	     */
	    get inverted(): boolean;
	    /**
	     * Sets wether or not the scratch is in inverted mode.
	     */
	    set inverted(inverted: boolean);
	    /**
	     * Resets the filter.
	     */
	    private _resetFilter;
	    /**
	     * Gets the default zone of the scratch component.
	     * @see .zones
	     */
	    get defaultZone(): Scratch2Zone;
	    /**
	     * Returns the reference of the first found zone that is indentified by the given identifier.
	     * @param id defines the identifier of the zone to get.
	     */
	    getZoneById(id: string): Scratch2Zone;
	    /**
	     * Plays the scratch sound. Typically used by the renderers.
	     * @hidden
	     */
	    _playScratchSound(): void;
	    /**
	     * Called once the user scratchs the scratch component.
	     * @param target the target container where pointer is moving.
	     * @param datas object that contains all the pointer event values (distance, etc.).
	     */
	    protected onMove(target: Container, datas: IPointerEvent): void;
	    /**
	     * Returns wether or not the given zone contains the given pointer coordinates (x,y)
	     * @param zone the zone to check
	     * @param coordinates the pointer coordinates
	     */
	    private _zoneContainsCoordinates;
	    /**
	     * Computes the optimizer which switches from
	     */
	    protected computeOptimizer(): void;
	    /**
	     * Sends the tracking event for scratch performances switch.
	     */
	    private _trackPerformancesDrop;
	    /**
	     * Only for debug purpose, shows the zones by drawing some graphics.
	     */
	    _showZones(): void;
	    /**
	     * Only for debug purpose, hides the zones by drawing some graphics.
	     */
	    _hideZones(): void;
	    /**
	     * Clears all the graphics used to instant reveal zones.
	     */
	    private _clearZonesToForceReveal;
	    /**
	     * Forces reveal the scratch and marks all zones reveal complete.
	     */
	    private _forceRevealAndMarkZones;
	    /**
	     * Exports the current scratch2 configuration
	     */
	    export(): any;
	    /**
	     * Parses the given scratch configuration to return a new scratch component
	     * @param config the configuration of the scratch component being created
	     * @param baseUrl the base url of the loader
	     */
	    static parse(config: any, baseUrl: string): Scratch2;
	}
}

declare module "@gdk/core-pixi/ui/scratch2/zone" {
	import { Rectangle } from "pixi.js";
	import type { HitArea, Graphics } from "pixi.js";
	export class Scratch2Zone {
	    /**
	     * Defines the optional identifier of the zone. Useful when getting a Scratch2
	     * reference from the GDK Editor.
	     * @see Scratch2.prototype.getZoneById
	     */
	    id: string;
	    /**
	     * The rectangle reference defining the zone.
	     */
	    rectangle: Rectangle;
	    /**
	     * Sets or gets wether or not the zone has been revealed.
	     */
	    revealed: boolean;
	    /**
	     * Sets or gets wether or not the zone has been revealed completely.
	     */
	    revealedComplete: boolean;
	    /**
	     * Custom ratio in interval [0, 1] to determine when the scratch zone has been enought scratched in order to reveal result.
	     */
	    revealRatio: number;
	    /**
	     * Sets or gets the current progression on scratching.
	     */
	    progress: number;
	    /**
	     * Defines the custom hit area of the zone that will be tested to check if user is scratching on this zone.
	     */
	    hitArea: HitArea;
	    /**
	     * Sets or gets wether or not the zone is active.
	     */
	    isActive: boolean;
	    /**
	     * Called on the user is scratching the zone.
	     */
	    onScratch: () => void;
	    /**
	     * Called on the zone is being revealed.
	     */
	    onReveal: () => void;
	    /**
	     * Called on the zone has been revealed completely.
	     */
	    onRevealComplete: () => void;
	    /**
	     * To simplify code, we a graphics here that will be used by the scratch2 to instant
	     * reveal the zone. The basic method would be to hide the zone as we do for the global scratch2 but
	     * zones are not Container.
	     * @hidden
	     */
	    _waitingForceRevealGraphics: Graphics;
	    /**
	     * Sets or gets wether or not the zone is dirty. i.e check dirty only on zones instead of testing the
	     * overall scratch2 zones.
	     * @hidden
	     */
	    _isDirty: boolean;
	    /**
	     * Constructor
	     * @param x the start x position of the zone relative to the scratch component.
	     * @param y the start y position of the zone relative to the scratch component.
	     * @param width the width of the zone in pixels.
	     * @param height the height of the zone in pixels.
	     */
	    constructor(x: number, y: number, width: number, height: number);
	    /**
	     * Resets the zone's state.
	     */
	    reset(): void;
	    /**
	     * Gets the current position of the zone on the X axis.
	     */
	    get x(): number;
	    /**
	     * Gets the current position of the zone on the Y axis.
	     */
	    get y(): number;
	    /**
	     * Gets the current width of the zone.
	     */
	    get width(): number;
	    /**
	     * Gets the current height of the zone.
	     */
	    get height(): number;
	    /**
	     * Exports the current zone configuration
	     */
	    export(): any;
	    /**
	     * Parses the given zone configuration to return a new zone component
	     * @param config the configuration of the scratch component being created
	     */
	    static parse(config: any): Scratch2Zone;
	}
}

declare module "@gdk/core-pixi/ui/scratch2/types" {
	import { Container } from "pixi.js";
	import type { Scratch2 } from "@gdk/core-pixi/ui/scratch2/scratch2";
	import type { DefaultScratchRenderer, OneClickScratchRenderer } from "@gdk/core-pixi/ui/scratch2/renderers/index";
	import type { Scratch2Zone } from "@gdk/core-pixi/ui/scratch2/zone";
	import type { ScratchPath } from "@gdk/core-pixi/ui/scratch/scratchPath";
	import type { IPointerEvent } from "@gdk/core-pixi/ui/baseui/ui/customPointer";
	/**
	 * Interface used to configure/customize the newly scratch being created
	 */
	export interface IScratch2Options {
	    /**
	     * The content container being scratchable. This content will be drawn by the scratch component and will be masked using
	     * the scratch renderer.
	     */
	    content: Container;
	    /**
	     * The renderer instance to be used
	     */
	    renderer: AbstractScratch2Renderer;
	    /**
	     * As the pixi.js resolution, the final dimensions (width/height) of the scratch will be multiplied by this value.
	     * Default value is 0.5.
	     */
	    resolution?: number;
	    /**
	     * Sets wether or not caching is enabled or not. Caching means that the scratch component will cache its rendering result until
	     * the user scratches again. Should be disabled typically when content contains animated elements (spines, etc.).
	     * Default value is "false".
	     * Available only when rendering using WebGL.
	     */
	    disableCaching?: boolean;
	    /**
	     * Ratio in interval [0, 1] to determine when the scratch has been enought scratched in order to reveal result.
	     * Default value is 0.7.
	     */
	    revealRatio?: number;
	    /**
	     * Defines the clamping value. Clamping means:
	     * - if pixel color < clampValue then pixel color = 0.0;
	     * - if pixel color >= clampValue then pixel color = 1.0;
	     * Only supported using WebGL renderer
	     */
	    clampValue?: number;
	    /**
	     * Defines wether or not the scratch rendering mode is inverted.
	     * When inverted, the content of the scratch is fully transparent by default.
	     * Means that when the user scratches, the scratch reveals the content instead of hiding the content.
	     */
	    inverted?: boolean;
	    /**
	     * Defines custom fallback when scratch component tries to save performances.
	     * Order:
	     * 	- Particles
	     * 	- Default
	     * 	- One Click
	     * Setting the fallback property allows to customize the renderers used when fallbacking.
	     * Default values is empty.
	     */
	    fallback?: {
	        /**
	         * The default renderer used when fallbacking.
	         */
	        defaultRenderer?: DefaultScratchRenderer;
	        /**
	         * The "one click" renderer used when fallbacking.
	         */
	        oneClickRenderer?: OneClickScratchRenderer;
	    };
	    /**
	     * The scratch component uses a custom filter to render the inverted mask (scratch + content). For some reasons, filters
	     * need sometimes an extra padding value to extend the bounds of the filter. This is due to the current implementation of filters and
	     * can't be automatically fixed by the scratch component.
	     */
	    padding?: number;
	}
	/**
	 * Interface that represents a scratch renderer. Typically ribbon renderer, particles renderer, etc.
	 * The renderer should produce a texture used to
	 */
	export abstract class AbstractScratch2Renderer extends Container {
	    /**
	     * Called once the renderer is activated by the scratch component.
	     * @param scratch the scratch component reference.
	     */
	    onActivate(scratch: Scratch2): void;
	    /**
	     * Called on the renderer is being rendered.
	     */
	    onRender(): void;
	    /**
	     * Called on the renderer has been rendered.
	     */
	    onPostRender(): void;
	    /**
	     * Called once the renderer has been destroyed.
	     */
	    onDestroy(): void;
	    /**
	     * Called on the user wants to auto-reveal the scratch component.
	     * @param scratch the scratch component reference.
	     * @param zone the zone to automatically reveal. If no zone provided in the scratch component, the zone represents the overall scratch component.
	     * @param path the path used while animating the auto mode.
	     * @param done called once the auto animation has been completed.
	     */
	    onAuto(scratch: Scratch2, zone: Scratch2Zone, path: ScratchPath, done: () => void): void;
	    /**
	     * Called on the user wants to stop the renderer. Typically to pause in auto mode.
	     */
	    onStop(): void;
	    /**
	     * Called on the user scratchs the scratch component.
	     * @param scratch the scratch component reference.
	     * @param event object that contains all the pointer event values (distance, etc.).
	     * @param zone the zone reference being scratched.
	     */
	    abstract onScratch(scratch: Scratch2, event: IPointerEvent, zone: Scratch2Zone): void;
	    /**
	     * Called on the scratched ratio changed.
	     * @param scratch defines the reference to the scratch using the renderer (this).
	     * @param oldRatio defines the value of the old scratched ratio [0, 1].
	     * @param newRatio defines the value of the new scratched ratio [0, 1].
	     */
	    onRatioChanged(scratch: Scratch2, oldRatio: number, newRatio: number): void;
	    /**
	     * Called on the scratch has been reset.
	     */
	    abstract reset(): void;
	    /**
	     * Exports the renderer configuration mainly used by the editor or cloning method
	     */
	    abstract export(): any;
	    /**
	     * Parses the given scratch renderer configuration to return a new renderer component
	     * @param config the configuration of the scratch component being created
	     * @param baseUrl the base url of the loader
	     */
	    static parse(config: any, baseUrl: string): AbstractScratch2Renderer;
	}
}

declare module "@gdk/core-pixi/ui/scratch2/renderers/index" {
	export * from "@gdk/core-pixi/ui/scratch2/renderers/default";
	export * from "@gdk/core-pixi/ui/scratch2/renderers/oneClick";
	export * from "@gdk/core-pixi/ui/scratch2/renderers/particles";
}

declare module "@gdk/core-pixi/ui/scratch2/renderers/default" {
	import { Texture, Sprite } from "pixi.js";
	import { AbstractScratch2Renderer } from "@gdk/core-pixi/ui/scratch2/types";
	import type { Scratch2 } from "@gdk/core-pixi/ui/scratch2/scratch2";
	import type { Scratch2Zone } from "@gdk/core-pixi/ui/scratch2/zone";
	import type { ScratchPath } from "@gdk/core-pixi/ui/scratch/scratchPath";
	import type { IPointerMoveEvent } from "@gdk/core-pixi/ui/baseui/ui/customPointer";
	export class DefaultScratchRenderer extends AbstractScratch2Renderer {
	    /**
	     * The sprite reference used to draw the mask.
	     */
	    sprite: Sprite;
	    /**
	     * The texture reference used to render the sprite.
	     */
	    texture: Texture;
	    private _autoTimelines;
	    private _autoSprites;
	    /**
	     * Constructor
	     * @param texture the texture being used.
	     */
	    constructor(texture?: Texture);
	    /**
	     * Called on the scratch has been reset.
	     */
	    reset(): void;
	    /**
	     * Called once the user scratchs the scratch component.
	     * @param event object that contains all the pointer event values (distance, etc.)
	     */
	    onScratch(scratch: Scratch2, event: IPointerMoveEvent): void;
	    /**
	     * Called on the user wants to stop the renderer. Typically to pause in auto mode.
	     */
	    onStop(): void;
	    /**
	     * Called on the user wants to auto-reveal the scratch component.
	     * @param scratch the scratch component reference.
	     * @param zone the zone to automatically reveal. If no zone provided in the scratch component, the zone represents the overall scratch component.
	     * @param path the path used while animating the auto mode.
	     * @param done called once the auto animation has been completed.
	     */
	    onAuto(scratch: Scratch2, zone: Scratch2Zone, path: ScratchPath, done: () => void): void;
	    /**
	     * Exports the renderer configuration mainly used by the editor or cloning method
	     */
	    export(): any;
	    /**
	     * Parses the given scratch renderer configuration to return a new renderer component
	     * @param config the configuration of the scratch component being created
	     * @param baseUrl the base url of the loader
	     */
	    static parse(config: any, baseUrl: string): AbstractScratch2Renderer;
	}
}

declare module "@gdk/core-pixi/ui/scratch2/renderers/oneClick" {
	import { Texture, Sprite } from "pixi.js";
	import { AbstractScratch2Renderer } from "@gdk/core-pixi/ui/scratch2/types";
	import type { Scratch2 } from "@gdk/core-pixi/ui/scratch2/scratch2";
	import type { Scratch2Zone } from "@gdk/core-pixi/ui/scratch2/zone";
	import type { ScratchPath } from "@gdk/core-pixi/ui/scratch/scratchPath";
	import type { IPointerMoveEvent } from "@gdk/core-pixi/ui/baseui/ui/customPointer";
	export interface ISpriteZone {
	    /**
	     * The zone reference having the sprite fit on.
	     */
	    zone: Scratch2Zone;
	    /**
	     * The sprite associated to the zone.
	     */
	    sprite: Sprite;
	}
	export class OneClickScratchRenderer extends AbstractScratch2Renderer {
	    /**
	     * The textures array used to keep textures
	     */
	    textures: Texture[];
	    /**
	     * The array containing all the sprites associated to their zones.
	     */
	    spriteZones: ISpriteZone[];
	    private _distance;
	    private _autoTweens;
	    private _autoSprites;
	    /**
	     * Constructor
	     * @param textures the textures array being used.
	     */
	    constructor(textures?: Texture[]);
	    /**
	     * Called on the scratch has been reset.
	     */
	    reset(): void;
	    /**
	     * Called on the user wants to stop the renderer. Typically to pause in auto mode.
	     */
	    onStop(): void;
	    /**
	     * Called once the user scratchs the scratch component.
	     * @param scratch the scratch component reference.
	     * @param event object that contains all the pointer event values (distance, etc.).
	     * @param zone the zone reference being scratched.
	     */
	    onScratch(scratch: Scratch2, event: IPointerMoveEvent, zone: Scratch2Zone): void;
	    /**
	     * Called on the user wants to auto-reveal the scratch component.
	     * @param scratch the scratch component reference.
	     * @param zone the zone to automatically reveal. If no zone provided in the scratch component, the zone represents the overall scratch component.
	     * @param path the path used while animating the auto mode.
	     * @param done called once the auto animation has been completed.
	     */
	    onAuto(scratch: Scratch2, zone: Scratch2Zone, path: ScratchPath, done: () => void): void;
	    private _switchTexture;
	    private _getSpriteZone;
	    /**
	     * Exports the renderer configuration mainly used by the editor or cloning method
	     */
	    export(): any;
	    /**
	     * Parses the given scratch renderer configuration to return a new renderer component
	     * @param config the configuration of the scratch component being created
	     * @param baseUrl the base url of the loader
	     */
	    static parse(config: any, baseUrl: string): AbstractScratch2Renderer;
	}
}

declare module "@gdk/core-pixi/ui/scratch2/renderers/particles" {
	import { Texture } from "pixi.js";
	import { AbstractScratch2Renderer } from "@gdk/core-pixi/ui/scratch2/types";
	import type { ScratchPath } from "@gdk/core-pixi/ui/scratch/scratchPath";
	import type { IPointerMoveEvent } from "@gdk/core-pixi/ui/baseui/ui/customPointer";
	import type { Scratch2Zone } from "@gdk/core-pixi/ui/scratch2/zone";
	import type { Scratch2 } from "@gdk/core-pixi/ui/scratch2/scratch2";
	import type { IEmitterConfig } from "@gdk/core-pixi/proton/parser2/index";
	export class ParticlesScratchRenderer extends AbstractScratch2Renderer {
	    /**
	     * Defines the texture reference used to render the particles.
	     */
	    texture: Texture;
	    /**
	     * Defines the scratch preset used while scratching.
	     */
	    scratchPreset: IEmitterConfig;
	    /**
	     * Defines the auto preset used while auto-scratching.
	     */
	    autoPreset: IEmitterConfig;
	    /**
	     * Defines the auto preset used while auto-scratching a zone.
	     */
	    autoZonePreset: IEmitterConfig;
	    private _renderer;
	    private _base;
	    private _emitter;
	    private _zone;
	    private _scratch;
	    private _stopped;
	    private _autoEmitters;
	    private _autoTimelines;
	    /**
	     * Constructor
	     * @param texture the texture being used
	     */
	    constructor(texture?: Texture);
	    /**
	     * Called on the scratch has been reset.
	     */
	    reset(): void;
	    /**
	     * Called once the renderer is activated by the scratch component.
	     * @param scratch the scratch component reference.
	     */
	    onActivate(scratch: Scratch2): void;
	    /**
	     * Called on the renderer is being rendered.
	     */
	    onRender(): void;
	    /**
	     * Called once the renderer has been destroyed.
	     */
	    onDestroy(): void;
	    /**
	     * Called on the user wants to stop the renderer. Typically to pause in auto mode.
	     */
	    onStop(): void;
	    /**
	     * Called once the user scratchs the scratch component.
	     * @param event object that contains all the pointer event values (distance, etc.)
	     */
	    onScratch(scratch: Scratch2, event: IPointerMoveEvent): void;
	    /**
	     * Called on the user wants to auto-reveal the scratch component.
	     * @param scratch the scratch component reference.
	     * @param zone the zone to automatically reveal. If no zone provided in the scratch component, the zone represents the overall scratch component.
	     * @param path the path used while animating the auto mode.
	     * @param done called once the auto animation has been completed.
	     */
	    onAuto(scratch: Scratch2, zone: Scratch2Zone, path: ScratchPath, done: () => void): void;
	    private _createEmitter;
	    private _clearParticles;
	    /**
	     * Returns wether or not the "bb" rectangle intersects the "ab" rectangle.
	     */
	    private _testRectangleIntersection;
	    /**
	     * Exports the renderer configuration mainly used by the editor or cloning method
	     */
	    export(): any;
	    /**
	     * Parses the given scratch renderer configuration to return a new renderer component
	     * @param config the configuration of the scratch component being created
	     * @param baseUrl the base url of the loader
	     */
	    static parse(config: any, baseUrl: string): AbstractScratch2Renderer;
	}
}

declare module "@gdk/core-pixi/ui/scratch2/scratch2Presets" {
	import type { IEmitterConfig } from "@gdk/core-pixi/proton/parser2/index";
	export class Scratch2Presets {
	    /**
	     * Preset typically used to scratch small zones.
	     */
	    static FDJ_SCRATCH_SMALL: IEmitterConfig;
	    /**
	     * Preset typically used to scratch big zones.
	     */
	    static FDJ_SCRATCH_BIG: IEmitterConfig;
	}
}

declare module "@gdk/core-pixi/ui/scratch/index" {
	export { Scratch, IScratchOptions } from "@gdk/core-pixi/ui/scratch/scratch";
	export { ScratchPath } from "@gdk/core-pixi/ui/scratch/scratchPath";
	export { Scratchable } from "@gdk/core-pixi/ui/scratch/scratchable";
	export { OneClickScratch } from "@gdk/core-pixi/ui/scratch/oneClickScratch";
	export { ScratchSolver, IScratchSounds, ESounds } from "@gdk/core-pixi/ui/scratch/scratchSolver";
	export { ScratchPresets } from "@gdk/core-pixi/ui/scratch/scratchPresets";
	export { ScratchAssets } from "@gdk/core-pixi/ui/scratch/scratchAssets";
}

declare module "@gdk/core-pixi/ui/scratch/oneClickScratch" {
	import { Container, Sprite } from "pixi.js";
	import { Scratchable } from "@gdk/core-pixi/ui/scratch/scratchable";
	export type TextureID = string;
	export interface IOneClickScratchOptions {
	    revealTextureID: TextureID;
	    scratchTextureID: TextureID;
	}
	export class OneClickScratch extends Container implements Scratchable {
	    isRevealed: boolean;
	    isAuto: boolean;
	    protected revealSprite: Sprite;
	    protected scratchSprite: Sprite;
	    constructor(options: IOneClickScratchOptions);
	    /**
	     * Automatically scratch element
	     */
	    auto(): void;
	    /**
	     * Get the progress of the scratch
	     */
	    getProgress(): number;
	    /**
	     * Reset the scratch
	     */
	    reset(): void;
	    private _onPointerTapHandler;
	}
}

declare module "@gdk/core-pixi/ui/scratch/scratchPresets" {
	import { ScratchPath } from "@gdk/core-pixi/ui/scratch/scratchPath";
	export class ScratchPresets {
	    static DEBUG: any;
	    static FDJ_SCRATCH_SMALL: any;
	    static FDJ_SCRATCH_BIG: any;
	    static AUTO_RANDOM_BIG: any;
	    static AUTO_RANDOM_SMALL: any;
	    static GRAVITY_LIKE: any;
	    static NO_PATH: ScratchPath;
	    static PATH_3_LINES_DIAGONAL: ScratchPath;
	    static PATH_5_LINES_DIAGONAL: ScratchPath;
	    static FDJ_AUTO: any;
	    static DEFAULT: any;
	    static DEFAULT_AUTO: any;
	    static DEFAULT_PATH: ScratchPath;
	}
}

declare module "@gdk/core-pixi/ui/scratch/scratchAssets" {
	import { Texture } from "pixi.js";
	export class ScratchAssets {
	    private static _imageCache;
	    /**
	     * get texture
	     * @param assetID ID of the texture you want to have
	     */
	    static get(assetID: string): Texture;
	    /**
	     * get raw (string) data from embeded assets
	     * @param assetID the asset id
	     */
	    static getRaw(assetID: string): string;
	    /**
	     * get image from embeded assets
	     * @param assetID the asset id
	     */
	    static getImage(assetID: string): HTMLImageElement;
	    /**
	     * will init ScratchAssets cache.
	     */
	    static initCache(): void;
	    /**
	     * Clears the ScratchAssets cache. Typically used only in playground or editor.
	     */
	    static clearCache(): void;
	    private static _embededAssets;
	}
}

declare module "@gdk/core-pixi/ui/scroll/index" {
	export { EScrollBarAlign2, ScrollBar2 } from "@gdk/core-pixi/ui/scroll/scrollBar2";
	export { ScrollContainer2 } from "@gdk/core-pixi/ui/scroll/scrollContainer2";
}

declare module "@gdk/core-pixi/ui/scroll/scrollBar2" {
	import { Container } from "pixi.js";
	import { Cubic } from "gsap";
	import type { mesh } from "pixi.js";
	/**
	 * @experimental
	 */
	export enum EScrollBarAlign2 {
	    /**
	     * Defines a scroll bar being vertical (scroll on Y axis).
	     */
	    Vertical = 0,
	    /**
	     * Defines a scroll bar being horizontal (scroll on the X axis).
	     */
	    Horizontal = 1
	}
	/**
	 * @experimental
	 */
	export class ScrollBar2 extends Container {
	    /**
	     * The handle element used to draw scroll bar's background.
	     */
	    handle: mesh.NineSlicePlane;
	    /**
	     * The tracking element used to change the scroll bar's ratio.
	     */
	    track: mesh.NineSlicePlane;
	    /**
	     * Used by specialized components. Mainly used to keep the original track height while computing iOS style thumb height while scrolling.
	     * @see ScrollContainer2.prototype._refreshTracksHeights for more informations.
	     * @hidden
	     */
	    _fixedTrackHeight: number;
	    private _alignement;
	    private _width;
	    private _height;
	    private _dragEvent;
	    /**
	     * Constructor.
	     * @param handle The handle element used to draw scroll bar's background.
	     * @param track The tracking element used to change the scroll bar's ratio.
	     * @param alignement The alignement type of the scroll bar (vertical or horizontal).
	     */
	    constructor(handle: mesh.NineSlicePlane, track: mesh.NineSlicePlane, alignement: EScrollBarAlign2);
	    /**
	     * Gets the current width of the scroll bar.
	     */
	    get width(): number;
	    /**
	     * Sets the current width of the scroll bar.
	     */
	    set width(width: number);
	    /**
	     * Gets the current height of the scroll bar.
	     */
	    get height(): number;
	    /**
	     * Sets the current height of the scroll bar.
	     */
	    set height(height: number);
	    /**
	     * Gets the scroll bar alignment type (verticla or horizontal).
	     */
	    get alignement(): EScrollBarAlign2;
	    /**
	     * Sets the scroll bar alignment type (verticla or horizontal).
	     */
	    set alignement(align: EScrollBarAlign2);
	    /**
	     * Scrolls to the given position.
	     * @param position the new position to scroll to. Number expression represents pixels. String expresion represents a ratio in %.
	     * @param duration the duration of the scroll animation. 0 means no animation.
	     * @param ease the easing function used while animating the scroll.
	     */
	    scrollTo(position: number | string, duration?: number, ease?: Cubic): void;
	    /**
	     * Sets the new scroll position.
	     * @param ratio the position ratio to set the tracking element to.
	     */
	    setScrollPosition(ratio: number): void;
	    /**
	     * Emits the scroll event.
	     */
	    private _refreshScroll;
	    /**
	     * Checks the limits of the tracking element according to the current handle height.
	     */
	    private _checkLimits;
	    /**
	     * Binds the events of the overall scroll bar.
	     */
	    private _bindEvents;
	    /**
	     * Export the scroll bar.
	     */
	    export(): any;
	    /**
	     * Parses the scroll bar.
	     * @param config the serialized data.
	     * @param baseUrl the base url of the loader.
	     * @param scrollBar the existing scroll bar.
	     */
	    static parse(config: any, baseUrl: string, scrollBar?: ScrollBar2): ScrollBar2;
	}
}

declare module "@gdk/core-pixi/ui/scroll/scrollContainer2" {
	import { Container, Sprite, Graphics } from "pixi.js";
	import { Cubic } from "gsap";
	import type { WebGLRenderer, CanvasRenderer } from "pixi.js";
	import { ScrollBar2 } from "@gdk/core-pixi/ui/scroll/scrollBar2";
	/**
	 * @experimental
	 */
	export class ScrollContainer2 extends Container {
	    /**
	     * Container used to store content of the scroll container.
	     * All scrollable children should be added in this content container.
	     */
	    content: Container;
	    /**
	     * Array of existing scroll bars for the current scroll container.
	     */
	    scrollBars: ScrollBar2[];
	    /**
	     * Defines the inertia ratio multiplied by the current deltas.
	     */
	    inertia: number;
	    /**
	     * Defines the scroll speed. When scrolling, the speed is multiplied by this value.
	     */
	    scrollSpeed: number;
	    /**
	     * Sets wether or not scrolling inertia is enabled.
	     */
	    inertiaEnabled: boolean;
	    private _scrollMask;
	    private _width;
	    private _height;
	    private _mouseWheelListener;
	    private _scrollDelta;
	    private _inertialOffsets;
	    private _lastFramePosition;
	    private _dragEvent;
	    private _scrollBounds;
	    private _lastScrollBounds;
	    private _automaticTrackHeight;
	    private _automaticScrollBarVisibility;
	    private static _lineHeight;
	    private static _pageHeight;
	    /**
	     * Constructor.
	     */
	    constructor();
	    /**
	     * Renders the scratch using the WebGL renderer.
	     * @param renderer the webgl renderer reference.
	     */
	    renderWebGL(renderer: WebGLRenderer): void;
	    /**
	     * Renders the scratch using the canvas renderer.
	     * @param renderer the canvas renderer reference.
	     */
	    renderCanvas(renderer: CanvasRenderer): void;
	    /**
	     * Sets the new dimensions of the scroll container.
	     * @param width the new width of the container in pixels.
	     * @param height the new height of the container in pixels.
	     */
	    setDimensions(width: number, height: number): void;
	    /**
	     * Gets the mask used to show/hide content in the scroll container. This should be a graphics in order to
	     * work in both WebGL and Canvas modes.
	     */
	    get scrollMask(): Sprite | Graphics;
	    /**
	     * Sets the mask used to show/hide content in the scroll container. This should be a graphics in order to
	     * work in both WebGL and Canvas modes.
	     */
	    set scrollMask(mask: Sprite | Graphics);
	    /**
	     * Gets the current width of the container in pixels.
	     */
	    get width(): number;
	    /**
	     * Sets the new width of the container in pixels.
	     */
	    set width(width: number);
	    /**
	     * Gets the current height of the container in pixels.
	     */
	    get height(): number;
	    /**
	     * Sets the new height of the container in pixels.
	     */
	    set height(height: number);
	    /**
	     * Gets wether or not the height of the track bar should be computed automatically.
	     */
	    get automaticTrackHeight(): boolean;
	    /**
	     * Gets wether or not the height of the track bar should be computed automatically.
	     */
	    set automaticTrackHeight(enable: boolean);
	    /**
	     * Gets wether or not the scroll bars should be automatically visible/unvisible according to the current content's bounds.
	     */
	    get automaticScrollBarVisibility(): boolean;
	    /**
	     * Sets wether or not the scroll bars should be automatically visible/unvisible according to the current content's bounds.
	     */
	    set automaticScrollBarVisibility(enable: boolean);
	    /**
	     * Scrolls to the given position in pixels or %.
	     * @param x the new position to scroll to. Number expression represents pixels. String expresion represents a ratio in %.
	     * @param duration the duration of the scroll animation. 0 means no animation.
	     * @param ease the easing function used while animating the scroll.
	     */
	    scrollTo(x: number | string, y: number | string, duration?: number, ease?: Cubic): void;
	    /**
	     * Adds a new scroll bar to the scroll container (handle + track) with the given type (alignment).
	     * @param scrollBar the scroll bar object containing the handle and track objects and the alignment type.
	     */
	    addScrollBar(scrollBar: ScrollBar2, configure?: boolean): ScrollBar2;
	    /**
	     * Removes the given scroll bar from the scroll container.
	     * @param scrollBar the scroll bar to remove.
	     */
	    removeScrollBar(scrollBar: ScrollBar2): boolean;
	    /**
	     * Adds the given container to the content.
	     * @param container defines the reference to the container to add in the content.
	     */
	    addContent(container: Container): void;
	    /**
	     * Removes the given container from the content.
	     * @param container defines the reference to the container to remove from the content.
	     */
	    removeContent(container: Container): void;
	    /**
	     * Updates the scroll bars visibilities according to the current configuration and the content's bounds.
	     */
	    private _updateScrollBarsVisibility;
	    /**
	     * Refreshes the current content's bounds.
	     */
	    private _refreshContentBounds;
	    /**
	     * Refreshes the tracks heights of the scroll bars when "_automaticTrackHeight" is set to true.
	     */
	    private _refreshTracksHeights;
	    /**
	     * Binds the events of the scroll container (typically wheel events).
	     */
	    private _bindEvents;
	    /**
	     * Checks the contents limits.
	     */
	    private _checkContentLimits;
	    /**
	     * Updates the inertia.
	     */
	    private _updateInertia;
	    /**
	     * Updates the content's mask.
	     */
	    private _updateContentMask;
	    /**
	     * Updates the thumb height iOS style.
	     */
	    private _checkThumbHeight;
	    /**
	     * Gets wether or not the scroll container is in debug mode in order to deactivate the mask and see all its content.
	     */
	    get debugMode(): boolean;
	    /**
	     * Sets wether or not the scroll container is in debug mode in order to deactivate the mask and see all its content.
	     */
	    set debugMode(enable: boolean);
	    /**
	     * Export the scroll container.
	     */
	    export(): any;
	    /**
	     * Parses the scroll container.
	     * @param config the serialized data.
	     * @param baseUrl the base url of the loader.
	     * @param container the existing scroll container 2.
	     */
	    static parse(config: any, baseUrl: string, container?: ScrollContainer2): ScrollContainer2;
	}
}

declare module "@gdk/core-pixi/ui/events/index" {
	export { DragEvent2 } from "@gdk/core-pixi/ui/events/dragEvent2";
}

declare module "@gdk/core-pixi/ui/events/dragEvent2" {
	import { utils } from "pixi.js";
	import type { Container } from "pixi.js";
	export class DragEvent2 extends utils.EventEmitter {
	    /**
	     * Sets or gets wether or not the dragging event is enabled.
	     */
	    enabled: boolean;
	    private _targetContainer;
	    private _dragDown;
	    private _transform;
	    private _lastPosition;
	    private _lastPointerPosition;
	    private _offsets;
	    private _pointerDownListener;
	    private _mouseDragListener;
	    private _touchDragListener;
	    private _mouseUpListener;
	    private _touchEndListener;
	    /**
	     * Constructor.
	     * @param targetContainer the target container where events should be listened.
	     */
	    constructor(targetContainer?: Container);
	    /**
	     * Gets wether or not the user is dragging the current target container.
	     */
	    get dragDown(): boolean;
	    /**
	     * Gets the current target container events are listened on.
	     */
	    get targetContainer(): Container;
	    /**
	     * Sets the current target container events are listened on.
	     */
	    set targetContainer(container: Container);
	    /**
	     * Binds the events of the target container to listen/emit drag events.
	     */
	    private _bindEvents;
	    /**
	     * Drag event. Called on mousemove or touchmove.
	     */
	    private _drag;
	    /**
	     * Drag end event. Called on mouseup or toucheend.
	     */
	    private _dragEnd;
	    /**
	     * Refreshes the event position (absolute).
	     */
	    private _refreshEventPosition;
	    /**
	     * Removes the temporary events used to listen drag events on canvas.
	     */
	    private _removeTemporaryEvents;
	}
}

declare module "@gdk/core-pixi/spine2/pushButton" {
	import { SpineTimelineButton } from "@gdk/core-pixi/spine2/button";
	import type { IStyles } from "@gdk/core-pixi/ui/index";
	/**
	 * @experimental
	 * Defines the new SpineButton working as a push button.
	 * On pointer up, an event named "push" is emitted.
	 * @example myPushButton.on("push", () => { ... });
	 */
	export class SpineTimelinePushButton extends SpineTimelineButton {
	    private _pushed;
	    private _clickEvent;
	    /**
	     * Constructor.
	     * @param assetId the id of the spine datas in the core-loader.
	     * @param styles the styles of the buttons.
	     */
	    constructor(assetId: string, styles: IStyles);
	    /**
	     * Resets the button.
	     */
	    reset(): void;
	    /**
	     * Registers the event on pointer down.
	     * @override
	     */
	    protected onPointerDown(): void;
	    /**
	     * Registers the event on pointer up.
	     */
	    protected onPointerUp(): void;
	    /**
	     * Registers the event on pointer up outside.
	     */
	    protected onPointerUpOutside(): void;
	    /**
	     * Gets wether or not the pushbutton is pushed.
	     */
	    get pushed(): boolean;
	    /**
	     * Sets wether or not the pushbutton is pushed.
	     */
	    set pushed(pushed: boolean);
	    /**
	     * Sets the button's state (pushed or unpushed).
	     * @param pushed wether or not the button is pushed.
	     */
	    private _setPushed;
	    /**
	     * Exports the spine timeline push button.
	     */
	    export(): any;
	    /**
	     * Parses the spine timeline push button according to the given configuration.
	     * @param config the serialized data.
	     * @param baseUrl the base url of the loader.
	     * @param button the existing button reference.
	     */
	    static parse(config: any, baseUrl: string, button?: SpineTimelinePushButton): SpineTimelinePushButton;
	}
}

declare module "@gdk/core-pixi/spine2/toggleButton" {
	import { SpineTimelineButton } from "@gdk/core-pixi/spine2/button";
	import type { ISpineTimelineButtonAnimations } from "@gdk/core-pixi/spine2/button";
	import type { IStyles } from "@gdk/core-pixi/ui/index";
	/**
	 * @experimental
	 * Defines all possible animations for spine button and the related names.
	 */
	export interface ISpineTimelineToggleButtonAnimations extends ISpineTimelineButtonAnimations {
	    select: string;
	    deselect: string;
	    overSelected: string;
	    overSelectedLoop: string;
	    outSelected: string;
	    selectedLoop: string;
	    upSelected: string;
	    overNotSelected: string;
	    overNotSelectedLoop: string;
	    outNotSelected: string;
	    notSelected: string;
	    notSelectedLoop: string;
	    notSelectedDown: string;
	    notSelectedDownLoop: string;
	    downSelected: string;
	    downSelectedLoop: string;
	    unselectedToIdle: string;
	    noSelectedUp: string;
	    selectedToUnselected: string;
	}
	/**
	 * @experimental
	 * Defines the new SpineButton working as a toggle button.
	 * On pointer up, events are sent to notify if selected or unselected.
	 * @example myToggleButton.on("selected", () => { ... });
	 * @example myToggleButton.on("unselected", () => { ... });
	 */
	export class SpineTimelineToggleButton extends SpineTimelineButton {
	    /**
	     * Defines all possible animations for the spine button and their related names in the spine file.
	     */
	    animationsNames: ISpineTimelineToggleButtonAnimations;
	    /**
	     * Sets or gets wether or not looping on "overSelectedLoop" is required.
	     */
	    loopOnOverSelected: boolean;
	    /**
	     * Sets or gets wether or not looping on "selectedLoop" is required.
	     */
	    loopOnSelected: boolean;
	    /**
	     * Sets or gets wether or not looping on "overnotselectedLoop" is required.
	     */
	    loopOnOverNotSelected: boolean;
	    /**
	     * Sets or gets wether or not looping on "notselectedLoop" is required.
	     */
	    loopOnNotSelected: boolean;
	    /**
	     * Sets or gets wether or not looping on "downSelected" is required.
	     */
	    loopOnDownSelected: boolean;
	    private _selected;
	    /**
	     * Constructor.
	     * @param assetId the id of the spine datas in the core-loader.
	     * @param styles the styles of the buttons.
	     */
	    constructor(assetId: string, styles: IStyles);
	    /**
	     * Registers the event on pointer down.
	     * @override
	     */
	    protected onPointerDown(): void;
	    /**
	     * Registers the event on pointer over.
	     */
	    protected onPointerOver(): void;
	    /**
	     * Registers the event on pointer out.
	     * @override
	     */
	    protected onPointerOut(): void;
	    /**
	     * Registers the event on pointer up.
	     * @override
	     */
	    protected onPointerUp(): void;
	    /**
	     * Registers the event on pointer up outside.
	     * @override
	     */
	    protected onPointerUpOutside(): void;
	    /**
	     * Gets wether or not the toggle button is pushed.
	     */
	    get selected(): boolean;
	    /**
	     * Sets wether or not the toggle button is pushed.
	     */
	    set selected(selected: boolean);
	    /**
	     * Sets the button's state (selected or unselected).
	     * @param selected wether or not the button is selected.
	     */
	    private _setSelected;
	    /**
	     * Exports the spine timeline toggle button.
	     */
	    export(): any;
	    /**
	     * Parses the spine timeline toggle button according to the given configuration.
	     * @param config the serialized data.
	     * @param baseUrl the base url of the loader.
	     * @param button the existing button reference.
	     */
	    static parse(config: any, baseUrl: string, button?: SpineTimelineToggleButton): SpineTimelineToggleButton;
	}
}

declare module "@gdk/core-pixi/spine2/radioButton" {
	import { Container } from "pixi.js";
	import type { SpineTimelineToggleButton } from "@gdk/core-pixi/spine2/toggleButton";
	/**
	 * @experimental
	 * Defines the new SpineButton working as a push button.
	 * On pointer up, events are sent to notify the selected or unselected button.
	 * @example myRadioButton.on("selected", (selectedButton) => { ... });
	 * @example myRadioButton.on("unselected", () => { ... });
	 */
	export class SpineTimelineRadioButton extends Container {
	    /**
	     * Stores the current list of the available buttons.
	     */
	    readonly buttons: SpineTimelineToggleButton[];
	    private _selected;
	    /**
	     * Constructor.
	     */
	    constructor();
	    /**
	     * Adds the given button to be controlled by the radio button.
	     * @param button the button to add and controlled by the radio button.
	     */
	    addButton(button: SpineTimelineToggleButton): SpineTimelineToggleButton;
	    /**
	     * Removes the given button from the available buttons controlled by the radio button.
	     * @param button the button reference to remove.
	     */
	    removeButton(button: SpineTimelineToggleButton): boolean;
	    /**
	     * Removes all the available buttons.
	     */
	    removeAllButtons(): void;
	    /**
	     * Returns the currently selected button reference.
	     */
	    get selected(): SpineTimelineToggleButton;
	    /**
	     * Sets the currently selected button.
	     */
	    set selected(selected: SpineTimelineToggleButton);
	    /**
	     * Resets the radio button to select none.
	     */
	    reset(): void;
	    /**
	     * Binds all needed events to control the overall buttons animation states.
	     */
	    private _bindEvents;
	    /**
	     * Registers the event on pointer over for the given button.
	     * @param button the button to configure the over event.
	     */
	    protected onPointerOver(button: SpineTimelineToggleButton): void;
	    /**
	     * Registers the event on pointer out.
	     * @param button the button to configure the out event.
	     */
	    protected onPointerOut(button: SpineTimelineToggleButton): void;
	    /**
	     * Registers the event on pointer down.
	     * @param button the button to configure the pointer down event.
	     */
	    protected onPointerDown(button: SpineTimelineToggleButton): void;
	    /**
	     * Registers the event on pointer up outside.
	     * @param button the button to configure the pointer up event.
	     */
	    protected onPointerUpOutside(button: SpineTimelineToggleButton): void;
	    /**
	     * Registers the event on pointer up.
	     * @param button the button to configure the pointer up event.
	     * @param force defines wether or not the state of the button should be forced.
	     */
	    protected onPointerUp(button: SpineTimelineToggleButton, force?: boolean): void;
	    /**
	     * Exports the spine timeline radio button.
	     */
	    export(): any;
	    /**
	     * Parses the spine timeline according to the given configuration.
	     * @param config the serialized data.
	     * @param baseUrl the base url of the loader.
	     * @param button the existing button reference.
	     */
	    static parse(config: any, baseUrl: string, button?: SpineTimelineRadioButton): SpineTimelineRadioButton;
	}
}

declare module "@gdk/core-pixi/spine2/checkButton" {
	import { Container } from "pixi.js";
	import type { SpineTimelineToggleButton } from "@gdk/core-pixi/spine2/toggleButton";
	/**
	 * @experimental
	 * Defines the new SpineButton working as a push button.
	 * On pointer up, events are sent to notify the selected or unselected button.
	 * @example myCheckButton.on("selected", (selectedButton) => { ... });
	 * @example myCheckButton.on("unselected", () => { ... });
	 * @example myCheckButton.selectedButtons.forEach((sb) => { ... });
	 */
	export class SpineTimelineCheckButton extends Container {
	    /**
	     * Stores the current list of the available buttons.
	     */
	    readonly buttons: SpineTimelineToggleButton[];
	    /**
	     * Defines the maximum count of selectable buttons.
	     */
	    maxSelectedButtonsCount: number;
	    private _selectedButtons;
	    /**
	     * Constructor.
	     */
	    constructor();
	    /**
	     * Adds the given button to be controlled by the radio button.
	     * @param button the button to add and controlled by the radio button.
	     */
	    addButton(button: SpineTimelineToggleButton): SpineTimelineToggleButton;
	    /**
	     * Removes the given button from the available buttons controlled by the radio button.
	     * @param button the button reference to remove.
	     */
	    removeButton(button: SpineTimelineToggleButton): boolean;
	    /**
	     * Removes all the available buttons.
	     */
	    removeAllButtons(): void;
	    /**
	     * Returns the currently selected button reference.
	     */
	    get selected(): SpineTimelineToggleButton[];
	    /**
	     * Sets the currently selected button.
	     */
	    set selected(selected: SpineTimelineToggleButton[]);
	    /**
	     * Resets the check button to select none.
	     */
	    reset(): void;
	    /**
	     * Binds all needed events to control the overall buttons animation states.
	     */
	    private _bindEvents;
	    /**
	     * Registers the event on pointer over for the given button.
	     * @param button the button to configure the over event.
	     */
	    protected onPointerOver(button: SpineTimelineToggleButton): void;
	    /**
	     * Registers the event on pointer out.
	     * @param button the button to configure the out event.
	     */
	    protected onPointerOut(button: SpineTimelineToggleButton): void;
	    /**
	     * Registers the event on pointer down.
	     * @param button the button to configure the pointer down event.
	     */
	    protected onPointerDown(button: SpineTimelineToggleButton): void;
	    /**
	     * Registers the event on pointer up outside.
	     * @param button the button to configure the pointer up event.
	     */
	    protected onPointerUpOutside(button: SpineTimelineToggleButton): void;
	    /**
	     * Registers the event on pointer up.
	     * @param button the button to configure the pointer up event.
	     * @param force defines wether or not the button state should be forced.
	     */
	    protected onPointerUp(button: SpineTimelineToggleButton, force?: boolean): void;
	    /**
	     * Exports the spine timeline radio button.
	     */
	    export(): any;
	    /**
	     * Parses the spine timeline according to the given configuration.
	     * @param config the serialized data.
	     * @param baseUrl the base url of the loader.
	     * @param button the existing button reference.
	     */
	    static parse(config: any, baseUrl: string, button?: SpineTimelineCheckButton): SpineTimelineCheckButton;
	}
}

declare module "@gdk/core-pixi/spine2/logo" {
	import { SpineTimeline } from "@gdk/core-pixi/spine2/timeline";
	import { TextField } from "@gdk/core-pixi/ui/index";
	import type { IStyles } from "@gdk/core-pixi/ui/index";
	import type { ISpineTimelineSequence } from "@gdk/core-pixi/spine2/types";
	/**
	 * @experimental
	 * Defines the new SpineLogo options that uses the newly created SpineTimeline features.
	 */
	export interface ISpineTimelineLogoOptions {
	    /**
	     * The name of the slot container in the spine that will contain the stake's textfield.
	     */
	    stakeContainerName?: string;
	    /**
	     * The styles to apply to the stake's textfield.
	     */
	    stakeStyles?: IStyles;
	    /**
	     * The value of the stake to draw.
	     */
	    stakeValue?: number;
	}
	/**
	 * @experimental
	 * Defines the new SpineLogo that uses the newly created SpineTimeline features.
	 */
	export class SpineTimelineLogo extends SpineTimeline {
	    /**
	     * The default sequence available for the spine logo.
	     */
	    static defaultSequence: ISpineTimelineSequence;
	    /**
	     * The spine logo's options reference.
	     */
	    options: ISpineTimelineLogoOptions;
	    stakeTextField: TextField;
	    private _stakeSlotContainer;
	    private _stake;
	    private _showStake;
	    /**
	     * Constructor.
	     * @param assetId the id of the spine datas in the core-loader.
	     */
	    constructor(assetId: string, options?: ISpineTimelineLogoOptions);
	    /**
	     * Inits the spine timeline.
	     */
	    private _initLogo;
	    /**
	     * Shows the logo by playing the logo's sequence.
	     */
	    show(): Promise<void>;
	    /**
	     * Gets the current stake text.
	     */
	    get stake(): string;
	    /**
	     * Sets the current stake text.
	     */
	    set stake(value: string);
	    /**
	     * Updates the stake textfield by setting pivot centered etc.
	     * Should be called once the stake's options changed (text, style, etc.).
	     */
	    updateStake(): void;
	    /**
	     * Gets wether or not the stake should be shown.
	     */
	    get showStake(): boolean;
	    /**
	     * Sets wether or not the stake should be shown.
	     */
	    set showStake(value: boolean);
	    /**
	     * Gets the current stake container.
	     */
	    get stakeContainer(): string;
	    /**
	     * Sets the current stake container.
	     * If a stake container already exists, the textfield's styles will be copied.
	     */
	    set stakeContainer(name: string);
	    /**
	     * Inits the stake by retrieving container, creating textfield etc.
	     */
	    private _initStake;
	    /**
	     * Exports the spine timeline logo.
	     */
	    export(): any;
	    /**
	     * Parses the spine timeline logo according to the given configuration.
	     * @param config the serialized data.
	     * @param baseUrl the base url of the loader.
	     * @param logo the existing timeline reference.
	     */
	    static parse(config: any, baseUrl: string, logo?: SpineTimelineLogo): SpineTimelineLogo;
	}
}

declare module "@gdk/core-pixi/tools/index" {
	export * from "@gdk/core-pixi/tools/dataCache";
	export * from "@gdk/core-pixi/tools/pDelayedCall";
	export * from "@gdk/core-pixi/tools/isLeftPointerTap";
	export * from "@gdk/core-pixi/tools/displayObjects";
}

declare module "@gdk/core-pixi/tools/pDelayedCall" {
	export function pDelayedCall(delay: number): Promise<void>;
}

declare module "@gdk/core-pixi/tools/isLeftPointerTap" {
	import type { interaction } from "pixi.js";
	/**
	 * Check the pointer event to prevent event from right click if it is a mouse click
	 * @param pointerEvent: The pointer event to check
	 * @return True if the interactionEvent is provided by a left mouse click or pointer tap
	 */
	export const isLeftPointerTap: (pointerEvent: interaction.InteractionEvent) => boolean;
}

declare module "@gdk/core-pixi/tools/displayObjects" {
	import type { DisplayObject } from "pixi.js";
	export function elementToString(el: DisplayObject): string;
	export function elementToPath(el: DisplayObject): string;
}
