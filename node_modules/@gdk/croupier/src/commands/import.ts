import alasql from "alasql";
import * as fs from "fs-extra";
import { logger } from "@gdk/backutils";
import decompress from "decompress";
import type { IRank, ITicket, ICroupier, ICroupierConfig } from "@gdk/backutils";

interface IAlaSQLStatement {
	into?: { tableid: string };
	table?: { tableid: string };
	select?: { columns: Array<{ value: any }> };
	columns?: Array<{ columnid: string }>;
	values?: Array<Array<{ value: any }>>;
}

interface IAlaSQLAST {
	statements: IAlaSQLStatement[];
}

export class CroupierImporter {
	private _id: number = 0;
	private _stakes: Array<{ value: number; currency: string }> = [];

	public croupierConf: ICroupierConfig = {
		masterGameCode: "",
		code: "",
		description: "",
		baseStake: 0,
		renewal: 0,
		ranks: [],
		seed: "",
		infos: {
			bicCode: 0,
			serviceCode: "",
			serviceName: "",
			type: "",
		},
	};

	/**
	 * Import archive file
	 * @param file
	 * @param serviceName
	 * @param version
	 */
	public async import(file: string): Promise<ICroupierConfig> {
		if (fs.existsSync("tmpdir")) {
			fs.removeSync("tmpdir");
		}

		const files = await decompress(file);
		const sqlCroupiersFiles = files
			.filter((f) => {
				return f.type === "file" && /prod\.sql$/.test(f.path);
			})
			.map((f) => f.data.toString("utf8"));
		const sqlUsrFiles = files
			.filter((f) => {
				return f.type === "file" && /external_service\.sql$/.test(f.path);
			})
			.map((f) => f.data.toString("utf8"));
		const jsonCroupierFiles = files
			.filter((f) => {
				return f.type === "file" && /croupier-.*\.json$/.test(f.path);
			})
			.map((f) => JSON.parse(f.data.toString("utf8")));

		if (sqlCroupiersFiles.length && sqlUsrFiles.length) {
			const sqlCroupierFile = sqlCroupiersFiles[0];
			const sqlUsrFile = sqlUsrFiles[0];

			this.importSQLCroupier(sqlCroupierFile);
			this.croupierConf.baseStake = this._stakes.map((s) => s.value).sort((a, b) => a - b)[0];
			this.importUsr(sqlUsrFile);

			this.croupierConf.description = `dealer ${this.croupierConf.code} for game ${this.croupierConf.masterGameCode}`;

			return this.croupierConf;
		} else if (jsonCroupierFiles.length && jsonCroupierFiles[0].schemaVersion === 3) {
			const jsonCroupierFile: ICroupier = jsonCroupierFiles[0];
			const { productVersion, productName, date, version, hashes, packageVersion, ...confContent } =
				jsonCroupierFile;

			this.croupierConf = confContent;

			return this.croupierConf;
		}

		throw new Error("missing croupier file");
	}

	/**
	 * Loads a sql croupier file and translates into a JSON format
	 */
	public importSQLCroupier(content: string): void {
		const ast = alasql.parse(content) as unknown as IAlaSQLAST;

		// For each statement, check insert intos
		ast.statements.forEach((s) => {
			if (!s.into || !s.into.tableid) {
				return;
			}

			switch (s.into.tableid) {
				case "ITG_GAME":
					this.parseItgGame(s);
					break;
				case "ITG_GAME_STAKE":
					this.parseGameStake(s);
					break;
				case "ITG_GAME_WIN_INDEX":
					this.parseWin(s);
					break;
				case "ITG_WIN_INDEX_SYMBOL":
					this.parseSymbols(s);
					break;
			}
		});
	}

	/**
	 * Loads a sql usr file and translates into a JSON format
	 */
	public importUsr(content: string): void {
		const ast = alasql.parse(content) as unknown as IAlaSQLAST;

		// For each statement, check insert intos
		ast.statements.forEach((s: IAlaSQLStatement) => {
			if (s.into && s.into.tableid === "REF_USR_EXTERNAL_SERVICE") {
				this.croupierConf.productName =
					this.croupierConf.masterGameCode =
					this.croupierConf.infos.serviceName =
						this.pickValueOf<string>(s, "EXS_NAME");
				this.croupierConf.infos.description = this.pickValueOf<string>(s, "EXS_DESCRIPTION");
				this.croupierConf.infos.engineCode = this.pickValueOf<string>(s, "ECO_CODE");
				this.croupierConf.infos.serviceCode = this.pickValueOf<string>(s, "EXS_CODE");
				this.croupierConf.infos.type = this.pickValueOf<string>(s, "EXS_TYPE");
				this.croupierConf.infos.bicCode = Number.parseInt(
					this.pickValueOf<string>(s, "EXS_ACCOUNT_NUMBER"),
					10
				);

				if (this.croupierConf.infos.serviceCode === "undefined") {
					logger.warn(`serviceCode was not defined, it will be set to "XXX"`);
					this.croupierConf.infos.serviceCode = "XXX";
				}
			}
		});
	}

	/**
	 * extract game info
	 */
	private parseItgGame(statement: IAlaSQLStatement): void {
		this.croupierConf.renewal = this.pickValueOf<number>(statement, "GAM_RENEWAL");
		this.croupierConf.version = this.pickValueOf<number>(statement, "GAM_REVISION");
		this.croupierConf.code = this.pickValueOf<string>(statement, "GAM_CODE");
	}

	/**
	 * Add a stake to the stakes list
	 */
	private parseGameStake(statement: IAlaSQLStatement): void {
		this._stakes.push({
			value: this.pickValueOf<number>(statement, "GST_STAKE"),
			currency: this.pickValueOf<string>(statement, "GST_CURRENCY").toLowerCase().trim(),
		});
	}

	/**
	 * Add a rank to the rank list
	 */
	private parseWin(statement: IAlaSQLStatement): void {
		const rank: IRank = {
			id: this.pickValueOf<number>(statement, "GWI_WIN_INDEX"),
			factor: {
				numerator: this.pickValueOf<number>(statement, "GWI_WIN_FACTOR") * 100,
				denominator: this.pickValueOf<number>(statement, "GWI_REFERENCE_STAKE"),
			},
			renewal: this.pickValueOf<number>(statement, "GWI_RENEWAL"),
			tickets: [],
		};

		this.croupierConf.ranks.push(rank);
	}

	/**
	 * Add ticket to the matching rank
	 */
	private parseSymbols(statement: IAlaSQLStatement): void {
		const rankId = this.pickValueOf<number>(statement, "GWI_WIN_INDEX");
		const rank = this.croupierConf.ranks.find((each) => each.id === rankId);

		const ticket: ITicket = {
			id: this._nextId(),
			symbol: this.pickValueOf<string>(statement, "WSY_WINNING_SYMBOL"),
			quantity: this.pickValueOf<number>(statement, "WSY_NUMBER_OF_TICKETS"),
			bonus: this.pickValueOf<string>(statement, "WSY_BONUS") === "1",
			tv: this.pickValueOf<string>(statement, "WSY_TV") === "1",
			extra: this.pickValueOf<number>(statement, "WSY_EXTRA") === 1,
			metadatas: { shape: "" },
		};

		rank.tickets.push(ticket);
	}

	private pickValueOf<T>(statement: IAlaSQLStatement, columnid: string): T {
		for (let i = 0; i < statement.columns.length; i++) {
			if (statement.columns[i].columnid === columnid) {
				if (statement.values) {
					return statement.values[0][i].value;
				} else if (statement.select) {
					return statement.select.columns[i].value;
				}
			}
		}

		return undefined;
	}

	private _nextId(): number {
		return this._id++;
	}
}
