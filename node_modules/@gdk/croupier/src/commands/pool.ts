import { JsonValidator, logger } from "@gdk/backutils";
import * as fs from "fs";
import * as path from "path";
import * as process from "process";
import type {
	ICroupier,
	ICroupierConfig,
	ATicketClass,
	IRank,
	IShape,
	SymbolDescription,
	ICroupierUsrInfos,
} from "@gdk/backutils";

import { loadClass } from "../tools/loadClass";
import { SeedLodash } from "../tools/seedLodash";
import { computeHashes } from "../tools/hashes";
import * as config from "./config";

const CROUPIER_SCHEMA = path.join(__dirname, "..", "..", "resources", "croupier-schema-1.json");

export class Generator<T extends ATicketClass> {
	private nextId: number = 0;
	private usedSymbols: string[] = [];
	private usedIds: number[] = [];

	public constructor(
		private conf: ICroupierConfig,
		private packageJson: any,
		private symbolClass?: any
	) {
		logger.info(`generate using seed : ${conf.seed}`);
		config.validate(conf);
		SeedLodash.seed(conf.seed);

		// a symbol class is needed if at least one rank has a shape having quantity > 0
		const needSymbolClass = conf.ranks.some((rank) => {
			return (
				rank.shapes instanceof Array &&
				rank.shapes.length > 0 &&
				rank.shapes.some((shape) => shape.quantity > 0)
			);
		});

		if (needSymbolClass && this.symbolClass === undefined) {
			const ticketClassPath = path.resolve(process.cwd(), ".build", "src", "ticket.js");
			this.symbolClass = loadClass<any>(ticketClassPath);
		}

		this.nextId = 0;
		this.usedIds = [];
		this.usedSymbols = [];
	}

	/**
	 * Run the generation
	 */
	public run(): ICroupier {
		const res: ICroupier = {
			schemaVersion: 3,
			productName: this.packageJson.name,
			productVersion: this.packageJson.version,
			version: 1,
			date: Date.now(),
			masterGameCode: this.conf.masterGameCode,
			code: this.conf.code,
			description: this.conf.description || `dealer ${this.conf.code}`,
			renewal: this.conf.renewal,
			baseStake: this.conf.baseStake,
			infos: this.conf.infos,
			ranks: [],
			seed: this.conf.seed,
		};

		// Order ranks
		// TODO: autogenerate rank ids ??
		this.conf.ranks = SeedLodash.instance.sortBy(
			this.conf.ranks,
			(r) => -r.factor.numerator / r.factor.denominator
		);

		for (const rank of this.conf.ranks) {
			rank.prizeDescription = rank.prizeDescription
				? `${this._prefix(rank.id)} - ${rank.prizeDescription}`
				: undefined;
			// TODO: auto generate prizeDescription ?
			// `${this._prefix(rank.id)} - ${.format(rank.factor.numerator / rank.factor.denominator * this.conf.stakes[0].value)}`;
		}

		// look for already made tickets
		for (const rank of this.conf.ranks) {
			if (rank.tickets) {
				rank.tickets = rank.tickets.filter((ticket) => {
					return ticket.quantity > 0;
				});

				for (const ticket of rank.tickets) {
					if (this.usedSymbols.indexOf(ticket.symbol) > -1) {
						logger.warn(`symbol ${ticket.symbol} appears several times in made tickets`);
					} else if (this.usedIds.indexOf(ticket.id) > -1) {
						throw new Error(`id ${ticket.id} appears several times in made tickets`);
					} else {
						this.usedSymbols.push(ticket.symbol);
						this.usedIds.push(ticket.id);
					}
				}
			} else {
				rank.tickets = [];
			}
		}

		// execute before
		if (this.symbolClass?.beforeAll) {
			this.symbolClass.beforeAll(this.conf);
		}

		for (const rank of this.conf.ranks) {
			if (rank.shapes) {
				for (const shape of rank.shapes) {
					while (shape.dbRecordQuantity > 0) {
						const aticket = this.getTicketFromShape(rank, shape);
						const symbol = this._symbolToString(aticket.toSymbol());
						this.usedSymbols.push(symbol);

						const quantity = Math.ceil(shape.quantity / shape.dbRecordQuantity);
						shape.quantity -= quantity;
						shape.dbRecordQuantity--;

						rank.tickets.push({
							id: this.nextTicketId(),
							symbol,
							quantity,
							metadatas: aticket.toMetadatas(),
							tv: SeedLodash.instance.isUndefined(aticket.tv) ? undefined : aticket.tv,
							bonus: SeedLodash.instance.isUndefined(aticket.bonus) ? undefined : aticket.bonus,
							extra: SeedLodash.instance.isUndefined(aticket.extra) ? undefined : aticket.extra,
						});
					}
				}
				delete rank.shapes;
			}
		}

		res.ranks.push(...this.conf.ranks);

		// Autogenerate renewalls if needed
		/*let totalTicket = 0;
		for (const r of res.ranks) {
			if (r.id === 1 && SeedLodash.instance.isUndefined(r.renewal)) { r.renewal = 1; } // renewal = 1 on rank 1.
			totalTicket += r.tickets.reduce((s, t) => s += t.quantity, 0);
		}
		if (SeedLodash.instance.isUndefined(res.renewal)) {
			res.renewal = totalTicket - 1;
		}*/

		// execute after
		if (this.symbolClass?.afterAll) {
			this.symbolClass.afterAll(this.conf, res);
		}

		res.hashes = computeHashes(res);

		// Validate output against schema
		const validator = new JsonValidator(JSON.parse(fs.readFileSync(CROUPIER_SCHEMA).toString()));
		validator.assert(res);

		return res;
	}

	private getTicketFromShape(rank: IRank, shape: IShape): T {
		let tries = 0;
		let ok = false;
		let ticket: T;
		do {
			if (tries++ >= 100) {
				throw new Error(`Not able to generate a new symbol after ${tries} tries`);
			}
			ticket = new this.symbolClass(this.conf, rank, shape);
			const symbol = this._symbolToString(ticket.toSymbol());
			if (this.usedSymbols.indexOf(symbol) === -1) {
				ok = true;
			}
		} while (!ok);
		return ticket;
	}

	private nextTicketId(): number {
		do {
			this.nextId++;
		} while (this.usedIds.indexOf(this.nextId) !== -1);

		return this.nextId;
	}

	private _prefix(n: number): string {
		let res = "";
		if (n === 0) {
			return (res = String(n));
		}

		switch (n % 100) {
			case 1:
			case 21:
			case 31:
			case 41:
			case 51:
			case 61:
			case 71:
			case 81:
			case 91:
				res = `${n}st`;
				break;
			case 2:
			case 22:
			case 32:
			case 42:
			case 52:
			case 62:
			case 72:
			case 82:
			case 92:
				res = `${n}nd`;
				break;
			case 3:
			case 23:
			case 33:
			case 43:
			case 53:
			case 63:
			case 73:
			case 83:
			case 93:
				res = `${n}rd`;
				break;
			case 11:
			case 12:
			case 13:
			default:
				res = `${n}th`;
				break;
		}
		return res;
	}

	private _formatAmount(a: number): string {
		return new Intl.NumberFormat("en-US", {
			style: "currency",
			currency: this.conf.stakes[0].currency,
		})
			.format(a)
			.replace(/,/g, ".");
	}

	private _symbolToString(symbol: SymbolDescription): string {
		if (!SeedLodash.instance.isString(symbol)) {
			symbol = `|JSON|${JSON.stringify(symbol)}`;
		}
		return symbol;
	}

	private _stringToSymbol(symbol: string): SymbolDescription {
		const matches = symbol.match(/^(\|JSON\|)(.*)/);
		if (matches) {
			symbol = JSON.parse(matches[2]);
		}
		return symbol;
	}
}

export function generateUsrSql(infos: ICroupierUsrInfos): string {
	const ecoCode = infos.engineCode || "ITG";
	return `UPDATE REF_USR_EXTERNAL_SERVICE SET
	EXS_NAME = '${infos.serviceName}',
	EXS_DESCRIPTION = '${infos.description || infos.serviceName}',
	EXS_TYPE = '${infos.type}',
	EXS_ACCOUNT_NUMBER = '${infos.bicCode}',
	EXS_CREATED = SYSDATE,
	EXS_UPDATED = SYSDATE
	WHERE ECO_CODE ='${ecoCode}' AND EXS_CODE = '${infos.serviceCode}';

INSERT INTO REF_USR_EXTERNAL_SERVICE( ECO_CODE, EXS_CODE, EXS_NAME, EXS_DESCRIPTION, EXS_TYPE, EXS_ACCOUNT_NUMBER, EXS_CREATED, EXS_UPDATED)
	SELECT '${ecoCode}', '${infos.serviceCode}', '${infos.serviceName}', '${
		infos.description || infos.serviceName
	}', '${infos.type}', '${infos.bicCode}', SYSDATE, SYSDATE FROM DUAL
	WHERE NOT EXISTS( SELECT 1 FROM REF_USR_EXTERNAL_SERVICE WHERE ECO_CODE ='${ecoCode}' AND EXS_CODE = '${
		infos.serviceCode
	}');

INSERT INTO usr_site_offer( ECO_CODE, EXS_CODE, SIT_CODE, SIO_STATUS, SIO_CREATED, SIO_UPDATED)
	select '${ecoCode}', '${infos.serviceCode}', 'FDJ_WEB', 'C', sysdate, sysdate from dual
	where not exists (select 1 from usr_site_offer where ECO_CODE = '${ecoCode}' and EXS_CODE = '${
		infos.serviceCode
	}' and SIT_CODE = 'FDJ_WEB');

INSERT INTO usr_limit_domain( ECO_CODE, EXS_CODE, SIT_CODE, LIT_CODE, LID_CREATED, LID_UPDATED)
	select '${ecoCode}', '${infos.serviceCode}', 'FDJ_WEB', 'AMT_CMP', sysdate, sysdate from dual
	where not exists (select 1 from usr_limit_domain where ECO_CODE = '${ecoCode}' and EXS_CODE = '${
		infos.serviceCode
	}' and SIT_CODE = 'FDJ_WEB' and LIT_CODE='AMT_CMP');

INSERT INTO usr_limit_domain( ECO_CODE, EXS_CODE, SIT_CODE, LIT_CODE, LID_CREATED, LID_UPDATED)
	select '${ecoCode}', '${infos.serviceCode}', 'FDJ_WEB', 'AMT_SPDVUV', sysdate, sysdate from dual
	where not exists (select 1 from usr_limit_domain where ECO_CODE = '${ecoCode}' and EXS_CODE = '${
		infos.serviceCode
	}' and SIT_CODE = 'FDJ_WEB' and LIT_CODE='AMT_SPDVUV');

INSERT INTO usr_limit_domain( ECO_CODE, EXS_CODE, SIT_CODE, LIT_CODE, LID_CREATED, LID_UPDATED)
	select '${ecoCode}', '${infos.serviceCode}', 'FDJ_WEB', 'AMT_SPDEUR', sysdate, sysdate from dual
	where not exists( select 1 from usr_limit_domain where ECO_CODE = '${ecoCode}' and EXS_CODE = '${
		infos.serviceCode
	}' and SIT_CODE = 'FDJ_WEB' and LIT_CODE='AMT_SPDEUR');`;
}
