import { strict as assert } from "assert";
import * as fs from "fs";
import * as path from "path";
import * as lodash from "lodash";
import { Numeral } from "@gdk/core";
import { ATicketClass, IShape, logger } from "@gdk/backutils";
import type { ICroupier, ICroupierConfig, IRankConfig, IRank, ITicket } from "@gdk/backutils";

import { SeedLodash } from "../tools/seedLodash";
import { validate as validateConfig } from "./config";
import * as lotteries from "../lotteries";
import { computeHashes } from "../tools/hashes";
import { loadClass } from "../tools/loadClass";
import { Generator } from "./pool";
import * as random from "../tools/random";
import * as parseTilut from "../tools/parseTilut";
import * as parsePetfile from "../tools/parsePetfile";
import * as parseCroupier from "../tools/parseCroupier";

export interface IConvertSource {
	[id: string]: IConvertRank;
}

export interface IConvertRank {
	value: number;
	weight: number;
	symbols: IConvertSymbol[];
}

export interface IConvertSymbol {
	shape: number | string;
	weight: number;
	source: string;
	symbol: string;
}

export type ParseSymbol = (shape: string) => string;

export interface ISymbolClass {
	constructor(seed: string);
	toString(): string;
}

export function extractConvertSource(params: {
	currentPath: string;
	filePath: string;
	symbolClassPath?: string;
}): IConvertSource {
	const { ext } = path.parse(params.filePath);

	const filePath =
		params.filePath[0] === "/"
			? path.resolve(params.filePath)
			: path.resolve(params.currentPath, params.filePath);

	if (!fs.existsSync(filePath)) {
		throw new Error(`Convert source file was not found: ${filePath}`);
	}

	let parseSymbol: undefined | ParseSymbol;
	if (params.symbolClassPath !== undefined) {
		const symbolClassPath =
			params.symbolClassPath[0] === "/"
				? path.resolve(params.symbolClassPath)
				: path.resolve(params.currentPath, params.symbolClassPath);

		const symbolClass = loadClass<ISymbolClass>(symbolClassPath);
		parseSymbol = (shape: string) => new symbolClass(shape).toString();
	}

	switch (ext) {
		case ".pet":
			return parsePetfile.parse(filePath, parseSymbol);
		case ".tilut":
			return parseTilut.parse(filePath, parseSymbol);
		case ".json":
			return parseCroupier.parse(filePath, parseSymbol);
		default:
			throw new Error(`cannot handle convert source file with extension "${ext}": "${filePath}"`);
	}
}

export class Converter {
	protected config: ICroupierConfig;
	protected source: IConvertSource;
	protected version: string;
	protected name: string;

	protected lotteryConf: lotteries.IConvertConfig;
	protected lotteryCode: string;

	public constructor(
		config: ICroupierConfig,
		source: IConvertSource,
		context: { name: string; version: string }
	) {
		this.config = config;
		this.source = source;
		this.name = context.name;
		this.version = context.version;

		this.validateConfig(config);

		logger.info(`using seed : ${this.config.seed}`);
		SeedLodash.seed(this.config.seed);

		const configShapes = lodash.uniq(
			lodash
				.flatten(this.config.ranks.map((rank) => rank.shapes))
				.filter((shape) => shape.quantity > 0)
				.map((shape) => shape.value)
		);
		const sourceShapes = lodash.values(this.source).map((shape) => String(shape.value));
		const missingShapes = lodash.difference(configShapes, sourceShapes);
		assert(
			missingShapes.length === 0,
			`some shape value referenced in config cannot be found in source file:` +
				` [${missingShapes.join(", ")}]`
		);
	}

	protected validateConfig(config: any): void {
		assert(
			config.hasOwnProperty("lottery") &&
				typeof config.lottery === "string" &&
				lotteries.CONVERT_CONFIGS.hasOwnProperty(config.lottery),
			`invalid lottery code in config: ${config.lottery ?? "undefined"}`
		);
		this.lotteryCode = config.lottery;
		this.lotteryConf = lotteries.CONVERT_CONFIGS[this.lotteryCode];

		// pre check if dbRecorQuantities are set,
		// raises a dedicated error with available symbols if not set
		// (more explicit than the validateConfig error)
		const dbRecordQantities = this.autosetDbRecordQuantities(config);

		validateConfig(config);

		// validate dbRecordQantities / quantities against available symbols
		this.validateConfigQuantities(config as ICroupierConfig);
	}

	protected validateConfigQuantities(config: ICroupierConfig): void {
		const multiplyQuantitiesBy = this.config.multiplyQuantitiesBy ?? 1;
		const errorMessages: string[] = [];

		let poolSize = 0;

		for (const rankConfig of config.ranks) {
			for (const shapeConfig of rankConfig.shapes) {
				const available = this.source[shapeConfig.value]?.weight ?? 0;

				const shapeWeight = this.source[shapeConfig.value]?.weight ?? 0;
				poolSize += shapeConfig.quantity;

				if (shapeConfig.quantity > 0 && shapeWeight === 0) {
					errorMessages.push(`Shape not found in source: "${shapeConfig.value}"`);
				}

				if (shapeConfig.dbRecordQuantity > shapeWeight) {
					errorMessages.push(
						`At least one shape has: symbols in source file < dbRecordQuantity. ` +
							`Rank "${rankConfig.id}" / shape "${shapeConfig.value}": ` +
							`dbRecordQuantity = ${shapeConfig.dbRecordQuantity}` +
							` > available symbols in source file = ${shapeWeight}`
					);
				}

				// in not depleting mode, every available symbol should be used
				// print a warning if available symbols > dbRecordQuantity
				if (!this.isDepleting && shapeConfig.dbRecordQuantity < available) {
					logger.warn(
						`rank "${rankConfig.id}" / shape "${shapeConfig.value}": ` +
							`unusual for a non depleting dealer: ` +
							`using ${shapeConfig.dbRecordQuantity} / ${available} symbols available.`
					);
				}

				const actualQuantity = multiplyQuantitiesBy * shapeConfig.quantity;
				if (shapeConfig.dbRecordQuantity > actualQuantity) {
					errorMessages.push(
						`At least one shape has: ticket quantity < dbRecordQuantity. ` +
							`Rank "${rankConfig.id}" / shape "${shapeConfig.value}": ` +
							`quantity ${actualQuantity} < dbRecordQuantity = ${shapeConfig.dbRecordQuantity}. ` +
							`Maybe multiply all quantities with config field "multiplyQuantitiesBy" ?`
					);
				}
			}
		}

		if (config.renewal > poolSize) {
			errorMessages.push(
				`Invalid renewal > pool size. ` +
					` Configuration renewal (${config.renewal}) should be lower or equal` +
					` to the pool size (${poolSize})`
			);
		}

		if (errorMessages.length > 0) {
			throw new Error(errorMessages.join("\n"));
		}
	}

	protected autosetDbRecordQuantities(
		config: any
	): Array<{ rank: string; shape: string; dbQuantity: number; availableSymbols: number }> {
		const ranks = config.ranks;
		const records: Array<{
			rank: string;
			shape: string;
			dbQuantity: number;
			availableSymbols: number;
		}> = [];

		if (ranks instanceof Array) {
			for (const rank of ranks) {
				const shapes = rank.shapes;
				if (shapes instanceof Array) {
					for (const shape of shapes) {
						const availableSymbols = this.source[shape.value]?.weight ?? 0;

						if (shape.dbRecordQuantity === undefined) {
							logger.debug(
								`rank "${rank.id}" / shape "${shape.value}": ` +
									`dbRecordQuantity not set, setting it to number of available symbols ` +
									`in source file: ${availableSymbols}`
							);
							shape.dbRecordQuantity = availableSymbols;
						}

						records.push({
							rank: rank.id,
							shape: shape.value,
							dbQuantity: shape.dbRecordQuantity,
							availableSymbols,
						});
					}
				}
			}
		}

		return records;
	}

	protected get isDepleting(): boolean {
		return this.lotteryConf.depleting;
	}

	protected computeRenewal(): number {
		if (this.config.renewal !== undefined) {
			return this.config.renewal;
		} else if (this.lotteryConf.computeRenewal !== undefined) {
			const multiplyQuantitiesBy = this.config.multiplyQuantitiesBy ?? 1;
			const poolSize = lodash.sum(
				lodash.flatten(
					this.config.ranks.map(({ shapes }) => shapes.map(({ quantity }) => quantity))
				)
			);
			return this.lotteryConf.computeRenewal(multiplyQuantitiesBy * poolSize);
		} else {
			return 0;
		}
	}

	/**
	 * Run source convertion into a dealer
	 */
	public run(): ICroupier {
		const dealer: ICroupier = {
			schemaVersion: 3,
			productName: this.name,
			productVersion: this.version,
			version: 1,
			date: Date.now(),
			masterGameCode: this.config.masterGameCode,
			code: this.config.code,
			description: this.config.description ?? `${this.lotteryCode} : ${this.config.code}`,
			renewal: this.computeRenewal(),
			baseStake: this.config.baseStake,
			ranks: this.extractRanks(),
			seed: this.config.seed,
		};

		// update ticket ids
		let ticketId = 1;
		for (const rank of dealer.ranks) {
			for (const ticket of rank.tickets) {
				ticket.id = ticketId++;
			}
		}

		// ensure lotteryConf.depleting matches dealer renewal
		if (this.lotteryConf.depleting) {
			assert(
				dealer.renewal > 0,
				`Dealer renewal is disabled (== 0) ` +
					`but lottery ${this.lotteryCode} is configured as depleting`
			);
		} else {
			assert(
				dealer.renewal === 0,
				`Dealer renewal is enabled (!= 0) ` +
					`but lottery ${this.lotteryCode} is configured as NON depleting`
			);
		}

		dealer.hashes = computeHashes(dealer);

		const pool = new Generator(dealer, { version: this.version, name: this.name });
		return pool.run();
	}

	protected extractRanks(): IRank[] {
		const ranks: IRank[] = this.config.ranks.map((rankConfig, index) => {
			const rank: IRank = {
				id: rankConfig.id ?? index + 1,
				factor: rankConfig.factor,
				tickets: this.extractRankTickets(rankConfig),
				prizeDescription: rankConfig.prizeDescription,
			};

			if (rankConfig.prizeType !== undefined) {
				rank.prizeType = rankConfig.prizeType;
			}

			return rank;
		});

		// update descriptions
		if (this.lotteryConf.prizeDescriptions ?? true) {
			const stake = this.config.baseStake;
			for (const rank of ranks) {
				if (rank.prizeDescription === undefined) {
					rank.prizeDescription = Numeral.currency({
						value: (rank.factor.numerator / rank.factor.denominator) * stake,
						currency: this.lotteryConf.currency,
					});
				}
			}
		}

		return ranks;
	}

	protected extractRankTickets(rankConfig: IRankConfig): ITicket[] {
		let tickets: ITicket[] = [];
		const shapes = rankConfig.shapes ?? [];

		// debug logs
		const nbSourceSymbols = lodash.sum(
			shapes.map(({ value }) => this.source[value]?.symbols.length ?? 0)
		);
		logger.debug(
			`extracting tickets for rank ${rankConfig.id}: collecting tickets` +
				` from ${Numeral.format(nbSourceSymbols)} symbols in source pool...`
		);
		let nbSourceSymbolsBeforeLog = nbSourceSymbols * 0.2;

		const multiplyQuantitiesBy = this.config.multiplyQuantitiesBy ?? 1;

		for (const shapeConfig of shapes) {
			// skip shape having quantity === 0
			if (shapeConfig.quantity === 0) {
				continue;
			}

			const sourceShape = this.source[shapeConfig.value];
			const shapeQuantity = multiplyQuantitiesBy * shapeConfig.quantity;

			// deduct the symbol pool from dbRecordQuantity
			const symbols =
				shapeConfig.dbRecordQuantity < sourceShape.symbols.length
					? random.shuffle(sourceShape.symbols).slice(0, shapeConfig.dbRecordQuantity)
					: sourceShape.symbols;

			const shapeWeight = lodash.sum(symbols.map((symbol) => symbol.weight)) ?? 0;

			let shapeQuantityLeft = shapeQuantity;
			let shapeWeightLeft = shapeWeight;

			const shapeTickets: ITicket[] = [];

			for (const { symbol, weight, source, shape } of symbols) {
				const quantity = Math.ceil((shapeQuantityLeft * weight) / shapeWeightLeft);
				shapeQuantityLeft -= quantity;
				shapeWeightLeft -= weight;
				shapeTickets.push({
					id: 0,
					symbol,
					quantity,
					metadatas: {
						shape: String(shape),
						source: lodash.truncate(source, { length: 500, omission: " [...]" }),
					},
				});

				// debug logs: report extraction progress
				if (--nbSourceSymbolsBeforeLog <= 0) {
					const progress = shapeTickets.length / nbSourceSymbols;
					logger.debug(`    symbol collection: ${Math.round(100 * progress)} % done`);
					nbSourceSymbolsBeforeLog = nbSourceSymbols * 0.2;
				}
			}

			// ensure the ticket quantity comply with shape configuration
			// and adjust last ticket quantity if the difference is 1 at most
			const actualQuantity = lodash.sum(shapeTickets.map((ticket) => ticket.quantity));
			const quantityDiff = actualQuantity - shapeQuantity;
			if (quantityDiff !== 0) {
				assert(
					Math.abs(quantityDiff) <= 1,
					`shape "${shapeConfig.value}": actual quantity: ${actualQuantity} differs too much` +
						` from expected quantity: ${shapeQuantity}` +
						` (= ${shapeConfig.quantity} x ${multiplyQuantitiesBy})`
				);
				shapeTickets[shapeTickets.length - 1].quantity -= quantityDiff;
			}

			// in non depleting mode, ticket with quantity == 0 are not allowed
			if (!this.isDepleting) {
				const wrongTickets = shapeTickets.filter((ticket) => ticket.quantity === 0);
				if (wrongTickets.length > 0) {
					assert.fail(
						`shape ${JSON.stringify(shapeConfig)} has ${wrongTickets.length} tickets ` +
							`with quantity == 0. example: ${JSON.stringify(wrongTickets[0], null, 4)}`
					);
				}
			}

			tickets = tickets.concat(shapeTickets);
		}

		// deduplicate tickets having same symbol
		const uniqTickets = lodash.uniqBy(tickets, "symbol");
		if (uniqTickets.length !== tickets.length) {
			logger.debug("    symbol deduplication: in progress");

			for (const uniqTicket of uniqTickets) {
				for (const ticket of tickets) {
					if (ticket.symbol === uniqTicket.symbol && ticket !== uniqTicket) {
						uniqTicket.quantity += ticket.quantity;
					}
				}
			}

			logger.debug(
				`    symbol deduplication: done.` +
					` (${Numeral.format(tickets.length)} -> ${Numeral.format(uniqTickets.length)})`
			);
		}

		// tickets with quantity = 0 are accepted only if they are the only one in
		// the list
		return uniqTickets.filter((ticket, index) => {
			return ticket.quantity > 0 || (index === 0 && uniqTickets.length === 1);
		});
	}

	/**
	 * Adjust rank quantities to use every symbol of source.
	 * WARNING: generally raises the quantity of tickets in ranks. Do not use in a depleting
	 * dealer !
	 */
	protected adjustRankQuantities(ranks: IRankConfig[]): void {
		// If it is a non depleting pool
		// find ranks with more symbol than pool occurences to determine
		// a coef to apply on the number of occurences
		const ratios = ranks.map((rank, i) => {
			const shapes = rank.shapes ?? [];
			return shapes.map((shape) => {
				return shape.quantity === 0
					? 0
					: Math.ceil(this.source[shape.value].weight / shape.quantity);
			});
		});

		const mult = lodash.max(lodash.flatten(ratios)) ?? 0;
		if (mult > 1) {
			for (const rank of ranks) {
				for (const shape of rank.shapes) {
					shape.quantity *= mult;
				}
			}
		}
	}
}
