import { JsonValidator, logger } from "@gdk/backutils";
import * as lodash from "lodash";
import fs from "fs";
import path from "path";
import { strict as assert } from "assert";
import uuid from "uuid";
import type { ICroupierConfig } from "@gdk/backutils";

import { CONVERT_CONFIGS, appendRanksAtEnd } from "../lotteries";
import { extractConvertSource } from "./convert";

const CONF_SCHEMA = path.join(__dirname, "..", "..", "resources", "conf-schema.json");

export function validate(conf: ICroupierConfig): void {
	const validator = new JsonValidator(JSON.parse(fs.readFileSync(CONF_SCHEMA).toString()));
	validator.assert(conf);

	// rank ids should be unique
	const rankIds = lodash.uniq(conf.ranks.map((rank) => rank.id));
	assert(rankIds.length === conf.ranks.length, `rank ids are not unique`);

	// rank ids should be consecutive and start at 1
	rankIds.sort((a: number, b: number) => a - b);
	const expRankIds = lodash.range(1, rankIds.length + 1);
	assert.deepEqual(
		rankIds,
		expRankIds,
		`rank ids should be consecutive integers starting at 1` +
			` (found [${rankIds.join(", ")}], expected [${expRankIds.join(", ")}])`
	);
}

export interface IInitOptions {
	masterGameCode?: string;
	code?: string;
	lotteryCode?: string;
	sourceFile?: string;
}

export function init(options: IInitOptions): ICroupierConfig {
	const config: ICroupierConfig = {
		masterGameCode: options.masterGameCode ?? "SET HERE: masterGameCode",
		code: options.code ?? "SET HERE: variantCode",
		baseStake: 1,
		seed: uuid.v4(),
		ranks: [],
	};

	if (options.lotteryCode !== undefined) {
		options.lotteryCode = options.lotteryCode.toUpperCase();
		if (!Object.keys(CONVERT_CONFIGS).includes(options.lotteryCode)) {
			logger.error(
				`config.init: invalid lottery code: "${options.lotteryCode}".` +
					` Supported lottery codes:` +
					`["${Object.keys(CONVERT_CONFIGS).join('", "')}"]`
			);
			process.exit(1);
		}

		config.lottery = options.lotteryCode;
	}

	if (options.sourceFile !== undefined) {
		if (options.lotteryCode === undefined) {
			logger.error(
				`config.init: lottery code is needed when generating a configuration` +
					`with a source file.`
			);
			process.exit(1);
		}

		initFromSourceFile(config, options.lotteryCode, options.sourceFile);

		CONVERT_CONFIGS[options.lotteryCode].initConfig?.(config);
	}

	return config;
}

export function initFromSourceFile(
	config: ICroupierConfig,
	lotteryCode: string,
	sourceFile: string
): void {
	const source = extractConvertSource({
		currentPath: process.cwd(),
		filePath: sourceFile,
	});

	config.sourceFile = `./${path.basename(sourceFile)}`;

	config.ranks = lodash.values(source).map(({ value, weight, symbols }) => {
		return {
			id: value,
			factor: { numerator: 1, denominator: 1 },
			shapes: [{ quantity: 0, dbRecordQuantity: weight, value: String(value) }],
		};
	});

	appendRanksAtEnd(config);
}

/**
 * Merge the config with requirements, requirements override data in config
 * @param conf
 * @param requirements
 */
export function mergeWithRequirements(
	conf: ICroupierConfig,
	requirements: object
): ICroupierConfig {
	/*if (!conf.infos) {
		conf.infos = {} as any;
	}

	for (const key of Object.keys(requirements)) {
		switch (key) {
			case "serviceName":
				conf.serviceName = requirements.serviceName;
				break;
			case "gameCode":
				conf.infos.gameCode = requirements.gameCode;
				break;
			case "serviceCode":
				conf.infos.serviceCode = requirements.serviceCode;
				break;
			case "bicCode":
				conf.infos.bicCode = requirements.bicCode;
				break;
			case "bicVariant":
				conf.infos.bicVariant = requirements.bicVariant;
				break;
			case "type":
				conf.infos.type = requirements.type;
				break;
			case "stakes":
				if (requirements.stakes.length) {
					conf.stakes = requirements.stakes;
				}
				break;
		}
	}*/

	return conf;
}
