import { logger } from "@gdk/backutils";
import * as lodash from "lodash";
import * as fs from "fs";
import { posix as path } from "path";
import chalk from "chalk";

import * as config from "./config";

export interface IFileChanges {
	[filepath: string]: string | null;
}

export interface IAddOptions {
	logLevel: string;
	gameDirectory: string;
	lotteryCode?: string;
	sourceFile?: string;
	masterGameCode?: string;
	code?: string;
	pretend?: boolean;
}

export interface IRemoveOptions {
	force: boolean;
	logLevel: string;
	all: boolean;
	gameDirectory: string;
}

export class RemoveError extends Error {
	public constructor(message: string) {
		super(message);
		this.name = "RemoveError";
	}
}

function formatChanges(changes: IFileChanges): string {
	return Object.keys(changes)
		.map((p) => {
			const status =
				changes[p] !== null ? chalk.green(fs.existsSync(p) ? "M" : "A") : chalk.red("D");
			const relativePath = path.relative(process.cwd(), p);
			return `${status}  ${chalk.white(relativePath)}`;
		})
		.join("\n");
}

function applyChanges(changes: IFileChanges): void {
	// apply changes
	for (const p in changes) {
		if (!changes.hasOwnProperty(p)) {
			continue;
		}
		const value = changes[p];

		if (value === null) {
			fs.rmSync(p, { recursive: true });
		} else if (value === "" && p[p.length - 1] === "/") {
			// empty directory
			fs.mkdirSync(p, { recursive: true });
		} else {
			fs.mkdirSync(path.dirname(p), { recursive: true });
			fs.writeFileSync(p, value);
		}
	}
}

function readPackageGames(gameDirectory: string = process.cwd()): string[] {
	const gamePackage = fs.readFileSync(path.join(gameDirectory, "package.json"), "utf8");
	const gamePackageJson = JSON.parse(gamePackage);
	return gamePackageJson.games ?? {};
}

function readResourceGames(gameDirectory: string = process.cwd()): string[] {
	const resourceDir = path.join(gameDirectory, "resources");
	return fs
		.readdirSync(resourceDir, { withFileTypes: true })
		.filter((entry) => entry.isDirectory())
		.map((entry) => entry.name);
}

export function add(gameName: string, options: IAddOptions): void {
	const changes: IFileChanges = {};
	computeGameAddition(gameName, options, changes);

	previewAddition(gameName, changes);

	if (options.pretend) {
		logger.info(`in PRETEND MODE: nothing actually done, remove -p option to proceed\n`);
		return;
	}

	applyChanges(changes);
	logger.info("done");
}

function computeGameAddition(gameName: string, options: IAddOptions, changes: IFileChanges): void {
	const gamePackagePath = path.join(options.gameDirectory, "package.json");
	const gamePackage = changes[gamePackagePath] ?? fs.readFileSync(gamePackagePath, "utf8");
	const gamePackageJson = JSON.parse(gamePackage);
	const games = gamePackageJson.games ?? {};

	const resourceDir = path.join(options.gameDirectory, "resources", gameName);
	let confPath = path.join(resourceDir, "conf.json");

	if (!(gameName in games)) {
		games[gameName] = path.relative(options.gameDirectory, confPath);
		gamePackageJson.games = games;

		const packageIndentation = guessIndentation(gamePackage);
		changes[gamePackagePath] = JSON.stringify(gamePackageJson, null, packageIndentation);
	} else {
		confPath = games[gameName];
		if (confPath[0] === "/") {
			confPath = path.join(options.gameDirectory, confPath);
		}
	}

	const specDir = path.join(resourceDir, "specifications");
	if (!fs.existsSync(specDir)) {
		changes[specDir + "/"] = "";
	}

	if (!fs.existsSync(confPath)) {
		const croupierConfig = config.init({
			...options,
			code: options.code ?? gameName,
		});
		changes[confPath] = JSON.stringify(croupierConfig, null, 2);
	}

	const testFile = path.join(options.gameDirectory, "test", gameName, "index.spec.ts");
	if (!fs.existsSync(testFile)) {
		changes[testFile] = generateGameTestCode(gameName);
	}

	if (options.sourceFile !== undefined) {
		const sourceFile = path.join(resourceDir, path.basename(options.sourceFile));
		if (!fs.existsSync(sourceFile)) {
			changes[sourceFile] = fs.readFileSync(options.sourceFile, "utf8");
		}
	}
}

function previewAddition(gameName: string, changes: IFileChanges): void {
	let preview = `add dealers: "${gameName}"\n`;

	// display preview
	if (Object.keys(changes).length === 0) {
		logger.info(preview);
		logger.warn("nothing to do");
		return;
	}

	preview += "\n" + formatChanges(changes) + "\n";

	logger.info(preview);
}

function generateGameTestCode(gameName: string): string {
	const testerClassName = [gameName[0].toUpperCase(), gameName.substr(1), "Tester"].join("");

	return `import { ACroupierTester } from "../croupierTester";

class ${testerClassName} extends ACroupierTester {
	public constructor() {
		super("${gameName}");
	}
}

describe("${gameName}-tests", () => {
	(new ${testerClassName}()).test();
});
`;
}

export function remove(gameNames: string[], options: IRemoveOptions): void {
	if (gameNames.length > 0) {
		if (options.all) {
			throw new RemoveError(`remove: game name arguments and --all option are mutually exclusive`);
		}
	} else {
		if (!options.all) {
			throw new RemoveError(`remove: no game name name specified. nothing to do`);
		}

		const games = readPackageGames(options.gameDirectory);
		gameNames.push(...Object.keys(games));
		const gameDirs = lodash.difference(
			readResourceGames(options.gameDirectory),
			Object.values(games)
		);
		gameNames.push(...gameDirs);
	}

	gameNames = lodash.uniq(gameNames);

	const pretend = !options.force;
	const changes: IFileChanges = {};
	for (const gameName of gameNames) {
		computeGameRemoval(gameName, options.gameDirectory, changes);
	}

	previewRemoval(gameNames, changes);

	if (pretend) {
		logger.info(`in PRETEND MODE: nothing actually removed, add -f option to proceed\n`);
		return;
	}

	applyChanges(changes);
	logger.info("done");
}

function computeGameRemoval(gameName: string, gameDirectory: string, changes: IFileChanges): void {
	const gamePackagePath = path.join(gameDirectory, "package.json");
	const gamePackage = changes[gamePackagePath] ?? fs.readFileSync(gamePackagePath, "utf8");
	const gamePackageJson = JSON.parse(gamePackage);
	const games = gamePackageJson.games ?? {};

	let resourceDir = path.join(gameDirectory, "resources", gameName);

	if (gameName in games) {
		const _resourceDir = path.join(gameDirectory, games[gameName]);
		delete games[gameName];

		gamePackageJson.games = games;

		const packageIndentation = guessIndentation(gamePackage);
		const newGamePackage = JSON.stringify(gamePackageJson, null, packageIndentation);

		if (newGamePackage !== gamePackage) {
			changes[gamePackagePath] = newGamePackage;
		}

		if (!_resourceDir.startsWith(resourceDir)) {
			resourceDir = _resourceDir;
		}
	}

	if (fs.existsSync(resourceDir)) {
		changes[resourceDir] = null;
	}

	const testDir = path.join(gameDirectory, "test", gameName);
	if (fs.existsSync(testDir)) {
		changes[testDir] = null;
	}
}

function previewRemoval(gameNames: string[], changes: IFileChanges): void {
	let preview = `remove dealers: "${gameNames.join(", ")}"\n`;

	// display preview
	if (Object.keys(changes).length === 0) {
		logger.info(preview);
		logger.warn("nothing to do (no file related)");
		return;
	}

	preview += "\n" + formatChanges(changes) + "\n";
	logger.info(preview);
}

const INDENT_PATTERN = /^( *)[^ ]/;

function guessIndentation(content: string): string {
	const lines = content.split("\n");

	if (lines.some((line) => line.startsWith("\t"))) {
		return "\t";
	}

	const level = lines
		.map((line) => INDENT_PATTERN.exec(line)?.[1].length ?? 0)
		.filter((l) => l > 0)
		.sort()[0];

	return " ".repeat(level ?? 0);
}
