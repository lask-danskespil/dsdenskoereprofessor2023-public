import * as lodash from "lodash";

import { SeedLodash } from "./seedLodash";

export enum EUniverseType {
	range = "range",
	weight = "weight",
}

export interface IWeightedValue<T> {
	value: T;
	weight?: number; // if not specified, weight is assumed to be 1.
}

const defaultLabel: string = "___";
export class WeightedValue<T> implements IWeightedValue<T> {
	private _value: T;
	private _weight: number;
	private _labels: { [label: string]: number } = {};

	public constructor(e: IWeightedValue<T>) {
		this._value = e.value;
		this._labels[defaultLabel] = this._weight = SeedLodash.instance.isUndefined(e.weight)
			? 1
			: e.weight;
	}

	public get value(): T {
		return this._value;
	}

	public get weight(): number {
		return this._weight;
	}

	public set weight(w: number) {
		this._weight = w;
	}

	/**
	 * add some weight to an element
	 * @param quantity weight to add to the element
	 */
	public add(quantity: number): void {
		this._weight += quantity;
	}

	/**
	 * remove some weight to an element
	 * @param quantity weight to remove
	 */
	public remove(quantity: number): void {
		this._weight -= Math.min(quantity, this._weight);
	}

	/**
	 * Freeze the
	 */
	public save(name?: string): void {
		this._labels[name || defaultLabel] = this._weight;
	}

	/**
	 * Reset
	 */
	public restore(name?: string): void {
		this._weight = this._labels[name || defaultLabel];
	}
}

export interface IUniverseOptions {
	autoRefill: boolean;
}

export class Universe<T> {
	protected autoRefill: boolean = false;
	protected values: Array<WeightedValue<T>>;
	protected _totalWeight: number;

	public constructor();
	public constructor(values: Array<IWeightedValue<T>>, options?: IUniverseOptions);
	public constructor(min: number, max: number, step?: number, options?: IUniverseOptions);
	public constructor(...params: any[]) {
		this.values = [];
		this._totalWeight = 0;
		let options: undefined | IUniverseOptions;

		if ((params.length === 1 || params.length === 2) && Array.isArray(params[0])) {
			for (const e of params[0]) {
				this._add(new WeightedValue(e));
			}
			options = params[1];
		} else if (params.length > 1 && lodash.isNumber(params[0]) && lodash.isNumber(params[1])) {
			const step = params.length > 2 && lodash.isNumber(params[2]) ? params[2] : 1;
			for (let i = params[0]; i <= params[1]; i += step) {
				this._add(new WeightedValue({ value: i } as any));
			}
			if (params[params.length - 1] instanceof Object) {
				options = params[params.length - 1] as IUniverseOptions;
			}
		}

		this.autoRefill = options?.autoRefill ?? false;
		this.save();
	}

	/**
	 * Returns the size of an universe (number of elements including weights)
	 */
	public size(): number {
		return SeedLodash.instance.sum(this.values.map((e) => e.weight));
	}

	/**
	 * Checks if a specific element is in the unverse
	 */
	public has(value: T): boolean {
		return this.count(value) > 0;
	}

	/**
	 *  Returns the number occurrences of a specific element in a universe
	 */
	public count(value: T): number {
		return SeedLodash.instance.sum(
			this.values.filter((e) => e.value === value).map((e) => e.weight)
		);
	}

	/**
	 * add some element to the universe
	 * @param value IWeightedValue
	 */
	public addValue(value: T, count?: number): void {
		this._add(new WeightedValue({ value, weight: count || 1 }));
	}

	/**
	 * remove some element to the universe
	 * @param value IWeightedValue
	 */
	public removeValue(value: T, count?: number): void {
		this._remove(value, count);
	}

	/**
	 * Pick one element in the universe, won't affect the universe itself as element will be replaced in it
	 */
	public sampleOne(): T {
		let index = this._randIndex();
		for (const value of this.values) {
			index -= value.weight;
			if (index < 0) {
				return value.value;
			}
		}
		// unreachable code
		throw {
			message: `wrong index when getting an element from an universe, Should never occurs`,
			code: 500,
		};
	}

	/**
	 * Pick several element in the universe, won't affect the universe itself as elements will be replaced in it
	 * @param count number of element to draw
	 */
	public sampleMany(count: number): T[] {
		const res: T[] = [];
		for (let i = 0; i < count; i++) {
			res.push(this.sampleOne());
		}
		return res;
	}

	/**
	 * Draw one element from the universe, the element will be removed from the universe
	 */
	public drawOne(): T {
		let index = this._randIndex();
		for (const value of this.values) {
			index -= value.weight;
			if (index < 0) {
				value.weight -= 1;
				this._totalWeight -= 1;

				// auto refill if empty
				if (this.autoRefill && this._totalWeight === 0) {
					this.restore();
				}

				return value.value;
			}
		}

		// unreachable code
		throw {
			message: `wrong index when getting an element from an universe, Should never occurs`,
			code: 500,
		};
	}

	/**
	 * Draw many elements from the universe, the elements will be removed from the universe
	 * @param count
	 */
	public drawMany(count: number): T[] {
		const res: T[] = [];
		for (let i = 0; i < count; i++) {
			res.push(this.drawOne());
		}
		return res;
	}

	/**
	 * Reset the universe to his original state
	 */
	public save(name?: string): void {
		for (const e of this.values) {
			e.save(name);
		}
	}

	/**
	 * Reset the universe to his original state
	 */
	public restore(name?: string): void {
		this._totalWeight = 0;
		for (const e of this.values) {
			e.restore(name);
			this._totalWeight += e.weight;
		}
	}

	private _add(v: WeightedValue<T>): void {
		const existingValue = this.values.find((e) => e.value === v.value);
		if (!existingValue) {
			this.values.push(new WeightedValue(v));
		} else {
			existingValue.add(v.weight);
		}
		this._totalWeight += v.weight;
	}

	private _remove(value: T, count?: number): void {
		if (SeedLodash.instance.isUndefined(count)) {
			for (const v of this.values) {
				if (v.value === value) {
					this._totalWeight -= v.weight;
					v.weight = 0;
				}
			}
		} else {
			for (const v of this.values) {
				if (v.value === value && count > 0) {
					this._totalWeight -= Math.min(count, v.weight);
					v.weight -= Math.min(count, v.weight);
				}
			}
		}
	}

	private _randIndex(): number {
		return SeedLodash.instance.random(this._totalWeight - 1);
	}
}
