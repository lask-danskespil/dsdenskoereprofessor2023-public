import { deepStrictEqual } from "assert";
import * as lodash from "lodash";
import { logger } from "@gdk/backutils";

export interface IScenario {
	v: string | number;
	q: number;
	[key: string]: any;
}

export type IFrequencies = { [scenario: string]: number } & {
	samples?: { [scenario: string]: { [key: string]: any } };
};

function clone<T>(value: T): T {
	return JSON.parse(JSON.stringify(value));
}

/**
 * Compute frequencies from a list of scenarios.
 *
 * @param scenarios: list of weighted values (number or string). Same values can appear twice in
 * the list, their weights will be added
 * @returns a hash with value as keys, and frequencies (percent) as value
 *
 * You can add other keys / values than "v" and "q" in the scenarios. If you do, the first scenario to
 * be registered for a given value withh be kept as a sample, displayed by the describe function of this
 * module.
 *
 *
 * example: getFrequencies([
 *    { v: "scenario 1", q: 10, symbol: "ABBSSC|"},
 *    { v: "scenario 2", q: 10 },
 *    { v: "scenario 2", q: 5, symbol: "AABBSH|0,1,5" }
 *  ]);
 *
 * will return  { "scenario 1": 40,
 *                "scenario 2": 60,
 *                samples: { "scenario 1": { symbol: "ABBSSC|" },
 *                            scenario 2": { symbol: "AABBSH|0,1,5" } }}
 */
export function compute(scenarios: IScenario[]): IFrequencies {
	let total = 0;

	const freqs: IFrequencies = { samples: {} } as IFrequencies;
	for (const scenario of scenarios) {
		total += scenario.q;

		// can this scenario be used as a sample ?
		if (freqs.samples[scenario.v] === undefined && Object.keys(scenario).length > 2) {
			const sample = lodash.pickBy(clone(scenario), (v, key) => key !== "v" && key !== "q");
			freqs.samples[scenario.v] = sample;
		}

		freqs[scenario.v] = (freqs[scenario.v] ?? 0) + scenario.q;
	}

	for (const v in freqs) {
		if (!freqs.hasOwnProperty(v) || v === "samples") {
			continue;
		}
		freqs[v] = (100 * freqs[v]) / total;
	}

	return freqs;
}

/**
 * Return a string representing the given frequencies.
 *
 * @param freqs: a frequency object (key are scenarios, values are pecents)
 * @param padLeft: number of spaces used to pad the list of frequencies
 * @returns string representing the given frequencies
 */
export function describe(freqs: IFrequencies, padLeft: number = 0): string {
	const scenarios = lodash.without(Object.keys(freqs), "samples");
	const scenarioLength = lodash.max(scenarios.map((s) => s.length)) ?? 0;
	const indent = " ".repeat(padLeft);

	const lines: string[] = [];
	for (const scenario of scenarios) {
		let example = "";
		const sample = freqs?.samples?.[scenario];
		if (sample !== undefined) {
			let sampleString = sample !== undefined ? JSON.stringify(sample) : "";
			if (sampleString.length > 100) {
				sampleString = sampleString.substr(0, 97) + "...";
			}
			example = `  (ex.: ${sampleString})`;
		}

		const percents = freqs[scenario].toFixed(2).padStart(5);
		lines.push(
			`${indent}* ${scenario.padEnd(scenarioLength)}:   ${percents.padStart(4)} % ${example}`
		);
	}

	return lines.join("\n");
}

/**
 * Makes an assertion on frequency equality.
 *
 * @param actual: actual frequencies
 * @param exp: expected frequencies
 * @param tolerance: frequency gap (in percent) allowed between actual / expected (below / over).
 *     for exemple, tolerance = 1.5 means for an expected 50% frequency, 48.5 is an acceptable
 *     value, so is 51.5, while 52% is not.
 * @returns string representing the given frequencies
 */
export function assert(actual: IFrequencies, exp: IFrequencies, tolerance: number = 1.5): void {
	logger.debug(`compares actual frequencies: \n${describe(actual, 8)}
    with expected: \n${describe(exp, 8)}`);

	const actualScenarios = lodash.without(Object.keys(actual), "samples");
	actualScenarios.sort();
	const expScenarios = lodash.without(Object.keys(exp), "samples");
	expScenarios.sort();

	deepStrictEqual(
		actualScenarios,
		expScenarios,
		`combinations differ in actual frequencies and in expected frequencies`
	);

	const wrongScenarios = actualScenarios.filter(
		(scenario) => Math.abs(actual[scenario] - exp[scenario]) > tolerance
	);

	deepStrictEqual(
		lodash.pick(actual, wrongScenarios),
		lodash.pick(exp, wrongScenarios),
		`expected and actual frequencies differs too much (> ${tolerance}%)`
	);
}
