import * as fs from "fs";
import * as lodash from "lodash";

import type { IConvertSource, IConvertSymbol, ParseSymbol } from "../commands/convert";

export class ParseTilutError extends Error {
	public constructor(message: string) {
		super(message);
		this.name = "ParseTilutError";
	}
}

const LINE_PATTERN = /^[a-z.]+\.(?<shape>[0-9]+)\.layout = "?(?<symbol>.*[^"])"?$/;

export function parse(
	filePath: string,
	customParseSymbol: ParseSymbol = defaultParseSymbol
): IConvertSource {
	const symbols = fs
		.readFileSync(filePath, { encoding: "latin1" })
		.trim()
		.split("\n")
		.map((shape) => parseLine(shape, customParseSymbol));

	const source: IConvertSource = {};

	const symbolsByShape = lodash.groupBy(symbols, "shape");
	for (const shape in symbolsByShape) {
		if (!symbolsByShape.hasOwnProperty(shape)) {
			continue;
		}
		const rankSymbols = symbolsByShape[shape];
		const weight = lodash.sum(rankSymbols.map((symbol) => symbol.weight)) ?? 0;
		source[shape] = { value: Number(shape), weight, symbols: rankSymbols };
	}

	return source;
}

function parseLine(
	line: string,
	customParseSymbol: ParseSymbol = defaultParseSymbol
): IConvertSymbol {
	const data = LINE_PATTERN.exec(line);

	if (data === null) {
		throw new ParseTilutError(`Invalid line: ${line}`);
	}

	const shape = Number(data.groups.shape);
	const weight = 1;
	const source = line;
	const symbol = customParseSymbol(data.groups.symbol);

	return { shape, symbol, weight, source };
}

export function defaultParseSymbol(shape: string): string {
	return shape;
}
