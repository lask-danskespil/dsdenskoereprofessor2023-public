import * as fs from "fs";
import * as lodash from "lodash";
import type { ICroupierConfig } from "@gdk/backutils";

import * as config from "../commands/config";
import type * as convert from "../commands/convert";

export class ParseCroupierError extends Error {
	public constructor(message: string) {
		super(message);
		this.name = "ParseCroupierError";
	}
}

const NUMBER_PATTERN = /^\d+$/;

export function parse(
	filePath: string,
	parseSymbol: convert.ParseSymbol = defaultParseSymbol
): convert.IConvertSource {
	const content = fs.readFileSync(filePath, "utf8");

	let croupier: ICroupierConfig;
	try {
		croupier = JSON.parse(fs.readFileSync(filePath, "utf8")) as ICroupierConfig;
	} catch (error) {
		throw new ParseCroupierError(`${filePath} is not a valid JSON: ${error}`);
	}

	config.validate(croupier);

	const source: convert.IConvertSource = {};

	for (const rank of croupier.ranks) {
		const symbols: convert.IConvertSymbol[] = [];
		for (const ticket of rank.tickets ?? []) {
			symbols.push({
				shape: String(ticket.metadatas?.shape ?? rank.id),
				weight: ticket.quantity,
				symbol: parseSymbol(ticket.symbol),
				source: ticket.metadatas?.source ?? ticket.symbol,
			});
		}

		source[rank.id] = {
			value: rank.id,
			weight: lodash.sum(symbols.map(({ weight }) => weight)),
			symbols,
		};
	}

	return source;
}

export function defaultParseSymbol(symbol: string): string {
	return symbol;
}
