import { strict as assert } from "assert";
import * as fs from "fs";
import * as lodash from "lodash";
import { xml2json } from "xml-js";

import type { IConvertSource, IConvertSymbol, ParseSymbol } from "../commands/convert";

export class ParsePetfileError extends Error {
	public constructor(message: string) {
		super(message);
		this.name = "ParsePetfileError";
	}
}

export function parse(
	filePath: string,
	customParseSymbol: ParseSymbol = defaultParseSymbol
): IConvertSource {
	const symbols = fs
		.readFileSync(filePath, { encoding: "latin1" })
		.trim()
		.split("\n")
		.map((line) => parseLine(line, customParseSymbol));

	const source: IConvertSource = {};

	const symbolsByShape = lodash.groupBy(symbols, "shape");
	for (const shape in symbolsByShape) {
		if (!symbolsByShape.hasOwnProperty(shape)) {
			continue;
		}
		const rankSymbols = symbolsByShape[shape];
		const weight = lodash.sum(rankSymbols.map((symbol) => symbol.weight)) ?? 0;
		source[shape] = { value: Number(shape), weight, symbols: rankSymbols };
	}

	return source;
}

function parseLine(
	line: string,
	customParseSymbol: ParseSymbol = defaultParseSymbol
): IConvertSymbol {
	const parts = line.split(";");

	if (parts.length !== 3) {
		throw new ParsePetfileError(`Invalid line: ${line}`);
	}

	const shape = Number(parts[0]);
	const weight = Number(parts[1]);
	const source = parts[2].trim();
	const symbol = parseSymbol(source, customParseSymbol);

	if (isNaN(shape) || isNaN(weight)) {
		throw new ParsePetfileError(`Invalid line: ${line}`);
	}

	return { shape, symbol, weight, source };
}

export function parseSymbol(
	symbol: string,
	customParseSymbol: ParseSymbol = defaultParseSymbol
): string {
	try {
		return customParseSymbol(symbol);
	} catch (error) {
		throw new ParsePetfileError(error.message);
	}
}

export function defaultParseSymbol(source: string): string {
	const gameData = JSON.parse(xml2json(source, { compact: true })).gamedata;
	const boards = Array.isArray(gameData.boards.board)
		? gameData.boards.board.map((b) => b._text)
		: [gameData.boards.board._text];

	let prizeLocations;
	if (gameData["prize-locations"]) {
		const locations = gameData["prize-locations"]["prize-location"];
		prizeLocations = Array.isArray(locations)
			? locations.map((b: any) => b._text)
			: [locations?._text];
	}

	return [
		gameData?.valueBoards?._text,
		boards.join("-") + "|",
		(prizeLocations ?? []).join("-"),
		gameData?.bonusPrize?._text,
		gameData?.bonus?._text,
	]
		.filter((v) => v !== undefined && v.length > 0)
		.join("|")
		.replace(/\|\|+/g, "|");
}
