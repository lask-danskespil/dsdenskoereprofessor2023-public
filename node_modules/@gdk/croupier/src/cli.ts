import { strict as assert } from "assert";
import * as program from "commander";
import inquirer from "inquirer";
import * as fs from "fs-extra";
import * as path from "path";
import uuid from "uuid";
import * as lodash from "lodash";
import { ELevel } from "@gdk/core";
import { logger, watchProcess, ICroupierUsrInfos } from "@gdk/backutils";
import type { ICroupier, ICroupierConfig } from "@gdk/backutils";

import * as config from "./commands/config";
import { Generator, generateUsrSql } from "./commands/pool";
import { Converter, extractConvertSource } from "./commands/convert";
import { createReport } from "./commands/info";
import { executeTests } from "./commands/test";
import { CroupierImporter } from "./commands/import";
import { customize } from "./commands/customize";
import * as project from "./commands/project";
import { loadClass } from "./tools/loadClass";
import { CONVERT_CONFIGS } from "./lotteries";

const packagejson = fs.readJsonSync("./package.json");

const LOG_LEVEL_OPTION = new program.Option(
	"--logLevel <level>",
	`Log level to use for logger, default:info`
)
	.choices(
		(lodash.values(ELevel).filter((v) => typeof v === "string") as string[]).map((v) =>
			v.toLowerCase()
		)
	)
	.default("info");

const GAME_DIRECTORY_OPTION = new program.Option(
	"-d, --gameDirectory <value>",
	"Directory of the game to run, defaultly current directory."
).default(process.cwd());

const ALL_CROUPIERS_OPTION = new program.Option("--all", "check all croupiers configs").default(
	false
);

const VERBOSE_OPTION = new program.Option("-v", "raise script verbosity (to level: debug)")
	.default(false)
	.implies({ logLevel: "debug" });

const LOTTERY_CODE_OPTION = new program.Option(
	"-l, --lotteryCode <lottery>",
	"Lottery code for which the dealer will be generated"
).choices(Object.keys(CONVERT_CONFIGS).map((code) => code.toLowerCase()));

export function run(): void {
	getCli().parse(process.argv);
}

let cli: undefined | program.Command;

export function getCli(): program.Command {
	if (cli !== undefined) {
		return cli;
	}

	cli = new program.Command().version(packagejson.version).name("croupier");

	cli
		.command("test")
		.summary("run tests on dealer for given game(s)")
		.description(
			"for each game specified as argument, run mocha in tests located in test/$game/index.spec.ts"
		)
		.argument("[games...]", "game names from game package.json, separated by comma")
		.addOption(LOG_LEVEL_OPTION)
		.addOption(VERBOSE_OPTION)
		.addOption(GAME_DIRECTORY_OPTION)
		.addOption(ALL_CROUPIERS_OPTION)
		.option("-c, --color", "force color output")
		.action(croupierTest);

	cli
		.command("import")
		.summary("import configuration from an old dealer package")
		.description(
			"allow to import an old dealer to a gdk3 compatible dealer configuration with the already generated symbols"
		)
		.argument("{files...}", "game names from game package.json, separated by comma")
		.addOption(LOG_LEVEL_OPTION)
		.addOption(VERBOSE_OPTION)
		.action(croupierImport);

	cli
		.command("customize")
		.summary("import tickets into a new configuration from dealer json")
		.description("allow to create a dealer based on the symbols of an existing dealer (any format)")
		.argument("[file]", "json customization config")
		.option("-c, --croupier <croupier>", "rename croupier", undefined)
		.action(croupierCustomize);

	cli
		.command("generate")
		.summary("generate dealer for given games of conf files")
		.description("generate croupier json file for each game specified as argument")
		.argument(
			"[gameOrConfPathes...]",
			"either gameConf file pathes or game names from game package.json, separated by comma"
		)
		.addOption(LOG_LEVEL_OPTION)
		.addOption(VERBOSE_OPTION)
		.addOption(GAME_DIRECTORY_OPTION)
		.addOption(ALL_CROUPIERS_OPTION)
		.option("-g, --gameName <value>", "Game name the croupier will be generated for")
		.option("-o, --override", "generate with new seed", false)
		.action(croupierGenerate);

	cli
		.command("report")
		.summary("generate report for given games")
		.description("for each game specified as argument, produce a report file")
		.argument("[game]", "either gameConf file or game name from game package.json")
		.addOption(LOG_LEVEL_OPTION)
		.addOption(VERBOSE_OPTION)
		.addOption(GAME_DIRECTORY_OPTION)
		.option("-t, --test", "Run tests and include tests report")
		.action(croupierInfo);

	const configCommand = cli
		.command("config")
		.summary("output a configuration for given lottery")
		.description("output on stdout the json of a new configuration file")
		.version(packagejson.version)
		.addOption(LOG_LEVEL_OPTION)
		.addOption(VERBOSE_OPTION)
		.addOption(LOTTERY_CODE_OPTION)
		.option("-s, --sourceFile <sourceFile>", "source file path")
		.option("-m, --masterGameCode<masterGameCode>", "code used as config.masterGameCode")
		.option("-c, --code <code>", "code used as config.code (dealer variantCode)")
		.action(croupierInitConfig);

	configCommand
		.command("check")
		.summary("validate given configuration file(s)")
		.description(
			"validate a the given configuration file(s), exit with error code if error were found"
		)
		.argument("[gameOrConfPathes...]", "configuration path / game names from game package.json")
		.addOption(LOG_LEVEL_OPTION)
		.addOption(VERBOSE_OPTION)
		.addOption(GAME_DIRECTORY_OPTION)
		.addOption(ALL_CROUPIERS_OPTION)
		.action(croupierCheckConfig);

	cli
		.command("remove")
		.alias("rm")
		.summary("remove given dealers from current project")
		.description(
			"remove the specified dealer(s) from the project, including package.json registering, resources directories, test files. This command only prints a preview as long as the -f / --force option is not set."
		)
		.argument("[gameNames...]", "game names to remove")
		.option("-f, --force", "Force removal. Without this option, remove command only log.", false)
		.addOption(LOG_LEVEL_OPTION)
		.addOption(VERBOSE_OPTION)
		.addOption(GAME_DIRECTORY_OPTION)
		.addOption(ALL_CROUPIERS_OPTION)
		.action(actionWrapper(croupierRemove));

	cli
		.command("add")
		.summary("add a new dealer to current project")
		.description(
			"add a new dealer to the current project, including package.json registering, resources directories, test files. Try this command with -p / --pretend option to get a preview."
		)
		.argument("gameName", "game name to add")
		.addOption(LOG_LEVEL_OPTION)
		.addOption(VERBOSE_OPTION)
		.addOption(GAME_DIRECTORY_OPTION)
		.addOption(LOTTERY_CODE_OPTION)
		.option("-s, --sourceFile <sourceFile>", "source file path")
		.option("-m, --masterGameCode<masterGameCode>", "code used as config.masterGameCode")
		.option("-c, --code <code>", "code used as config.code (dealer variantCode)")
		.option("-p, --pretend", "do not alter files, just print a preview", false)
		.action(actionWrapper(project.add));

	return cli;
}

async function croupierTest(gamesToRun: string[], options: any): Promise<void> {
	logger.level = options.logLevel;
	watchProcess();

	const gamePackageJson = require(path.resolve(options.gameDirectory, "package.json"));
	const gameConfs = await getGameConfs(gamesToRun, gamePackageJson, options);
	const gameKeys = gameConfs.map(([game]) => game);

	executeTests(gameKeys, options.color);
}

async function croupierImport(archiveFiles: string[], options: any): Promise<void> {
	logger.level = options.logLevel;
	watchProcess();

	const gamePackageJson = fs.readJSONSync("package.json");
	const archives: string[] = [];

	for (const archive of archiveFiles) {
		if (fs.existsSync(archive)) {
			if (fs.lstatSync(archive).isDirectory()) {
				for (const f of fs.readdirSync(archive)) {
					if ([".tgz", ".zip", ".tar"].indexOf(path.extname(f)) !== -1) {
						archives.push(path.join(archive, f));
					}
				}
			} else {
				archives.push(archive);
			}
		}
	}

	for (const archive of archives) {
		logger.info(`importing : ${archive}`);
		const croupierImporter = new CroupierImporter();
		try {
			const croupierConf = await croupierImporter.import(archive);
			fs.ensureDirSync(`resources/${croupierConf.code}/`);
			fs.writeJSONSync(`resources/${croupierConf.code}/conf.json`, croupierConf, { spaces: 2 });

			gamePackageJson.games[croupierConf.code] = `resources/${croupierConf.code}/conf.json`;
			fs.writeJSONSync("package.json", gamePackageJson, { spaces: 2 });
		} catch (e) {
			logger.error(`can't import ${archive}`, e);
		}
	}
}

async function croupierCustomize(configFile: string, options: any): Promise<void> {
	logger.level = options.logLevel;
	watchProcess();

	const gamePackageJson = fs.readJSONSync("package.json");

	if (!configFile) {
		// @TODO launch graphical interface
	} else if (fs.existsSync(configFile)) {
		const conf = fs.readJsonSync(configFile);
		const croupierConf = await customize(conf);
		fs.ensureDirSync(`resources/${croupierConf.code}/`);
		fs.writeJSONSync(`resources/${croupierConf.code}/conf.json`, croupierConf, { spaces: 2 });
		gamePackageJson.games[croupierConf.code] = `resources/${croupierConf.code}/conf.json`;
		fs.writeJSONSync("package.json", gamePackageJson, { spaces: 2 });
	} else {
		throw new Error(`Can't find customization file : ${configFile}`);
	}
}

/**
 * Check configuration for games
 * @param gamesToRun
 * @param command
 */
async function croupierCheckConfig(gamesToRun: string[], options: any): Promise<void> {
	logger.level = options.logLevel;
	watchProcess();

	const gamePackageJson = require(path.resolve(options.gameDirectory, "package.json"));
	const gameConfs = await getGameConfs(gamesToRun, gamePackageJson, options);

	let success = true;

	for (const [gameName, confFile] of gameConfs) {
		const gameDescr = gameName !== "" ? " game " + gameName : "";
		logger.info(`validating${gameDescr} configuration file: ${confFile}`);

		let conf = fs.readJSONSync(confFile);
		const requirementsFile = path.join(
			path.dirname(confFile),
			"specifications",
			"requirements.json"
		);

		if (fs.existsSync(requirementsFile)) {
			conf = config.mergeWithRequirements(conf, fs.readJSONSync(requirementsFile));
		}

		try {
			config.validate(conf);
		} catch (error) {
			success = false;
			logger.error(error.toString());
			continue;
		}

		logger.info(`success`);
	}

	process.exit(success ? 0 : 1);
}

async function croupierRemove(gameNames: string[], options: project.IRemoveOptions): Promise<void> {
	const gamePackageJson = require(path.resolve(options.gameDirectory, "package.json"));
	gameNames = (await getGameConfs(gameNames, gamePackageJson, options)).map(
		([gameName]) => gameName
	);

	return project.remove(gameNames, options);
}

async function croupierGenerate(gamesToRun: string[], options: any): Promise<void> {
	logger.level = options.logLevel;
	watchProcess();

	const gamePackageJson = require(path.resolve(options.gameDirectory, "package.json"));
	const gameConfs = await getGameConfs(gamesToRun, gamePackageJson, options);

	for (const [game, confFile] of gameConfs) {
		const croupier = croupierGenerateForConfig(confFile, packagejson, {
			override: options.override,
		});

		logger.info("Creating xls Report");
		const xlsReport = await createReport(croupier);
		logger.info("xls Report created");
		fs.ensureDirSync(`out/${game}`);
		fs.writeJSONSync(`out/${game}/croupier.json`, croupier, { spaces: 4 });

		xlsReport.xlsx.writeFile(`out/${game}/report.xlsx`);
		logger.info("Done !");
	}
}

function croupierInitConfig(options: any): void {
	logger.level = options.logLevel;
	watchProcess();

	if (options.lotteryCode !== undefined) {
		options.lotteryCode = options.lotteryCode.toUpperCase();
	}

	const conf = config.init(options);

	console.log(JSON.stringify(conf, null, 2));
}

export type CommanderAction = (...args: any[]) => any;

function actionWrapper(action: CommanderAction): CommanderAction {
	return (...args: any[]): void => {
		watchProcess();
		const options = args[args.length - 2];
		if (options instanceof Object && "logLevel" in options) {
			logger.level = options.logLevel;
		}

		action(...args);
	};
}

/**
 * Extract game name and game configuration path (as tuples) from the package.json file,
 * accordingly to options passed to the given command.
 *
 * @param gamesToRun: list of game names, if any (empty list is none)
 * @param command: the commanderjs command
 * @param packageJson: object built from the decoded package.json file.
 * @returns: list of tuples [gameName, gameConfPath] filtered by command options
 */
async function getGameConfs(
	gameNames: string[],
	packageJson: { games?: { [name: string]: string } },
	options: { all?: boolean; gameName?: string; prompt?: string }
): Promise<Array<[string, string]>> {
	const games = packageJson.games;
	assert(
		Object.keys(games ?? {}).length > 0,
		`Couldn't find any game registered in package.json.` +
			`Is object "games" defined in package.json ?`
	);

	const actualGameNames = Object.keys(games);
	assert(
		!(options.all && options.gameName),
		`you cannot mix option "--all" with option "gameName"`
	);

	if (gameNames.length === 0) {
		if (options.all) {
			gameNames = actualGameNames;
		} else if (options.gameName) {
			gameNames = [options.gameName];
		} else if (actualGameNames.length === 1) {
			gameNames = [actualGameNames[0]];
		} else {
			gameNames = [
				(
					await inquirer.prompt([
						{
							name: "question",
							message: options.prompt ?? "Please select a dealer: ",
							type: "list",
							choices: actualGameNames.map((key) => {
								return {
									value: key,
									name: key,
								};
							}),
						},
					])
				).question,
			];
		}
	}

	const unknownGames: string[] = [];
	const gameConfs: Array<[string, string]> = [];

	for (const gameName of gameNames) {
		if (gameName in games) {
			gameConfs.push([gameName, games[gameName]]);
		} else if (fs.existsSync(gameName)) {
			const _gameName = Object.keys(games).find((name) => games[name] === gameName) ?? "";
			gameConfs.push([_gameName, gameName]);
		} else {
			unknownGames.push(gameName);
		}
	}

	assert(
		unknownGames.length === 0,
		`Invalid game names: ${JSON.stringify(unknownGames)}.` +
			` Possible game names: [${JSON.stringify(Object.keys(games))}]`
	);

	return gameConfs;
}

export function croupierGenerateForConfig(
	confFile: string,
	context: { name: string; version: string },
	options?: { override: boolean }
): ICroupier {
	let conf: ICroupierConfig = fs.readJSONSync(confFile);
	const requirementsFile = path.join(path.dirname(confFile), "specifications", "requirements.json");
	logger.info(`generating : ${context.name} (${conf.code})`);

	if (fs.existsSync(requirementsFile)) {
		conf = config.mergeWithRequirements(conf, fs.readJSONSync(requirementsFile));
	}

	const confDirectory = path.resolve(path.dirname(confFile));

	let generator;

	// set the seed if not set yet or asked to override it
	if (!conf.seed || options?.override) {
		logger.info(`set seed in config file: ${confFile}`);
		conf.seed = uuid.v4();
		fs.writeJsonSync(confFile, conf, { spaces: 2 });
	}

	if (conf.sourceFile !== undefined) {
		const convertSource = extractConvertSource({
			currentPath: path.dirname(confFile),
			filePath: conf.sourceFile,
			symbolClassPath: conf.symbolClass,
		});
		logger.info(`from source: ${conf.sourceFile}`);
		generator = new Converter(conf, convertSource, context);
	} else {
		let symbolClass: any;
		if (conf.symbolClass !== undefined) {
			const symbolClassPath =
				conf.symbolClass.substr(0, 2) === "./"
					? path.resolve(path.dirname(confFile), conf.symbolClass)
					: path.resolve(conf.symbolClass);
			symbolClass = loadClass<any>(symbolClassPath);
		}

		generator = new Generator(conf, context, symbolClass);
	}

	return generator.run();
}

async function croupierInfo(gameToRun: string, command: program.Command): Promise<void> {
	// necessary ?
	return Promise.resolve();
}

if (require.main === module) {
	run();
}
