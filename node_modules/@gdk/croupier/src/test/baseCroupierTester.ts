import { IRank, logger } from "@gdk/backutils";
import { strict as assert } from "assert";
import * as fs from "fs-extra";
import * as path from "path";
import * as lodash from "lodash";

import { proof } from "../tools/testHelpers";

import type { ICroupierConfig, ITicket, IWinFactor } from "@gdk/backutils";

const MAX_SYMBOL_LENGTH = 2048;

export abstract class ABaseCroupierTester {
	protected readonly croupier: ICroupierConfig;
	protected readonly tickets: ITicket[];

	protected constructor(serviceName: string) {
		logger.level = global.gdkLogLevel;
		this.croupier = fs.readJsonSync(path.join("out", serviceName, "croupier.json"));
		this.tickets = lodash.flatten(this.croupier.ranks.map((rank) => rank.tickets));
	}

	// play a ticket to determinate his shape
	protected abstract symbolToShape(symbol: string): string;

	// play a ticket to determinate his win factor
	protected abstract symbolToFactor(symbol: string): IWinFactor;

	/**
	 * Run ticket tests
	 */
	public test(): void {
		describe("Global ticket properties", () => {
			it("should contains tickets with unique ids", () => {
				const ids = this.tickets.map((ticket) => ticket.id);
				for (const id of ids) {
					if (ids.indexOf(id) !== ids.lastIndexOf(id)) {
						assert.fail(`There are more than one ticket with id: ${id}.`);
					}
				}
			});
		});

		describe(`Global ranks properties`, () => {
			it("should contains ranks with unique ids", () => {
				const ids = this.croupier.ranks.map((rank) => rank.id);
				for (const id of ids) {
					if (ids.indexOf(id) !== ids.lastIndexOf(id)) {
						assert.fail(`There are more than one rank with id: ${id}.`);
					}
				}
			});
		});

		it(`symbol lengths <= ${MAX_SYMBOL_LENGTH} characters`, () => {
			for (const ticket of this.tickets) {
				ABaseCroupierTester.testSymbolLength(ticket.symbol);
			}
		});

		this.testSymbolShapes();
		this.testSymbolFactors();
	}

	protected testSymbolShapes(): void {
		it("tickets symbols comply with config shapes", () => {
			for (const ticket of this.tickets) {
				const shape = this.symbolToShape(ticket.symbol);
				assert.equal(
					shape,
					ticket.metadatas.shape,
					`ticket's symbol shape: "${shape}" differs with its conf:` + ` ${JSON.stringify(ticket)}`
				);
			}
		});
	}

	protected testSymbolFactors(): void {
		describe(`Ticket factors computed on symbol match rank factor`, () => {
			for (const rank of this.croupier.ranks) {
				const { numerator, denominator } = rank.factor;
				it(`Rank ${rank.id}: ${numerator} / ${denominator}`, () => {
					for (const ticket of rank.tickets ?? []) {
						const factor = this.symbolToFactor(ticket.symbol);
						assert.equal(
							factor.numerator / factor.denominator,
							numerator / denominator,
							`invalid ticket: ${JSON.stringify(ticket)}`
						);
					}
				});
			}
		});
	}

	@proof("empty symbol", /bad symbol length/, "")
	@proof("long symbol", /bad symbol length/, " ".repeat(MAX_SYMBOL_LENGTH + 1))
	protected static testSymbolLength(symbol: string): void {
		assert(
			symbol.length > 0 && symbol.length < MAX_SYMBOL_LENGTH,
			`bad symbol length (should be in [1; ${MAX_SYMBOL_LENGTH}]): "${symbol}"`
		);
	}
}
