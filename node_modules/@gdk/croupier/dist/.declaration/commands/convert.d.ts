import type { ICroupier, ICroupierConfig, IRankConfig, IRank, ITicket } from "@gdk/backutils";
import * as lotteries from "../lotteries";
export interface IConvertSource {
    [id: string]: IConvertRank;
}
export interface IConvertRank {
    value: number;
    weight: number;
    symbols: IConvertSymbol[];
}
export interface IConvertSymbol {
    shape: number | string;
    weight: number;
    source: string;
    symbol: string;
}
export type ParseSymbol = (shape: string) => string;
export interface ISymbolClass {
    constructor(seed: string): any;
    toString(): string;
}
export declare function extractConvertSource(params: {
    currentPath: string;
    filePath: string;
    symbolClassPath?: string;
}): IConvertSource;
export declare class Converter {
    protected config: ICroupierConfig;
    protected source: IConvertSource;
    protected version: string;
    protected name: string;
    protected lotteryConf: lotteries.IConvertConfig;
    protected lotteryCode: string;
    constructor(config: ICroupierConfig, source: IConvertSource, context: {
        name: string;
        version: string;
    });
    protected validateConfig(config: any): void;
    protected validateConfigQuantities(config: ICroupierConfig): void;
    protected autosetDbRecordQuantities(config: any): Array<{
        rank: string;
        shape: string;
        dbQuantity: number;
        availableSymbols: number;
    }>;
    protected get isDepleting(): boolean;
    protected computeRenewal(): number;
    /**
     * Run source convertion into a dealer
     */
    run(): ICroupier;
    protected extractRanks(): IRank[];
    protected extractRankTickets(rankConfig: IRankConfig): ITicket[];
    /**
     * Adjust rank quantities to use every symbol of source.
     * WARNING: generally raises the quantity of tickets in ranks. Do not use in a depleting
     * dealer !
     */
    protected adjustRankQuantities(ranks: IRankConfig[]): void;
}
