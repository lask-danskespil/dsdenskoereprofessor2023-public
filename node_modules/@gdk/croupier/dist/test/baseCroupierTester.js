"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ABaseCroupierTester = void 0;
const backutils_1 = require("@gdk/backutils");
const assert_1 = require("assert");
const fs = __importStar(require("fs-extra"));
const path = __importStar(require("path"));
const lodash = __importStar(require("lodash"));
const testHelpers_1 = require("../tools/testHelpers");
const MAX_SYMBOL_LENGTH = 2048;
class ABaseCroupierTester {
    constructor(serviceName) {
        backutils_1.logger.level = global.gdkLogLevel;
        this.croupier = fs.readJsonSync(path.join("out", serviceName, "croupier.json"));
        this.tickets = lodash.flatten(this.croupier.ranks.map((rank) => rank.tickets));
    }
    /**
     * Run ticket tests
     */
    test() {
        describe("Global ticket properties", () => {
            it("should contains tickets with unique ids", () => {
                const ids = this.tickets.map((ticket) => ticket.id);
                for (const id of ids) {
                    if (ids.indexOf(id) !== ids.lastIndexOf(id)) {
                        assert_1.strict.fail(`There are more than one ticket with id: ${id}.`);
                    }
                }
            });
        });
        describe(`Global ranks properties`, () => {
            it("should contains ranks with unique ids", () => {
                const ids = this.croupier.ranks.map((rank) => rank.id);
                for (const id of ids) {
                    if (ids.indexOf(id) !== ids.lastIndexOf(id)) {
                        assert_1.strict.fail(`There are more than one rank with id: ${id}.`);
                    }
                }
            });
        });
        it(`symbol lengths <= ${MAX_SYMBOL_LENGTH} characters`, () => {
            for (const ticket of this.tickets) {
                ABaseCroupierTester.testSymbolLength(ticket.symbol);
            }
        });
        this.testSymbolShapes();
        this.testSymbolFactors();
    }
    testSymbolShapes() {
        it("tickets symbols comply with config shapes", () => {
            for (const ticket of this.tickets) {
                const shape = this.symbolToShape(ticket.symbol);
                assert_1.strict.equal(shape, ticket.metadatas.shape, `ticket's symbol shape: "${shape}" differs with its conf:` + ` ${JSON.stringify(ticket)}`);
            }
        });
    }
    testSymbolFactors() {
        describe(`Ticket factors computed on symbol match rank factor`, () => {
            for (const rank of this.croupier.ranks) {
                const { numerator, denominator } = rank.factor;
                it(`Rank ${rank.id}: ${numerator} / ${denominator}`, () => {
                    var _a;
                    for (const ticket of (_a = rank.tickets) !== null && _a !== void 0 ? _a : []) {
                        const factor = this.symbolToFactor(ticket.symbol);
                        assert_1.strict.equal(factor.numerator / factor.denominator, numerator / denominator, `invalid ticket: ${JSON.stringify(ticket)}`);
                    }
                });
            }
        });
    }
    static testSymbolLength(symbol) {
        (0, assert_1.strict)(symbol.length > 0 && symbol.length < MAX_SYMBOL_LENGTH, `bad symbol length (should be in [1; ${MAX_SYMBOL_LENGTH}]): "${symbol}"`);
    }
}
__decorate([
    (0, testHelpers_1.proof)("empty symbol", /bad symbol length/, ""),
    (0, testHelpers_1.proof)("long symbol", /bad symbol length/, " ".repeat(MAX_SYMBOL_LENGTH + 1))
], ABaseCroupierTester, "testSymbolLength", null);
exports.ABaseCroupierTester = ABaseCroupierTester;
//# sourceMappingURL=baseCroupierTester.js.map