"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.assert = exports.describe = exports.compute = void 0;
const assert_1 = require("assert");
const lodash = __importStar(require("lodash"));
const backutils_1 = require("@gdk/backutils");
function clone(value) {
    return JSON.parse(JSON.stringify(value));
}
/**
 * Compute frequencies from a list of scenarios.
 *
 * @param scenarios: list of weighted values (number or string). Same values can appear twice in
 * the list, their weights will be added
 * @returns a hash with value as keys, and frequencies (percent) as value
 *
 * You can add other keys / values than "v" and "q" in the scenarios. If you do, the first scenario to
 * be registered for a given value withh be kept as a sample, displayed by the describe function of this
 * module.
 *
 *
 * example: getFrequencies([
 *    { v: "scenario 1", q: 10, symbol: "ABBSSC|"},
 *    { v: "scenario 2", q: 10 },
 *    { v: "scenario 2", q: 5, symbol: "AABBSH|0,1,5" }
 *  ]);
 *
 * will return  { "scenario 1": 40,
 *                "scenario 2": 60,
 *                samples: { "scenario 1": { symbol: "ABBSSC|" },
 *                            scenario 2": { symbol: "AABBSH|0,1,5" } }}
 */
function compute(scenarios) {
    var _a;
    let total = 0;
    const freqs = { samples: {} };
    for (const scenario of scenarios) {
        total += scenario.q;
        // can this scenario be used as a sample ?
        if (freqs.samples[scenario.v] === undefined && Object.keys(scenario).length > 2) {
            const sample = lodash.pickBy(clone(scenario), (v, key) => key !== "v" && key !== "q");
            freqs.samples[scenario.v] = sample;
        }
        freqs[scenario.v] = ((_a = freqs[scenario.v]) !== null && _a !== void 0 ? _a : 0) + scenario.q;
    }
    for (const v in freqs) {
        if (!freqs.hasOwnProperty(v) || v === "samples") {
            continue;
        }
        freqs[v] = (100 * freqs[v]) / total;
    }
    return freqs;
}
exports.compute = compute;
/**
 * Return a string representing the given frequencies.
 *
 * @param freqs: a frequency object (key are scenarios, values are pecents)
 * @param padLeft: number of spaces used to pad the list of frequencies
 * @returns string representing the given frequencies
 */
function describe(freqs, padLeft = 0) {
    var _a, _b;
    const scenarios = lodash.without(Object.keys(freqs), "samples");
    const scenarioLength = (_a = lodash.max(scenarios.map((s) => s.length))) !== null && _a !== void 0 ? _a : 0;
    const indent = " ".repeat(padLeft);
    const lines = [];
    for (const scenario of scenarios) {
        let example = "";
        const sample = (_b = freqs === null || freqs === void 0 ? void 0 : freqs.samples) === null || _b === void 0 ? void 0 : _b[scenario];
        if (sample !== undefined) {
            let sampleString = sample !== undefined ? JSON.stringify(sample) : "";
            if (sampleString.length > 100) {
                sampleString = sampleString.substr(0, 97) + "...";
            }
            example = `  (ex.: ${sampleString})`;
        }
        const percents = freqs[scenario].toFixed(2).padStart(5);
        lines.push(`${indent}* ${scenario.padEnd(scenarioLength)}:   ${percents.padStart(4)} % ${example}`);
    }
    return lines.join("\n");
}
exports.describe = describe;
/**
 * Makes an assertion on frequency equality.
 *
 * @param actual: actual frequencies
 * @param exp: expected frequencies
 * @param tolerance: frequency gap (in percent) allowed between actual / expected (below / over).
 *     for exemple, tolerance = 1.5 means for an expected 50% frequency, 48.5 is an acceptable
 *     value, so is 51.5, while 52% is not.
 * @returns string representing the given frequencies
 */
function assert(actual, exp, tolerance = 1.5) {
    backutils_1.logger.debug(`compares actual frequencies: \n${describe(actual, 8)}
    with expected: \n${describe(exp, 8)}`);
    const actualScenarios = lodash.without(Object.keys(actual), "samples");
    actualScenarios.sort();
    const expScenarios = lodash.without(Object.keys(exp), "samples");
    expScenarios.sort();
    (0, assert_1.deepStrictEqual)(actualScenarios, expScenarios, `combinations differ in actual frequencies and in expected frequencies`);
    const wrongScenarios = actualScenarios.filter((scenario) => Math.abs(actual[scenario] - exp[scenario]) > tolerance);
    (0, assert_1.deepStrictEqual)(lodash.pick(actual, wrongScenarios), lodash.pick(exp, wrongScenarios), `expected and actual frequencies differs too much (> ${tolerance}%)`);
}
exports.assert = assert;
//# sourceMappingURL=frequencies.js.map