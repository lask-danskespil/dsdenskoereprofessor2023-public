"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Universe = exports.WeightedValue = exports.EUniverseType = void 0;
const lodash = __importStar(require("lodash"));
const seedLodash_1 = require("./seedLodash");
var EUniverseType;
(function (EUniverseType) {
    EUniverseType["range"] = "range";
    EUniverseType["weight"] = "weight";
})(EUniverseType = exports.EUniverseType || (exports.EUniverseType = {}));
const defaultLabel = "___";
class WeightedValue {
    constructor(e) {
        this._labels = {};
        this._value = e.value;
        this._labels[defaultLabel] = this._weight = seedLodash_1.SeedLodash.instance.isUndefined(e.weight)
            ? 1
            : e.weight;
    }
    get value() {
        return this._value;
    }
    get weight() {
        return this._weight;
    }
    set weight(w) {
        this._weight = w;
    }
    /**
     * add some weight to an element
     * @param quantity weight to add to the element
     */
    add(quantity) {
        this._weight += quantity;
    }
    /**
     * remove some weight to an element
     * @param quantity weight to remove
     */
    remove(quantity) {
        this._weight -= Math.min(quantity, this._weight);
    }
    /**
     * Freeze the
     */
    save(name) {
        this._labels[name || defaultLabel] = this._weight;
    }
    /**
     * Reset
     */
    restore(name) {
        this._weight = this._labels[name || defaultLabel];
    }
}
exports.WeightedValue = WeightedValue;
class Universe {
    constructor(...params) {
        var _a;
        this.autoRefill = false;
        this.values = [];
        this._totalWeight = 0;
        let options;
        if ((params.length === 1 || params.length === 2) && Array.isArray(params[0])) {
            for (const e of params[0]) {
                this._add(new WeightedValue(e));
            }
            options = params[1];
        }
        else if (params.length > 1 && lodash.isNumber(params[0]) && lodash.isNumber(params[1])) {
            const step = params.length > 2 && lodash.isNumber(params[2]) ? params[2] : 1;
            for (let i = params[0]; i <= params[1]; i += step) {
                this._add(new WeightedValue({ value: i }));
            }
            if (params[params.length - 1] instanceof Object) {
                options = params[params.length - 1];
            }
        }
        this.autoRefill = (_a = options === null || options === void 0 ? void 0 : options.autoRefill) !== null && _a !== void 0 ? _a : false;
        this.save();
    }
    /**
     * Returns the size of an universe (number of elements including weights)
     */
    size() {
        return seedLodash_1.SeedLodash.instance.sum(this.values.map((e) => e.weight));
    }
    /**
     * Checks if a specific element is in the unverse
     */
    has(value) {
        return this.count(value) > 0;
    }
    /**
     *  Returns the number occurrences of a specific element in a universe
     */
    count(value) {
        return seedLodash_1.SeedLodash.instance.sum(this.values.filter((e) => e.value === value).map((e) => e.weight));
    }
    /**
     * add some element to the universe
     * @param value IWeightedValue
     */
    addValue(value, count) {
        this._add(new WeightedValue({ value, weight: count || 1 }));
    }
    /**
     * remove some element to the universe
     * @param value IWeightedValue
     */
    removeValue(value, count) {
        this._remove(value, count);
    }
    /**
     * Pick one element in the universe, won't affect the universe itself as element will be replaced in it
     */
    sampleOne() {
        let index = this._randIndex();
        for (const value of this.values) {
            index -= value.weight;
            if (index < 0) {
                return value.value;
            }
        }
        // unreachable code
        throw {
            message: `wrong index when getting an element from an universe, Should never occurs`,
            code: 500,
        };
    }
    /**
     * Pick several element in the universe, won't affect the universe itself as elements will be replaced in it
     * @param count number of element to draw
     */
    sampleMany(count) {
        const res = [];
        for (let i = 0; i < count; i++) {
            res.push(this.sampleOne());
        }
        return res;
    }
    /**
     * Draw one element from the universe, the element will be removed from the universe
     */
    drawOne() {
        let index = this._randIndex();
        for (const value of this.values) {
            index -= value.weight;
            if (index < 0) {
                value.weight -= 1;
                this._totalWeight -= 1;
                // auto refill if empty
                if (this.autoRefill && this._totalWeight === 0) {
                    this.restore();
                }
                return value.value;
            }
        }
        // unreachable code
        throw {
            message: `wrong index when getting an element from an universe, Should never occurs`,
            code: 500,
        };
    }
    /**
     * Draw many elements from the universe, the elements will be removed from the universe
     * @param count
     */
    drawMany(count) {
        const res = [];
        for (let i = 0; i < count; i++) {
            res.push(this.drawOne());
        }
        return res;
    }
    /**
     * Reset the universe to his original state
     */
    save(name) {
        for (const e of this.values) {
            e.save(name);
        }
    }
    /**
     * Reset the universe to his original state
     */
    restore(name) {
        this._totalWeight = 0;
        for (const e of this.values) {
            e.restore(name);
            this._totalWeight += e.weight;
        }
    }
    _add(v) {
        const existingValue = this.values.find((e) => e.value === v.value);
        if (!existingValue) {
            this.values.push(new WeightedValue(v));
        }
        else {
            existingValue.add(v.weight);
        }
        this._totalWeight += v.weight;
    }
    _remove(value, count) {
        if (seedLodash_1.SeedLodash.instance.isUndefined(count)) {
            for (const v of this.values) {
                if (v.value === value) {
                    this._totalWeight -= v.weight;
                    v.weight = 0;
                }
            }
        }
        else {
            for (const v of this.values) {
                if (v.value === value && count > 0) {
                    this._totalWeight -= Math.min(count, v.weight);
                    v.weight -= Math.min(count, v.weight);
                }
            }
        }
    }
    _randIndex() {
        return seedLodash_1.SeedLodash.instance.random(this._totalWeight - 1);
    }
}
exports.Universe = Universe;
//# sourceMappingURL=universe.js.map