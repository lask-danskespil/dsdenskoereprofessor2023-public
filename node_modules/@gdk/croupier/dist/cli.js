"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.croupierGenerateForConfig = exports.getCli = exports.run = void 0;
const assert_1 = require("assert");
const program = __importStar(require("commander"));
const inquirer_1 = __importDefault(require("inquirer"));
const fs = __importStar(require("fs-extra"));
const path = __importStar(require("path"));
const uuid_1 = __importDefault(require("uuid"));
const lodash = __importStar(require("lodash"));
const core_1 = require("@gdk/core");
const backutils_1 = require("@gdk/backutils");
const config = __importStar(require("./commands/config"));
const pool_1 = require("./commands/pool");
const convert_1 = require("./commands/convert");
const info_1 = require("./commands/info");
const test_1 = require("./commands/test");
const import_1 = require("./commands/import");
const customize_1 = require("./commands/customize");
const project = __importStar(require("./commands/project"));
const loadClass_1 = require("./tools/loadClass");
const lotteries_1 = require("./lotteries");
const packagejson = fs.readJsonSync("./package.json");
const LOG_LEVEL_OPTION = new program.Option("--logLevel <level>", `Log level to use for logger, default:info`)
    .choices(lodash.values(core_1.ELevel).filter((v) => typeof v === "string").map((v) => v.toLowerCase()))
    .default("info");
const GAME_DIRECTORY_OPTION = new program.Option("-d, --gameDirectory <value>", "Directory of the game to run, defaultly current directory.").default(process.cwd());
const ALL_CROUPIERS_OPTION = new program.Option("--all", "check all croupiers configs").default(false);
const VERBOSE_OPTION = new program.Option("-v", "raise script verbosity (to level: debug)")
    .default(false)
    .implies({ logLevel: "debug" });
const LOTTERY_CODE_OPTION = new program.Option("-l, --lotteryCode <lottery>", "Lottery code for which the dealer will be generated").choices(Object.keys(lotteries_1.CONVERT_CONFIGS).map((code) => code.toLowerCase()));
function run() {
    getCli().parse(process.argv);
}
exports.run = run;
let cli;
function getCli() {
    if (cli !== undefined) {
        return cli;
    }
    cli = new program.Command().version(packagejson.version).name("croupier");
    cli
        .command("test")
        .summary("run tests on dealer for given game(s)")
        .description("for each game specified as argument, run mocha in tests located in test/$game/index.spec.ts")
        .argument("[games...]", "game names from game package.json, separated by comma")
        .addOption(LOG_LEVEL_OPTION)
        .addOption(VERBOSE_OPTION)
        .addOption(GAME_DIRECTORY_OPTION)
        .addOption(ALL_CROUPIERS_OPTION)
        .option("-c, --color", "force color output")
        .action(croupierTest);
    cli
        .command("import")
        .summary("import configuration from an old dealer package")
        .description("allow to import an old dealer to a gdk3 compatible dealer configuration with the already generated symbols")
        .argument("{files...}", "game names from game package.json, separated by comma")
        .addOption(LOG_LEVEL_OPTION)
        .addOption(VERBOSE_OPTION)
        .action(croupierImport);
    cli
        .command("customize")
        .summary("import tickets into a new configuration from dealer json")
        .description("allow to create a dealer based on the symbols of an existing dealer (any format)")
        .argument("[file]", "json customization config")
        .option("-c, --croupier <croupier>", "rename croupier", undefined)
        .action(croupierCustomize);
    cli
        .command("generate")
        .summary("generate dealer for given games of conf files")
        .description("generate croupier json file for each game specified as argument")
        .argument("[gameOrConfPathes...]", "either gameConf file pathes or game names from game package.json, separated by comma")
        .addOption(LOG_LEVEL_OPTION)
        .addOption(VERBOSE_OPTION)
        .addOption(GAME_DIRECTORY_OPTION)
        .addOption(ALL_CROUPIERS_OPTION)
        .option("-g, --gameName <value>", "Game name the croupier will be generated for")
        .option("-o, --override", "generate with new seed", false)
        .action(croupierGenerate);
    cli
        .command("report")
        .summary("generate report for given games")
        .description("for each game specified as argument, produce a report file")
        .argument("[game]", "either gameConf file or game name from game package.json")
        .addOption(LOG_LEVEL_OPTION)
        .addOption(VERBOSE_OPTION)
        .addOption(GAME_DIRECTORY_OPTION)
        .option("-t, --test", "Run tests and include tests report")
        .action(croupierInfo);
    const configCommand = cli
        .command("config")
        .summary("output a configuration for given lottery")
        .description("output on stdout the json of a new configuration file")
        .version(packagejson.version)
        .addOption(LOG_LEVEL_OPTION)
        .addOption(VERBOSE_OPTION)
        .addOption(LOTTERY_CODE_OPTION)
        .option("-s, --sourceFile <sourceFile>", "source file path")
        .option("-m, --masterGameCode<masterGameCode>", "code used as config.masterGameCode")
        .option("-c, --code <code>", "code used as config.code (dealer variantCode)")
        .action(croupierInitConfig);
    configCommand
        .command("check")
        .summary("validate given configuration file(s)")
        .description("validate a the given configuration file(s), exit with error code if error were found")
        .argument("[gameOrConfPathes...]", "configuration path / game names from game package.json")
        .addOption(LOG_LEVEL_OPTION)
        .addOption(VERBOSE_OPTION)
        .addOption(GAME_DIRECTORY_OPTION)
        .addOption(ALL_CROUPIERS_OPTION)
        .action(croupierCheckConfig);
    cli
        .command("remove")
        .alias("rm")
        .summary("remove given dealers from current project")
        .description("remove the specified dealer(s) from the project, including package.json registering, resources directories, test files. This command only prints a preview as long as the -f / --force option is not set.")
        .argument("[gameNames...]", "game names to remove")
        .option("-f, --force", "Force removal. Without this option, remove command only log.", false)
        .addOption(LOG_LEVEL_OPTION)
        .addOption(VERBOSE_OPTION)
        .addOption(GAME_DIRECTORY_OPTION)
        .addOption(ALL_CROUPIERS_OPTION)
        .action(actionWrapper(croupierRemove));
    cli
        .command("add")
        .summary("add a new dealer to current project")
        .description("add a new dealer to the current project, including package.json registering, resources directories, test files. Try this command with -p / --pretend option to get a preview.")
        .argument("gameName", "game name to add")
        .addOption(LOG_LEVEL_OPTION)
        .addOption(VERBOSE_OPTION)
        .addOption(GAME_DIRECTORY_OPTION)
        .addOption(LOTTERY_CODE_OPTION)
        .option("-s, --sourceFile <sourceFile>", "source file path")
        .option("-m, --masterGameCode<masterGameCode>", "code used as config.masterGameCode")
        .option("-c, --code <code>", "code used as config.code (dealer variantCode)")
        .option("-p, --pretend", "do not alter files, just print a preview", false)
        .action(actionWrapper(project.add));
    return cli;
}
exports.getCli = getCli;
async function croupierTest(gamesToRun, options) {
    backutils_1.logger.level = options.logLevel;
    (0, backutils_1.watchProcess)();
    const gamePackageJson = require(path.resolve(options.gameDirectory, "package.json"));
    const gameConfs = await getGameConfs(gamesToRun, gamePackageJson, options);
    const gameKeys = gameConfs.map(([game]) => game);
    (0, test_1.executeTests)(gameKeys, options.color);
}
async function croupierImport(archiveFiles, options) {
    backutils_1.logger.level = options.logLevel;
    (0, backutils_1.watchProcess)();
    const gamePackageJson = fs.readJSONSync("package.json");
    const archives = [];
    for (const archive of archiveFiles) {
        if (fs.existsSync(archive)) {
            if (fs.lstatSync(archive).isDirectory()) {
                for (const f of fs.readdirSync(archive)) {
                    if ([".tgz", ".zip", ".tar"].indexOf(path.extname(f)) !== -1) {
                        archives.push(path.join(archive, f));
                    }
                }
            }
            else {
                archives.push(archive);
            }
        }
    }
    for (const archive of archives) {
        backutils_1.logger.info(`importing : ${archive}`);
        const croupierImporter = new import_1.CroupierImporter();
        try {
            const croupierConf = await croupierImporter.import(archive);
            fs.ensureDirSync(`resources/${croupierConf.code}/`);
            fs.writeJSONSync(`resources/${croupierConf.code}/conf.json`, croupierConf, { spaces: 2 });
            gamePackageJson.games[croupierConf.code] = `resources/${croupierConf.code}/conf.json`;
            fs.writeJSONSync("package.json", gamePackageJson, { spaces: 2 });
        }
        catch (e) {
            backutils_1.logger.error(`can't import ${archive}`, e);
        }
    }
}
async function croupierCustomize(configFile, options) {
    backutils_1.logger.level = options.logLevel;
    (0, backutils_1.watchProcess)();
    const gamePackageJson = fs.readJSONSync("package.json");
    if (!configFile) {
        // @TODO launch graphical interface
    }
    else if (fs.existsSync(configFile)) {
        const conf = fs.readJsonSync(configFile);
        const croupierConf = await (0, customize_1.customize)(conf);
        fs.ensureDirSync(`resources/${croupierConf.code}/`);
        fs.writeJSONSync(`resources/${croupierConf.code}/conf.json`, croupierConf, { spaces: 2 });
        gamePackageJson.games[croupierConf.code] = `resources/${croupierConf.code}/conf.json`;
        fs.writeJSONSync("package.json", gamePackageJson, { spaces: 2 });
    }
    else {
        throw new Error(`Can't find customization file : ${configFile}`);
    }
}
/**
 * Check configuration for games
 * @param gamesToRun
 * @param command
 */
async function croupierCheckConfig(gamesToRun, options) {
    backutils_1.logger.level = options.logLevel;
    (0, backutils_1.watchProcess)();
    const gamePackageJson = require(path.resolve(options.gameDirectory, "package.json"));
    const gameConfs = await getGameConfs(gamesToRun, gamePackageJson, options);
    let success = true;
    for (const [gameName, confFile] of gameConfs) {
        const gameDescr = gameName !== "" ? " game " + gameName : "";
        backutils_1.logger.info(`validating${gameDescr} configuration file: ${confFile}`);
        let conf = fs.readJSONSync(confFile);
        const requirementsFile = path.join(path.dirname(confFile), "specifications", "requirements.json");
        if (fs.existsSync(requirementsFile)) {
            conf = config.mergeWithRequirements(conf, fs.readJSONSync(requirementsFile));
        }
        try {
            config.validate(conf);
        }
        catch (error) {
            success = false;
            backutils_1.logger.error(error.toString());
            continue;
        }
        backutils_1.logger.info(`success`);
    }
    process.exit(success ? 0 : 1);
}
async function croupierRemove(gameNames, options) {
    const gamePackageJson = require(path.resolve(options.gameDirectory, "package.json"));
    gameNames = (await getGameConfs(gameNames, gamePackageJson, options)).map(([gameName]) => gameName);
    return project.remove(gameNames, options);
}
async function croupierGenerate(gamesToRun, options) {
    backutils_1.logger.level = options.logLevel;
    (0, backutils_1.watchProcess)();
    const gamePackageJson = require(path.resolve(options.gameDirectory, "package.json"));
    const gameConfs = await getGameConfs(gamesToRun, gamePackageJson, options);
    for (const [game, confFile] of gameConfs) {
        const croupier = croupierGenerateForConfig(confFile, packagejson, {
            override: options.override,
        });
        backutils_1.logger.info("Creating xls Report");
        const xlsReport = await (0, info_1.createReport)(croupier);
        backutils_1.logger.info("xls Report created");
        fs.ensureDirSync(`out/${game}`);
        fs.writeJSONSync(`out/${game}/croupier.json`, croupier, { spaces: 4 });
        xlsReport.xlsx.writeFile(`out/${game}/report.xlsx`);
        backutils_1.logger.info("Done !");
    }
}
function croupierInitConfig(options) {
    backutils_1.logger.level = options.logLevel;
    (0, backutils_1.watchProcess)();
    if (options.lotteryCode !== undefined) {
        options.lotteryCode = options.lotteryCode.toUpperCase();
    }
    const conf = config.init(options);
    console.log(JSON.stringify(conf, null, 2));
}
function actionWrapper(action) {
    return (...args) => {
        (0, backutils_1.watchProcess)();
        const options = args[args.length - 2];
        if (options instanceof Object && "logLevel" in options) {
            backutils_1.logger.level = options.logLevel;
        }
        action(...args);
    };
}
/**
 * Extract game name and game configuration path (as tuples) from the package.json file,
 * accordingly to options passed to the given command.
 *
 * @param gamesToRun: list of game names, if any (empty list is none)
 * @param command: the commanderjs command
 * @param packageJson: object built from the decoded package.json file.
 * @returns: list of tuples [gameName, gameConfPath] filtered by command options
 */
async function getGameConfs(gameNames, packageJson, options) {
    var _a, _b;
    const games = packageJson.games;
    (0, assert_1.strict)(Object.keys(games !== null && games !== void 0 ? games : {}).length > 0, `Couldn't find any game registered in package.json.` +
        `Is object "games" defined in package.json ?`);
    const actualGameNames = Object.keys(games);
    (0, assert_1.strict)(!(options.all && options.gameName), `you cannot mix option "--all" with option "gameName"`);
    if (gameNames.length === 0) {
        if (options.all) {
            gameNames = actualGameNames;
        }
        else if (options.gameName) {
            gameNames = [options.gameName];
        }
        else if (actualGameNames.length === 1) {
            gameNames = [actualGameNames[0]];
        }
        else {
            gameNames = [
                (await inquirer_1.default.prompt([
                    {
                        name: "question",
                        message: (_a = options.prompt) !== null && _a !== void 0 ? _a : "Please select a dealer: ",
                        type: "list",
                        choices: actualGameNames.map((key) => {
                            return {
                                value: key,
                                name: key,
                            };
                        }),
                    },
                ])).question,
            ];
        }
    }
    const unknownGames = [];
    const gameConfs = [];
    for (const gameName of gameNames) {
        if (gameName in games) {
            gameConfs.push([gameName, games[gameName]]);
        }
        else if (fs.existsSync(gameName)) {
            const _gameName = (_b = Object.keys(games).find((name) => games[name] === gameName)) !== null && _b !== void 0 ? _b : "";
            gameConfs.push([_gameName, gameName]);
        }
        else {
            unknownGames.push(gameName);
        }
    }
    (0, assert_1.strict)(unknownGames.length === 0, `Invalid game names: ${JSON.stringify(unknownGames)}.` +
        ` Possible game names: [${JSON.stringify(Object.keys(games))}]`);
    return gameConfs;
}
function croupierGenerateForConfig(confFile, context, options) {
    let conf = fs.readJSONSync(confFile);
    const requirementsFile = path.join(path.dirname(confFile), "specifications", "requirements.json");
    backutils_1.logger.info(`generating : ${context.name} (${conf.code})`);
    if (fs.existsSync(requirementsFile)) {
        conf = config.mergeWithRequirements(conf, fs.readJSONSync(requirementsFile));
    }
    const confDirectory = path.resolve(path.dirname(confFile));
    let generator;
    // set the seed if not set yet or asked to override it
    if (!conf.seed || (options === null || options === void 0 ? void 0 : options.override)) {
        backutils_1.logger.info(`set seed in config file: ${confFile}`);
        conf.seed = uuid_1.default.v4();
        fs.writeJsonSync(confFile, conf, { spaces: 2 });
    }
    if (conf.sourceFile !== undefined) {
        const convertSource = (0, convert_1.extractConvertSource)({
            currentPath: path.dirname(confFile),
            filePath: conf.sourceFile,
            symbolClassPath: conf.symbolClass,
        });
        backutils_1.logger.info(`from source: ${conf.sourceFile}`);
        generator = new convert_1.Converter(conf, convertSource, context);
    }
    else {
        let symbolClass;
        if (conf.symbolClass !== undefined) {
            const symbolClassPath = conf.symbolClass.substr(0, 2) === "./"
                ? path.resolve(path.dirname(confFile), conf.symbolClass)
                : path.resolve(conf.symbolClass);
            symbolClass = (0, loadClass_1.loadClass)(symbolClassPath);
        }
        generator = new pool_1.Generator(conf, context, symbolClass);
    }
    return generator.run();
}
exports.croupierGenerateForConfig = croupierGenerateForConfig;
async function croupierInfo(gameToRun, command) {
    // necessary ?
    return Promise.resolve();
}
if (require.main === module) {
    run();
}
//# sourceMappingURL=cli.js.map