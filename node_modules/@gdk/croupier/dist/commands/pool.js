"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateUsrSql = exports.Generator = void 0;
const backutils_1 = require("@gdk/backutils");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const process = __importStar(require("process"));
const loadClass_1 = require("../tools/loadClass");
const seedLodash_1 = require("../tools/seedLodash");
const hashes_1 = require("../tools/hashes");
const config = __importStar(require("./config"));
const CROUPIER_SCHEMA = path.join(__dirname, "..", "..", "resources", "croupier-schema-1.json");
class Generator {
    constructor(conf, packageJson, symbolClass) {
        this.conf = conf;
        this.packageJson = packageJson;
        this.symbolClass = symbolClass;
        this.nextId = 0;
        this.usedSymbols = [];
        this.usedIds = [];
        backutils_1.logger.info(`generate using seed : ${conf.seed}`);
        config.validate(conf);
        seedLodash_1.SeedLodash.seed(conf.seed);
        // a symbol class is needed if at least one rank has a shape having quantity > 0
        const needSymbolClass = conf.ranks.some((rank) => {
            return (rank.shapes instanceof Array &&
                rank.shapes.length > 0 &&
                rank.shapes.some((shape) => shape.quantity > 0));
        });
        if (needSymbolClass && this.symbolClass === undefined) {
            const ticketClassPath = path.resolve(process.cwd(), ".build", "src", "ticket.js");
            this.symbolClass = (0, loadClass_1.loadClass)(ticketClassPath);
        }
        this.nextId = 0;
        this.usedIds = [];
        this.usedSymbols = [];
    }
    /**
     * Run the generation
     */
    run() {
        var _a, _b;
        const res = {
            schemaVersion: 3,
            productName: this.packageJson.name,
            productVersion: this.packageJson.version,
            version: 1,
            date: Date.now(),
            masterGameCode: this.conf.masterGameCode,
            code: this.conf.code,
            description: this.conf.description || `dealer ${this.conf.code}`,
            renewal: this.conf.renewal,
            baseStake: this.conf.baseStake,
            infos: this.conf.infos,
            ranks: [],
            seed: this.conf.seed,
        };
        // Order ranks
        // TODO: autogenerate rank ids ??
        this.conf.ranks = seedLodash_1.SeedLodash.instance.sortBy(this.conf.ranks, (r) => -r.factor.numerator / r.factor.denominator);
        for (const rank of this.conf.ranks) {
            rank.prizeDescription = rank.prizeDescription
                ? `${this._prefix(rank.id)} - ${rank.prizeDescription}`
                : undefined;
            // TODO: auto generate prizeDescription ?
            // `${this._prefix(rank.id)} - ${.format(rank.factor.numerator / rank.factor.denominator * this.conf.stakes[0].value)}`;
        }
        // look for already made tickets
        for (const rank of this.conf.ranks) {
            if (rank.tickets) {
                rank.tickets = rank.tickets.filter((ticket) => {
                    return ticket.quantity > 0;
                });
                for (const ticket of rank.tickets) {
                    if (this.usedSymbols.indexOf(ticket.symbol) > -1) {
                        backutils_1.logger.warn(`symbol ${ticket.symbol} appears several times in made tickets`);
                    }
                    else if (this.usedIds.indexOf(ticket.id) > -1) {
                        throw new Error(`id ${ticket.id} appears several times in made tickets`);
                    }
                    else {
                        this.usedSymbols.push(ticket.symbol);
                        this.usedIds.push(ticket.id);
                    }
                }
            }
            else {
                rank.tickets = [];
            }
        }
        // execute before
        if ((_a = this.symbolClass) === null || _a === void 0 ? void 0 : _a.beforeAll) {
            this.symbolClass.beforeAll(this.conf);
        }
        for (const rank of this.conf.ranks) {
            if (rank.shapes) {
                for (const shape of rank.shapes) {
                    while (shape.dbRecordQuantity > 0) {
                        const aticket = this.getTicketFromShape(rank, shape);
                        const symbol = this._symbolToString(aticket.toSymbol());
                        this.usedSymbols.push(symbol);
                        const quantity = Math.ceil(shape.quantity / shape.dbRecordQuantity);
                        shape.quantity -= quantity;
                        shape.dbRecordQuantity--;
                        rank.tickets.push({
                            id: this.nextTicketId(),
                            symbol,
                            quantity,
                            metadatas: aticket.toMetadatas(),
                            tv: seedLodash_1.SeedLodash.instance.isUndefined(aticket.tv) ? undefined : aticket.tv,
                            bonus: seedLodash_1.SeedLodash.instance.isUndefined(aticket.bonus) ? undefined : aticket.bonus,
                            extra: seedLodash_1.SeedLodash.instance.isUndefined(aticket.extra) ? undefined : aticket.extra,
                        });
                    }
                }
                delete rank.shapes;
            }
        }
        res.ranks.push(...this.conf.ranks);
        // Autogenerate renewalls if needed
        /*let totalTicket = 0;
        for (const r of res.ranks) {
            if (r.id === 1 && SeedLodash.instance.isUndefined(r.renewal)) { r.renewal = 1; } // renewal = 1 on rank 1.
            totalTicket += r.tickets.reduce((s, t) => s += t.quantity, 0);
        }
        if (SeedLodash.instance.isUndefined(res.renewal)) {
            res.renewal = totalTicket - 1;
        }*/
        // execute after
        if ((_b = this.symbolClass) === null || _b === void 0 ? void 0 : _b.afterAll) {
            this.symbolClass.afterAll(this.conf, res);
        }
        res.hashes = (0, hashes_1.computeHashes)(res);
        // Validate output against schema
        const validator = new backutils_1.JsonValidator(JSON.parse(fs.readFileSync(CROUPIER_SCHEMA).toString()));
        validator.assert(res);
        return res;
    }
    getTicketFromShape(rank, shape) {
        let tries = 0;
        let ok = false;
        let ticket;
        do {
            if (tries++ >= 100) {
                throw new Error(`Not able to generate a new symbol after ${tries} tries`);
            }
            ticket = new this.symbolClass(this.conf, rank, shape);
            const symbol = this._symbolToString(ticket.toSymbol());
            if (this.usedSymbols.indexOf(symbol) === -1) {
                ok = true;
            }
        } while (!ok);
        return ticket;
    }
    nextTicketId() {
        do {
            this.nextId++;
        } while (this.usedIds.indexOf(this.nextId) !== -1);
        return this.nextId;
    }
    _prefix(n) {
        let res = "";
        if (n === 0) {
            return (res = String(n));
        }
        switch (n % 100) {
            case 1:
            case 21:
            case 31:
            case 41:
            case 51:
            case 61:
            case 71:
            case 81:
            case 91:
                res = `${n}st`;
                break;
            case 2:
            case 22:
            case 32:
            case 42:
            case 52:
            case 62:
            case 72:
            case 82:
            case 92:
                res = `${n}nd`;
                break;
            case 3:
            case 23:
            case 33:
            case 43:
            case 53:
            case 63:
            case 73:
            case 83:
            case 93:
                res = `${n}rd`;
                break;
            case 11:
            case 12:
            case 13:
            default:
                res = `${n}th`;
                break;
        }
        return res;
    }
    _formatAmount(a) {
        return new Intl.NumberFormat("en-US", {
            style: "currency",
            currency: this.conf.stakes[0].currency,
        })
            .format(a)
            .replace(/,/g, ".");
    }
    _symbolToString(symbol) {
        if (!seedLodash_1.SeedLodash.instance.isString(symbol)) {
            symbol = `|JSON|${JSON.stringify(symbol)}`;
        }
        return symbol;
    }
    _stringToSymbol(symbol) {
        const matches = symbol.match(/^(\|JSON\|)(.*)/);
        if (matches) {
            symbol = JSON.parse(matches[2]);
        }
        return symbol;
    }
}
exports.Generator = Generator;
function generateUsrSql(infos) {
    const ecoCode = infos.engineCode || "ITG";
    return `UPDATE REF_USR_EXTERNAL_SERVICE SET
	EXS_NAME = '${infos.serviceName}',
	EXS_DESCRIPTION = '${infos.description || infos.serviceName}',
	EXS_TYPE = '${infos.type}',
	EXS_ACCOUNT_NUMBER = '${infos.bicCode}',
	EXS_CREATED = SYSDATE,
	EXS_UPDATED = SYSDATE
	WHERE ECO_CODE ='${ecoCode}' AND EXS_CODE = '${infos.serviceCode}';

INSERT INTO REF_USR_EXTERNAL_SERVICE( ECO_CODE, EXS_CODE, EXS_NAME, EXS_DESCRIPTION, EXS_TYPE, EXS_ACCOUNT_NUMBER, EXS_CREATED, EXS_UPDATED)
	SELECT '${ecoCode}', '${infos.serviceCode}', '${infos.serviceName}', '${infos.description || infos.serviceName}', '${infos.type}', '${infos.bicCode}', SYSDATE, SYSDATE FROM DUAL
	WHERE NOT EXISTS( SELECT 1 FROM REF_USR_EXTERNAL_SERVICE WHERE ECO_CODE ='${ecoCode}' AND EXS_CODE = '${infos.serviceCode}');

INSERT INTO usr_site_offer( ECO_CODE, EXS_CODE, SIT_CODE, SIO_STATUS, SIO_CREATED, SIO_UPDATED)
	select '${ecoCode}', '${infos.serviceCode}', 'FDJ_WEB', 'C', sysdate, sysdate from dual
	where not exists (select 1 from usr_site_offer where ECO_CODE = '${ecoCode}' and EXS_CODE = '${infos.serviceCode}' and SIT_CODE = 'FDJ_WEB');

INSERT INTO usr_limit_domain( ECO_CODE, EXS_CODE, SIT_CODE, LIT_CODE, LID_CREATED, LID_UPDATED)
	select '${ecoCode}', '${infos.serviceCode}', 'FDJ_WEB', 'AMT_CMP', sysdate, sysdate from dual
	where not exists (select 1 from usr_limit_domain where ECO_CODE = '${ecoCode}' and EXS_CODE = '${infos.serviceCode}' and SIT_CODE = 'FDJ_WEB' and LIT_CODE='AMT_CMP');

INSERT INTO usr_limit_domain( ECO_CODE, EXS_CODE, SIT_CODE, LIT_CODE, LID_CREATED, LID_UPDATED)
	select '${ecoCode}', '${infos.serviceCode}', 'FDJ_WEB', 'AMT_SPDVUV', sysdate, sysdate from dual
	where not exists (select 1 from usr_limit_domain where ECO_CODE = '${ecoCode}' and EXS_CODE = '${infos.serviceCode}' and SIT_CODE = 'FDJ_WEB' and LIT_CODE='AMT_SPDVUV');

INSERT INTO usr_limit_domain( ECO_CODE, EXS_CODE, SIT_CODE, LIT_CODE, LID_CREATED, LID_UPDATED)
	select '${ecoCode}', '${infos.serviceCode}', 'FDJ_WEB', 'AMT_SPDEUR', sysdate, sysdate from dual
	where not exists( select 1 from usr_limit_domain where ECO_CODE = '${ecoCode}' and EXS_CODE = '${infos.serviceCode}' and SIT_CODE = 'FDJ_WEB' and LIT_CODE='AMT_SPDEUR');`;
}
exports.generateUsrSql = generateUsrSql;
//# sourceMappingURL=pool.js.map