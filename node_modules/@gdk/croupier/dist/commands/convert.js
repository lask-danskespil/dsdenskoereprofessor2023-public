"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Converter = exports.extractConvertSource = void 0;
const assert_1 = require("assert");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const lodash = __importStar(require("lodash"));
const core_1 = require("@gdk/core");
const backutils_1 = require("@gdk/backutils");
const seedLodash_1 = require("../tools/seedLodash");
const config_1 = require("./config");
const lotteries = __importStar(require("../lotteries"));
const hashes_1 = require("../tools/hashes");
const loadClass_1 = require("../tools/loadClass");
const pool_1 = require("./pool");
const random = __importStar(require("../tools/random"));
const parseTilut = __importStar(require("../tools/parseTilut"));
const parsePetfile = __importStar(require("../tools/parsePetfile"));
const parseCroupier = __importStar(require("../tools/parseCroupier"));
function extractConvertSource(params) {
    const { ext } = path.parse(params.filePath);
    const filePath = params.filePath[0] === "/"
        ? path.resolve(params.filePath)
        : path.resolve(params.currentPath, params.filePath);
    if (!fs.existsSync(filePath)) {
        throw new Error(`Convert source file was not found: ${filePath}`);
    }
    let parseSymbol;
    if (params.symbolClassPath !== undefined) {
        const symbolClassPath = params.symbolClassPath[0] === "/"
            ? path.resolve(params.symbolClassPath)
            : path.resolve(params.currentPath, params.symbolClassPath);
        const symbolClass = (0, loadClass_1.loadClass)(symbolClassPath);
        parseSymbol = (shape) => new symbolClass(shape).toString();
    }
    switch (ext) {
        case ".pet":
            return parsePetfile.parse(filePath, parseSymbol);
        case ".tilut":
            return parseTilut.parse(filePath, parseSymbol);
        case ".json":
            return parseCroupier.parse(filePath, parseSymbol);
        default:
            throw new Error(`cannot handle convert source file with extension "${ext}": "${filePath}"`);
    }
}
exports.extractConvertSource = extractConvertSource;
class Converter {
    constructor(config, source, context) {
        this.config = config;
        this.source = source;
        this.name = context.name;
        this.version = context.version;
        this.validateConfig(config);
        backutils_1.logger.info(`using seed : ${this.config.seed}`);
        seedLodash_1.SeedLodash.seed(this.config.seed);
        const configShapes = lodash.uniq(lodash
            .flatten(this.config.ranks.map((rank) => rank.shapes))
            .filter((shape) => shape.quantity > 0)
            .map((shape) => shape.value));
        const sourceShapes = lodash.values(this.source).map((shape) => String(shape.value));
        const missingShapes = lodash.difference(configShapes, sourceShapes);
        (0, assert_1.strict)(missingShapes.length === 0, `some shape value referenced in config cannot be found in source file:` +
            ` [${missingShapes.join(", ")}]`);
    }
    validateConfig(config) {
        var _a;
        (0, assert_1.strict)(config.hasOwnProperty("lottery") &&
            typeof config.lottery === "string" &&
            lotteries.CONVERT_CONFIGS.hasOwnProperty(config.lottery), `invalid lottery code in config: ${(_a = config.lottery) !== null && _a !== void 0 ? _a : "undefined"}`);
        this.lotteryCode = config.lottery;
        this.lotteryConf = lotteries.CONVERT_CONFIGS[this.lotteryCode];
        // pre check if dbRecorQuantities are set,
        // raises a dedicated error with available symbols if not set
        // (more explicit than the validateConfig error)
        const dbRecordQantities = this.autosetDbRecordQuantities(config);
        (0, config_1.validate)(config);
        // validate dbRecordQantities / quantities against available symbols
        this.validateConfigQuantities(config);
    }
    validateConfigQuantities(config) {
        var _a, _b, _c, _d, _e;
        const multiplyQuantitiesBy = (_a = this.config.multiplyQuantitiesBy) !== null && _a !== void 0 ? _a : 1;
        const errorMessages = [];
        let poolSize = 0;
        for (const rankConfig of config.ranks) {
            for (const shapeConfig of rankConfig.shapes) {
                const available = (_c = (_b = this.source[shapeConfig.value]) === null || _b === void 0 ? void 0 : _b.weight) !== null && _c !== void 0 ? _c : 0;
                const shapeWeight = (_e = (_d = this.source[shapeConfig.value]) === null || _d === void 0 ? void 0 : _d.weight) !== null && _e !== void 0 ? _e : 0;
                poolSize += shapeConfig.quantity;
                if (shapeConfig.quantity > 0 && shapeWeight === 0) {
                    errorMessages.push(`Shape not found in source: "${shapeConfig.value}"`);
                }
                if (shapeConfig.dbRecordQuantity > shapeWeight) {
                    errorMessages.push(`At least one shape has: symbols in source file < dbRecordQuantity. ` +
                        `Rank "${rankConfig.id}" / shape "${shapeConfig.value}": ` +
                        `dbRecordQuantity = ${shapeConfig.dbRecordQuantity}` +
                        ` > available symbols in source file = ${shapeWeight}`);
                }
                // in not depleting mode, every available symbol should be used
                // print a warning if available symbols > dbRecordQuantity
                if (!this.isDepleting && shapeConfig.dbRecordQuantity < available) {
                    backutils_1.logger.warn(`rank "${rankConfig.id}" / shape "${shapeConfig.value}": ` +
                        `unusual for a non depleting dealer: ` +
                        `using ${shapeConfig.dbRecordQuantity} / ${available} symbols available.`);
                }
                const actualQuantity = multiplyQuantitiesBy * shapeConfig.quantity;
                if (shapeConfig.dbRecordQuantity > actualQuantity) {
                    errorMessages.push(`At least one shape has: ticket quantity < dbRecordQuantity. ` +
                        `Rank "${rankConfig.id}" / shape "${shapeConfig.value}": ` +
                        `quantity ${actualQuantity} < dbRecordQuantity = ${shapeConfig.dbRecordQuantity}. ` +
                        `Maybe multiply all quantities with config field "multiplyQuantitiesBy" ?`);
                }
            }
        }
        if (config.renewal > poolSize) {
            errorMessages.push(`Invalid renewal > pool size. ` +
                ` Configuration renewal (${config.renewal}) should be lower or equal` +
                ` to the pool size (${poolSize})`);
        }
        if (errorMessages.length > 0) {
            throw new Error(errorMessages.join("\n"));
        }
    }
    autosetDbRecordQuantities(config) {
        var _a, _b;
        const ranks = config.ranks;
        const records = [];
        if (ranks instanceof Array) {
            for (const rank of ranks) {
                const shapes = rank.shapes;
                if (shapes instanceof Array) {
                    for (const shape of shapes) {
                        const availableSymbols = (_b = (_a = this.source[shape.value]) === null || _a === void 0 ? void 0 : _a.weight) !== null && _b !== void 0 ? _b : 0;
                        if (shape.dbRecordQuantity === undefined) {
                            backutils_1.logger.debug(`rank "${rank.id}" / shape "${shape.value}": ` +
                                `dbRecordQuantity not set, setting it to number of available symbols ` +
                                `in source file: ${availableSymbols}`);
                            shape.dbRecordQuantity = availableSymbols;
                        }
                        records.push({
                            rank: rank.id,
                            shape: shape.value,
                            dbQuantity: shape.dbRecordQuantity,
                            availableSymbols,
                        });
                    }
                }
            }
        }
        return records;
    }
    get isDepleting() {
        return this.lotteryConf.depleting;
    }
    computeRenewal() {
        var _a;
        if (this.config.renewal !== undefined) {
            return this.config.renewal;
        }
        else if (this.lotteryConf.computeRenewal !== undefined) {
            const multiplyQuantitiesBy = (_a = this.config.multiplyQuantitiesBy) !== null && _a !== void 0 ? _a : 1;
            const poolSize = lodash.sum(lodash.flatten(this.config.ranks.map(({ shapes }) => shapes.map(({ quantity }) => quantity))));
            return this.lotteryConf.computeRenewal(multiplyQuantitiesBy * poolSize);
        }
        else {
            return 0;
        }
    }
    /**
     * Run source convertion into a dealer
     */
    run() {
        var _a;
        const dealer = {
            schemaVersion: 3,
            productName: this.name,
            productVersion: this.version,
            version: 1,
            date: Date.now(),
            masterGameCode: this.config.masterGameCode,
            code: this.config.code,
            description: (_a = this.config.description) !== null && _a !== void 0 ? _a : `${this.lotteryCode} : ${this.config.code}`,
            renewal: this.computeRenewal(),
            baseStake: this.config.baseStake,
            ranks: this.extractRanks(),
            seed: this.config.seed,
        };
        // update ticket ids
        let ticketId = 1;
        for (const rank of dealer.ranks) {
            for (const ticket of rank.tickets) {
                ticket.id = ticketId++;
            }
        }
        // ensure lotteryConf.depleting matches dealer renewal
        if (this.lotteryConf.depleting) {
            (0, assert_1.strict)(dealer.renewal > 0, `Dealer renewal is disabled (== 0) ` +
                `but lottery ${this.lotteryCode} is configured as depleting`);
        }
        else {
            (0, assert_1.strict)(dealer.renewal === 0, `Dealer renewal is enabled (!= 0) ` +
                `but lottery ${this.lotteryCode} is configured as NON depleting`);
        }
        dealer.hashes = (0, hashes_1.computeHashes)(dealer);
        const pool = new pool_1.Generator(dealer, { version: this.version, name: this.name });
        return pool.run();
    }
    extractRanks() {
        var _a;
        const ranks = this.config.ranks.map((rankConfig, index) => {
            var _a;
            const rank = {
                id: (_a = rankConfig.id) !== null && _a !== void 0 ? _a : index + 1,
                factor: rankConfig.factor,
                tickets: this.extractRankTickets(rankConfig),
                prizeDescription: rankConfig.prizeDescription,
            };
            if (rankConfig.prizeType !== undefined) {
                rank.prizeType = rankConfig.prizeType;
            }
            return rank;
        });
        // update descriptions
        if ((_a = this.lotteryConf.prizeDescriptions) !== null && _a !== void 0 ? _a : true) {
            const stake = this.config.baseStake;
            for (const rank of ranks) {
                if (rank.prizeDescription === undefined) {
                    rank.prizeDescription = core_1.Numeral.currency({
                        value: (rank.factor.numerator / rank.factor.denominator) * stake,
                        currency: this.lotteryConf.currency,
                    });
                }
            }
        }
        return ranks;
    }
    extractRankTickets(rankConfig) {
        var _a, _b, _c;
        let tickets = [];
        const shapes = (_a = rankConfig.shapes) !== null && _a !== void 0 ? _a : [];
        // debug logs
        const nbSourceSymbols = lodash.sum(shapes.map(({ value }) => { var _a, _b; return (_b = (_a = this.source[value]) === null || _a === void 0 ? void 0 : _a.symbols.length) !== null && _b !== void 0 ? _b : 0; }));
        backutils_1.logger.debug(`extracting tickets for rank ${rankConfig.id}: collecting tickets` +
            ` from ${core_1.Numeral.format(nbSourceSymbols)} symbols in source pool...`);
        let nbSourceSymbolsBeforeLog = nbSourceSymbols * 0.2;
        const multiplyQuantitiesBy = (_b = this.config.multiplyQuantitiesBy) !== null && _b !== void 0 ? _b : 1;
        for (const shapeConfig of shapes) {
            // skip shape having quantity === 0
            if (shapeConfig.quantity === 0) {
                continue;
            }
            const sourceShape = this.source[shapeConfig.value];
            const shapeQuantity = multiplyQuantitiesBy * shapeConfig.quantity;
            // deduct the symbol pool from dbRecordQuantity
            const symbols = shapeConfig.dbRecordQuantity < sourceShape.symbols.length
                ? random.shuffle(sourceShape.symbols).slice(0, shapeConfig.dbRecordQuantity)
                : sourceShape.symbols;
            const shapeWeight = (_c = lodash.sum(symbols.map((symbol) => symbol.weight))) !== null && _c !== void 0 ? _c : 0;
            let shapeQuantityLeft = shapeQuantity;
            let shapeWeightLeft = shapeWeight;
            const shapeTickets = [];
            for (const { symbol, weight, source, shape } of symbols) {
                const quantity = Math.ceil((shapeQuantityLeft * weight) / shapeWeightLeft);
                shapeQuantityLeft -= quantity;
                shapeWeightLeft -= weight;
                shapeTickets.push({
                    id: 0,
                    symbol,
                    quantity,
                    metadatas: {
                        shape: String(shape),
                        source: lodash.truncate(source, { length: 500, omission: " [...]" }),
                    },
                });
                // debug logs: report extraction progress
                if (--nbSourceSymbolsBeforeLog <= 0) {
                    const progress = shapeTickets.length / nbSourceSymbols;
                    backutils_1.logger.debug(`    symbol collection: ${Math.round(100 * progress)} % done`);
                    nbSourceSymbolsBeforeLog = nbSourceSymbols * 0.2;
                }
            }
            // ensure the ticket quantity comply with shape configuration
            // and adjust last ticket quantity if the difference is 1 at most
            const actualQuantity = lodash.sum(shapeTickets.map((ticket) => ticket.quantity));
            const quantityDiff = actualQuantity - shapeQuantity;
            if (quantityDiff !== 0) {
                (0, assert_1.strict)(Math.abs(quantityDiff) <= 1, `shape "${shapeConfig.value}": actual quantity: ${actualQuantity} differs too much` +
                    ` from expected quantity: ${shapeQuantity}` +
                    ` (= ${shapeConfig.quantity} x ${multiplyQuantitiesBy})`);
                shapeTickets[shapeTickets.length - 1].quantity -= quantityDiff;
            }
            // in non depleting mode, ticket with quantity == 0 are not allowed
            if (!this.isDepleting) {
                const wrongTickets = shapeTickets.filter((ticket) => ticket.quantity === 0);
                if (wrongTickets.length > 0) {
                    assert_1.strict.fail(`shape ${JSON.stringify(shapeConfig)} has ${wrongTickets.length} tickets ` +
                        `with quantity == 0. example: ${JSON.stringify(wrongTickets[0], null, 4)}`);
                }
            }
            tickets = tickets.concat(shapeTickets);
        }
        // deduplicate tickets having same symbol
        const uniqTickets = lodash.uniqBy(tickets, "symbol");
        if (uniqTickets.length !== tickets.length) {
            backutils_1.logger.debug("    symbol deduplication: in progress");
            for (const uniqTicket of uniqTickets) {
                for (const ticket of tickets) {
                    if (ticket.symbol === uniqTicket.symbol && ticket !== uniqTicket) {
                        uniqTicket.quantity += ticket.quantity;
                    }
                }
            }
            backutils_1.logger.debug(`    symbol deduplication: done.` +
                ` (${core_1.Numeral.format(tickets.length)} -> ${core_1.Numeral.format(uniqTickets.length)})`);
        }
        // tickets with quantity = 0 are accepted only if they are the only one in
        // the list
        return uniqTickets.filter((ticket, index) => {
            return ticket.quantity > 0 || (index === 0 && uniqTickets.length === 1);
        });
    }
    /**
     * Adjust rank quantities to use every symbol of source.
     * WARNING: generally raises the quantity of tickets in ranks. Do not use in a depleting
     * dealer !
     */
    adjustRankQuantities(ranks) {
        var _a;
        // If it is a non depleting pool
        // find ranks with more symbol than pool occurences to determine
        // a coef to apply on the number of occurences
        const ratios = ranks.map((rank, i) => {
            var _a;
            const shapes = (_a = rank.shapes) !== null && _a !== void 0 ? _a : [];
            return shapes.map((shape) => {
                return shape.quantity === 0
                    ? 0
                    : Math.ceil(this.source[shape.value].weight / shape.quantity);
            });
        });
        const mult = (_a = lodash.max(lodash.flatten(ratios))) !== null && _a !== void 0 ? _a : 0;
        if (mult > 1) {
            for (const rank of ranks) {
                for (const shape of rank.shapes) {
                    shape.quantity *= mult;
                }
            }
        }
    }
}
exports.Converter = Converter;
//# sourceMappingURL=convert.js.map