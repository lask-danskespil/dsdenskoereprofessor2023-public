"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.remove = exports.add = exports.RemoveError = void 0;
const backutils_1 = require("@gdk/backutils");
const lodash = __importStar(require("lodash"));
const fs = __importStar(require("fs"));
const path_1 = require("path");
const chalk_1 = __importDefault(require("chalk"));
const config = __importStar(require("./config"));
class RemoveError extends Error {
    constructor(message) {
        super(message);
        this.name = "RemoveError";
    }
}
exports.RemoveError = RemoveError;
function formatChanges(changes) {
    return Object.keys(changes)
        .map((p) => {
        const status = changes[p] !== null ? chalk_1.default.green(fs.existsSync(p) ? "M" : "A") : chalk_1.default.red("D");
        const relativePath = path_1.posix.relative(process.cwd(), p);
        return `${status}  ${chalk_1.default.white(relativePath)}`;
    })
        .join("\n");
}
function applyChanges(changes) {
    // apply changes
    for (const p in changes) {
        if (!changes.hasOwnProperty(p)) {
            continue;
        }
        const value = changes[p];
        if (value === null) {
            fs.rmSync(p, { recursive: true });
        }
        else if (value === "" && p[p.length - 1] === "/") {
            // empty directory
            fs.mkdirSync(p, { recursive: true });
        }
        else {
            fs.mkdirSync(path_1.posix.dirname(p), { recursive: true });
            fs.writeFileSync(p, value);
        }
    }
}
function readPackageGames(gameDirectory = process.cwd()) {
    var _a;
    const gamePackage = fs.readFileSync(path_1.posix.join(gameDirectory, "package.json"), "utf8");
    const gamePackageJson = JSON.parse(gamePackage);
    return (_a = gamePackageJson.games) !== null && _a !== void 0 ? _a : {};
}
function readResourceGames(gameDirectory = process.cwd()) {
    const resourceDir = path_1.posix.join(gameDirectory, "resources");
    return fs
        .readdirSync(resourceDir, { withFileTypes: true })
        .filter((entry) => entry.isDirectory())
        .map((entry) => entry.name);
}
function add(gameName, options) {
    const changes = {};
    computeGameAddition(gameName, options, changes);
    previewAddition(gameName, changes);
    if (options.pretend) {
        backutils_1.logger.info(`in PRETEND MODE: nothing actually done, remove -p option to proceed\n`);
        return;
    }
    applyChanges(changes);
    backutils_1.logger.info("done");
}
exports.add = add;
function computeGameAddition(gameName, options, changes) {
    var _a, _b, _c;
    const gamePackagePath = path_1.posix.join(options.gameDirectory, "package.json");
    const gamePackage = (_a = changes[gamePackagePath]) !== null && _a !== void 0 ? _a : fs.readFileSync(gamePackagePath, "utf8");
    const gamePackageJson = JSON.parse(gamePackage);
    const games = (_b = gamePackageJson.games) !== null && _b !== void 0 ? _b : {};
    const resourceDir = path_1.posix.join(options.gameDirectory, "resources", gameName);
    let confPath = path_1.posix.join(resourceDir, "conf.json");
    if (!(gameName in games)) {
        games[gameName] = path_1.posix.relative(options.gameDirectory, confPath);
        gamePackageJson.games = games;
        const packageIndentation = guessIndentation(gamePackage);
        changes[gamePackagePath] = JSON.stringify(gamePackageJson, null, packageIndentation);
    }
    else {
        confPath = games[gameName];
        if (confPath[0] === "/") {
            confPath = path_1.posix.join(options.gameDirectory, confPath);
        }
    }
    const specDir = path_1.posix.join(resourceDir, "specifications");
    if (!fs.existsSync(specDir)) {
        changes[specDir + "/"] = "";
    }
    if (!fs.existsSync(confPath)) {
        const croupierConfig = config.init(Object.assign(Object.assign({}, options), { code: (_c = options.code) !== null && _c !== void 0 ? _c : gameName }));
        changes[confPath] = JSON.stringify(croupierConfig, null, 2);
    }
    const testFile = path_1.posix.join(options.gameDirectory, "test", gameName, "index.spec.ts");
    if (!fs.existsSync(testFile)) {
        changes[testFile] = generateGameTestCode(gameName);
    }
    if (options.sourceFile !== undefined) {
        const sourceFile = path_1.posix.join(resourceDir, path_1.posix.basename(options.sourceFile));
        if (!fs.existsSync(sourceFile)) {
            changes[sourceFile] = fs.readFileSync(options.sourceFile, "utf8");
        }
    }
}
function previewAddition(gameName, changes) {
    let preview = `add dealers: "${gameName}"\n`;
    // display preview
    if (Object.keys(changes).length === 0) {
        backutils_1.logger.info(preview);
        backutils_1.logger.warn("nothing to do");
        return;
    }
    preview += "\n" + formatChanges(changes) + "\n";
    backutils_1.logger.info(preview);
}
function generateGameTestCode(gameName) {
    const testerClassName = [gameName[0].toUpperCase(), gameName.substr(1), "Tester"].join("");
    return `import { ACroupierTester } from "../croupierTester";

class ${testerClassName} extends ACroupierTester {
	public constructor() {
		super("${gameName}");
	}
}

describe("${gameName}-tests", () => {
	(new ${testerClassName}()).test();
});
`;
}
function remove(gameNames, options) {
    if (gameNames.length > 0) {
        if (options.all) {
            throw new RemoveError(`remove: game name arguments and --all option are mutually exclusive`);
        }
    }
    else {
        if (!options.all) {
            throw new RemoveError(`remove: no game name name specified. nothing to do`);
        }
        const games = readPackageGames(options.gameDirectory);
        gameNames.push(...Object.keys(games));
        const gameDirs = lodash.difference(readResourceGames(options.gameDirectory), Object.values(games));
        gameNames.push(...gameDirs);
    }
    gameNames = lodash.uniq(gameNames);
    const pretend = !options.force;
    const changes = {};
    for (const gameName of gameNames) {
        computeGameRemoval(gameName, options.gameDirectory, changes);
    }
    previewRemoval(gameNames, changes);
    if (pretend) {
        backutils_1.logger.info(`in PRETEND MODE: nothing actually removed, add -f option to proceed\n`);
        return;
    }
    applyChanges(changes);
    backutils_1.logger.info("done");
}
exports.remove = remove;
function computeGameRemoval(gameName, gameDirectory, changes) {
    var _a, _b;
    const gamePackagePath = path_1.posix.join(gameDirectory, "package.json");
    const gamePackage = (_a = changes[gamePackagePath]) !== null && _a !== void 0 ? _a : fs.readFileSync(gamePackagePath, "utf8");
    const gamePackageJson = JSON.parse(gamePackage);
    const games = (_b = gamePackageJson.games) !== null && _b !== void 0 ? _b : {};
    let resourceDir = path_1.posix.join(gameDirectory, "resources", gameName);
    if (gameName in games) {
        const _resourceDir = path_1.posix.join(gameDirectory, games[gameName]);
        delete games[gameName];
        gamePackageJson.games = games;
        const packageIndentation = guessIndentation(gamePackage);
        const newGamePackage = JSON.stringify(gamePackageJson, null, packageIndentation);
        if (newGamePackage !== gamePackage) {
            changes[gamePackagePath] = newGamePackage;
        }
        if (!_resourceDir.startsWith(resourceDir)) {
            resourceDir = _resourceDir;
        }
    }
    if (fs.existsSync(resourceDir)) {
        changes[resourceDir] = null;
    }
    const testDir = path_1.posix.join(gameDirectory, "test", gameName);
    if (fs.existsSync(testDir)) {
        changes[testDir] = null;
    }
}
function previewRemoval(gameNames, changes) {
    let preview = `remove dealers: "${gameNames.join(", ")}"\n`;
    // display preview
    if (Object.keys(changes).length === 0) {
        backutils_1.logger.info(preview);
        backutils_1.logger.warn("nothing to do (no file related)");
        return;
    }
    preview += "\n" + formatChanges(changes) + "\n";
    backutils_1.logger.info(preview);
}
const INDENT_PATTERN = /^( *)[^ ]/;
function guessIndentation(content) {
    const lines = content.split("\n");
    if (lines.some((line) => line.startsWith("\t"))) {
        return "\t";
    }
    const level = lines
        .map((line) => { var _a, _b; return (_b = (_a = INDENT_PATTERN.exec(line)) === null || _a === void 0 ? void 0 : _a[1].length) !== null && _b !== void 0 ? _b : 0; })
        .filter((l) => l > 0)
        .sort()[0];
    return " ".repeat(level !== null && level !== void 0 ? level : 0);
}
//# sourceMappingURL=project.js.map