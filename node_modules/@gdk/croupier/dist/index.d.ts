declare module "@gdk/croupier" {
	export * from "@gdk/croupier/commands/info";
	export * from "@gdk/croupier/commands/pool";
	export * from "@gdk/croupier/cli";
	export * from "@gdk/croupier/test/baseCroupierTester";
	export * from "@gdk/croupier/tools/random";
	export * from "@gdk/croupier/tools/universe";
	export * as frequencies from "./tools/frequencies";
	export * as parseTilut from "./tools/parseTilut";
	export * as parsePetfile from "./tools/parsePetfile";
	export * as parseCroupier from "./tools/parseCroupier";
	export * from "@gdk/croupier/tools/testHelpers";
	global {
	    var gdkLogLevel: undefined | string;
	}
}

declare module "@gdk/croupier/commands/info" {
	import { Workbook } from "exceljs";
	import type { ICroupier } from "@gdk/backutils";
	export function createReport(croupier: ICroupier): Promise<Workbook>;
}

declare module "@gdk/croupier/commands/pool" {
	import type { ICroupier, ICroupierConfig, ATicketClass, ICroupierUsrInfos } from "@gdk/backutils";
	export class Generator<T extends ATicketClass> {
	    private conf;
	    private packageJson;
	    private symbolClass?;
	    private nextId;
	    private usedSymbols;
	    private usedIds;
	    constructor(conf: ICroupierConfig, packageJson: any, symbolClass?: any);
	    /**
	     * Run the generation
	     */
	    run(): ICroupier;
	    private getTicketFromShape;
	    private nextTicketId;
	    private _prefix;
	    private _formatAmount;
	    private _symbolToString;
	    private _stringToSymbol;
	}
	export function generateUsrSql(infos: ICroupierUsrInfos): string;
}

declare module "@gdk/croupier/cli" {
	import * as program from "commander";
	import type { ICroupier } from "@gdk/backutils";
	export function run(): void;
	export function getCli(): program.Command;
	export type CommanderAction = (...args: any[]) => any;
	export function croupierGenerateForConfig(confFile: string, context: {
	    name: string;
	    version: string;
	}, options?: {
	    override: boolean;
	}): ICroupier;
}

declare module "@gdk/croupier/test/baseCroupierTester" {
	import type { ICroupierConfig, ITicket, IWinFactor } from "@gdk/backutils";
	export abstract class ABaseCroupierTester {
	    protected readonly croupier: ICroupierConfig;
	    protected readonly tickets: ITicket[];
	    protected constructor(serviceName: string);
	    protected abstract symbolToShape(symbol: string): string;
	    protected abstract symbolToFactor(symbol: string): IWinFactor;
	    /**
	     * Run ticket tests
	     */
	    test(): void;
	    protected testSymbolShapes(): void;
	    protected testSymbolFactors(): void;
	    protected static testSymbolLength(symbol: string): void;
	}
}

declare module "@gdk/croupier/tools/random" {
	/**
	 * Shuffles an array
	 * @param values T[]
	 * @return a new array shuffled (does not touch the original array)
	 */
	export function shuffle<T>(values: T[]): T[];
	/**
	 * Shuffles an array in place
	 * @param values T[]
	 * @return the array passed in params which has been shuffled
	 */
	export function shuffleInPlace<T>(values: T[]): T[];
}

declare module "@gdk/croupier/tools/universe" {
	export enum EUniverseType {
	    range = "range",
	    weight = "weight"
	}
	export interface IWeightedValue<T> {
	    value: T;
	    weight?: number;
	}
	export class WeightedValue<T> implements IWeightedValue<T> {
	    private _value;
	    private _weight;
	    private _labels;
	    constructor(e: IWeightedValue<T>);
	    get value(): T;
	    get weight(): number;
	    set weight(w: number);
	    /**
	     * add some weight to an element
	     * @param quantity weight to add to the element
	     */
	    add(quantity: number): void;
	    /**
	     * remove some weight to an element
	     * @param quantity weight to remove
	     */
	    remove(quantity: number): void;
	    /**
	     * Freeze the
	     */
	    save(name?: string): void;
	    /**
	     * Reset
	     */
	    restore(name?: string): void;
	}
	export interface IUniverseOptions {
	    autoRefill: boolean;
	}
	export class Universe<T> {
	    protected autoRefill: boolean;
	    protected values: Array<WeightedValue<T>>;
	    protected _totalWeight: number;
	    constructor();
	    constructor(values: Array<IWeightedValue<T>>, options?: IUniverseOptions);
	    constructor(min: number, max: number, step?: number, options?: IUniverseOptions);
	    /**
	     * Returns the size of an universe (number of elements including weights)
	     */
	    size(): number;
	    /**
	     * Checks if a specific element is in the unverse
	     */
	    has(value: T): boolean;
	    /**
	     *  Returns the number occurrences of a specific element in a universe
	     */
	    count(value: T): number;
	    /**
	     * add some element to the universe
	     * @param value IWeightedValue
	     */
	    addValue(value: T, count?: number): void;
	    /**
	     * remove some element to the universe
	     * @param value IWeightedValue
	     */
	    removeValue(value: T, count?: number): void;
	    /**
	     * Pick one element in the universe, won't affect the universe itself as element will be replaced in it
	     */
	    sampleOne(): T;
	    /**
	     * Pick several element in the universe, won't affect the universe itself as elements will be replaced in it
	     * @param count number of element to draw
	     */
	    sampleMany(count: number): T[];
	    /**
	     * Draw one element from the universe, the element will be removed from the universe
	     */
	    drawOne(): T;
	    /**
	     * Draw many elements from the universe, the elements will be removed from the universe
	     * @param count
	     */
	    drawMany(count: number): T[];
	    /**
	     * Reset the universe to his original state
	     */
	    save(name?: string): void;
	    /**
	     * Reset the universe to his original state
	     */
	    restore(name?: string): void;
	    private _add;
	    private _remove;
	    private _randIndex;
	}
}

declare module "@gdk/croupier/tools/testHelpers" {
	/// <reference types="node" />
	import type { AssertPredicate } from "assert";
	/**
	 * Ensure given function or method fails with given arguments, with an error matching
	 * given predicate.
	 * If used as a decorator, should be used on a static method.
	 */
	export function proof(description: string, predicate: AssertPredicate, ...args: any[]): any;
}
