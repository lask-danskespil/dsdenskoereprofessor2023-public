import { shuffle, shuffleInPlace } from "../src/tools/random";

import * as _ from "lodash";
import { Universe } from "../src/tools/universe";

const testArray = new Array(50).fill(0).map((e, i) => i);
describe(".shuffle", () => {
	test("should let the original array untouched", () => {
		const a = testArray.slice();
		shuffle(a);
		expect(a.toString() === testArray.toString()).toBeTruthy();
	});

	test("should shuffle", () => {
		const a = testArray.slice();
		const b = shuffle(a);
		expect(b.toString() === a.toString()).toBeFalsy();
		expect(b.length).toBe(a.length);
		for (const e of a) {
			expect(b.indexOf(e)).toBeGreaterThanOrEqual(0);
		}
	});
});

describe(".shuffleInPlace", () => {
	test("should modify the original array", () => {
		const a = testArray.slice();
		shuffleInPlace(a);
		expect(a.toString() === testArray.toString()).toBeFalsy();
	});

	test("should shuffle", () => {
		const a = testArray.slice();
		const b = shuffleInPlace(a);
		expect(b === a).toBeTruthy();
		expect(a.length).toBe(testArray.length);
		for (const e of a) {
			expect(testArray.indexOf(e)).toBeGreaterThanOrEqual(0);
		}
	});
});

describe(".range universe", () => {
	test("should pick an element", () => {
		const N = 10000;
		const U = new Universe<number>(0, 10, 2);
		const res = { 0: 0, 2: 0, 4: 0, 6: 0, 8: 0, 10: 0 };
		for (let i = 0; i < N; i++) {
			res[U.sampleOne()]++;
		}

		expect(_.sum(_.values(res)) === N).toBeTruthy();
		[0, 2, 4, 6, 8, 10].forEach((v) => {
			expect(Math.abs(res[v] - N / 6) / N).toBeLessThan(0.05);
		});
	});
});

describe("universe", () => {
	test("refills by itself with autofill option", () => {
		const universe = new Universe<number>(0, 9, 1, { autoRefill: true });

		// consumes every values in universe
		const values: number[] = [];
		for (let i = 0; i < 10; i++) {
			values.push(universe.drawOne());
		}
		values.sort();
		const expected = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
		expect(values).toEqual(expected);

		// consumes every value, again
		for (let i = 0; i < 10; i++) {
			values.push(universe.drawOne());
		}
		values.sort();
		expected.push(...expected);
		expected.sort();
		expect(values).toEqual(expected);
	});
});
