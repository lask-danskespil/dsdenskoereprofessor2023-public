import * as fs from "fs";
import type { ICroupier } from "@gdk/backutils";
import * as lodash from "lodash";
import { strict as assert } from "assert";
import * as path from "path";

import { validate as validateConfig } from "../src/commands/config";
import { croupierGenerateForConfig } from "../src/cli";
import { listToString } from "./utils";

const DATA_PATH = "./test/convertData";

async function main(): Promise<void> {
	const rawFiles = fs.readdirSync(path.resolve(DATA_PATH), { withFileTypes: true });
	const folders = rawFiles.filter((file) => file.isDirectory()).map((value) => value.name);

	describe(`convert: non regression tests`, () => {
		for (const folder of folders) {
			it(`convertion of ${folder}: non regression test`, async () => nonRegression(folder));
		}
	});
}

function getCroupierSymbols(croupier: ICroupier): string[] {
	return lodash.flattenDeep(croupier.ranks.map((r) => r.tickets.map((t) => t.symbol)));
}

async function nonRegression(folder: string): Promise<void> {
	const config = require(path.resolve(`${DATA_PATH}/${folder}/conf.json`));
	const expectedPath = path.resolve(`${DATA_PATH}/${folder}/croupier.json`);
	const expectedResultJson = fs.readFileSync(expectedPath, "utf8");
	const expectedResult = JSON.parse(expectedResultJson);
	const confPath = path.resolve(`${DATA_PATH}/${folder}/conf.json`);

	const expectError = expectedResult.hasOwnProperty("error");

	let result: any;
	try {
		result = await croupierGenerateForConfig(confPath, { version: "1.0.0", name: folder });
	} catch (error) {
		if (expectError) {
			result = { error: String(error) };
		} else {
			throw error;
		}
	}

	const resultPath = path.resolve(`${DATA_PATH}/${folder}/croupier.actual.json`);
	fs.writeFileSync(resultPath, JSON.stringify(result, null, 4));

	if (expectError) {
		assert(
			new RegExp(expectedResult.error, "i").test(result.error),
			`Expected generator to throw an error matching: "${expectedResult.error}", but ` +
				(result.error !== undefined ? `got this error: ${result.error}` : `didnt fail`)
		);
	} else {
		result.date = expectedResult.date;
		assert(
			JSON.stringify(result, null, 4) === expectedResultJson,
			`converted dealer differs (${resultPath}) from expected dealer (${expectedPath})`
		);

		validateCroupier(result as ICroupier);
	}
}

function validateCroupier(croupier: ICroupier): void {
	for (const rank of croupier.ranks) {
		assert(rank.factor.denominator > 0, `rank ${rank.id} denominator is null`);
	}
	assert(
		typeof croupier.renewal === "number" && !isNaN(croupier.renewal) && croupier.renewal >= 0,
		`renewal is not a correct number: "${croupier.renewal}"`
	);
	const symbols = getCroupierSymbols(croupier);
	assert(symbols.length === lodash.uniq(symbols).length, `at least one symbol is duplicated`);
}

main();
