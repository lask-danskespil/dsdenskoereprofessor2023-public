"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChannelProxy = void 0;
var tools_1 = require("./tools/tools");
var configuration_1 = require("./tools/configuration");
var tags_1 = require("./tools/tags");
var ChannelProxy = /** @class */ (function () {
    /**
     * Constructor
     * @param channelId the id of the channel being created
     */
    function ChannelProxy(bridge, channelId) {
        var _this = this;
        this.bridge = bridge;
        /**
         * Defines the reference to the notifier used to notify the game.
         */
        this.notifier = null;
        this._savedPromises = {};
        // Configure
        var configuration = (0, configuration_1.getBridgeConfiguration)();
        this.hostKey = (0, tools_1.getQueryParameters)()["host-key"] || "";
        var channelOrigins = configuration.channelOrigin || { "": "*" };
        this.channelOrigin = channelOrigins[this.hostKey] || "*";
        this.lotteryCode = configuration.lotteryCode[this.hostKey] || configuration.lotteryCode[""];
        // Misc.
        this.channelId = channelId;
        // Add event listener to listen messages
        window.addEventListener("message", function (ev) { return _this._onMessage(ev); });
        window.addEventListener("unload", function (ev) {
            _this.emitEvent("TAG", {
                eventType: "unload",
            });
        });
    }
    /**
     * Initializes the channel proxy
     */
    ChannelProxy.prototype.initialize = function () {
        return __awaiter(this, void 0, void 0, function () {
            var result, allowedTagsList, gel;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._callWithPromise("__init__", [
                            this.channelId,
                        ])];
                    case 1:
                        result = _a.sent();
                        this.type = result.type === "ITF" ? "ITG" : result.type;
                        this.name = result.name;
                        allowedTagsList = [];
                        if (this.bridge.configuration.tags && this.bridge.configuration.tags.allowedTagsList) {
                            allowedTagsList =
                                this.bridge.configuration.tags.allowedTagsList[this.lotteryCode] ||
                                    this.bridge.configuration.tags.allowedTagsList;
                        }
                        if (this.bridge.configuration.tags && this.bridge.configuration.tags.gameExclusionList) {
                            gel = this.bridge.configuration.tags.gameExclusionList[this.lotteryCode] ||
                                this.bridge.configuration.tags.gameExclusionList;
                            if (gel && Array.isArray(gel) && gel.indexOf(this.name) !== -1) {
                                allowedTagsList = []; // exclude all
                            }
                        }
                        this.tags = new tags_1.Tags(this.bridge.configuration.tags, this.type, this.name, allowedTagsList);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets the new notifier to use to listen the notifications of the host.
     * @param notifier defines the reference to the notifier listening the notifications.
     */
    ChannelProxy.prototype.setNotifier = function (notifier) {
        this.notifier = notifier;
        this._call("setNotifier");
    };
    ChannelProxy.prototype.executeAction = function (actionId, parameters) {
        if (actionId === "OPEN_POPUP") {
            if (parameters.code === "BetError.999") {
                return this._callWithPromise("executeAction", [actionId, parameters]);
            }
            else {
                throw new Error("Not implemented yet.");
            }
        }
        else if (actionId === "TAG") {
            // terrible but TAGS are on emitEvent and com calls executeAction...
            this.emitEvent("TAG", parameters);
            return;
        }
        return this._callWithPromise("executeAction", [actionId, parameters]);
    };
    /**
     * Emit an event
     * @param eventType Event type
     * @param eventData Event data
     */
    ChannelProxy.prototype.emitEvent = function (eventType, eventData) {
        if (eventType === "DIMENSIONS" && window.opener) {
            var paddingWidth = window.outerWidth - window.innerWidth;
            var paddingHeight = window.outerHeight - window.innerHeight;
            window.resizeTo(eventData.width + paddingWidth, eventData.height + paddingHeight);
        }
        if (eventType === "TAG" && this.tags && eventData) {
            var tag = this.tags.formatTag(eventData);
            if (this.bridge.configuration.tags && this.bridge.configuration.tags.log) {
                // Log tracking here instead of in framework
                // eslint-disable-next-line no-console
                console.debug("[TRACK]", this.tags.formatTagForLog(tag));
            }
            var force = tag.eventType === "unload" ||
                (tag.eventType === "view" &&
                    tag.viewInfo &&
                    tag.viewInfo.name === "result" &&
                    tag.viewInfo.state === "didDisappear");
            this.tags.send(tag, force);
            eventData = tag;
        }
        if (["PREBET", "GAME_END_HOOK", "RESUME_HOOK"].includes(eventType)) {
            return this._callWithPromise("emitEvent", [eventType, eventData]);
        }
        else {
            this._call("emitEvent", [eventType, eventData]);
        }
    };
    /**
     * Sends the tag for a request params event.
     * @param requestConfig
     */
    ChannelProxy.prototype.emitRequestParamsTag = function (requestConfig) {
        var _a;
        this.emitEvent("TAG", {
            eventType: "requestParams",
            event: requestConfig.eventTag || "unknown",
            extraData: (_a = requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.extraTagData) === null || _a === void 0 ? void 0 : _a.request,
            requestConfig: {
                baseUrl: requestConfig.baseURL,
                url: requestConfig.url,
                data: requestConfig.data,
                headers: requestConfig.headers,
                method: requestConfig.method,
            },
        });
    };
    /**
     * Sends the tag for a request response event.
     * @param requestConfig
     * @param requestResponse
     */
    ChannelProxy.prototype.emitRequestResponseTag = function (requestConfig, requestResponse) {
        var _a;
        this.emitEvent("TAG", {
            eventType: "requestResponse",
            event: requestConfig.eventTag || "unknown",
            extraData: (_a = requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.extraTagData) === null || _a === void 0 ? void 0 : _a.response,
            requestConfig: {
                baseUrl: requestConfig.baseURL,
                url: requestConfig.url,
                data: requestConfig.data,
                headers: requestConfig.headers,
                method: requestConfig.method,
            },
            requestResponse: {
                data: requestResponse.data,
                status: requestResponse.status,
                headers: requestResponse.headers,
            },
        });
    };
    /**
     * Sends the tag for a request error event.
     * @param requestConfig
     * @param requestResponse
     */
    ChannelProxy.prototype.emitRequestErrorTag = function (requestConfig, requestResponse) {
        var _a;
        this.emitEvent("TAG", {
            eventType: "requestError",
            event: requestConfig.eventTag || "unknown",
            extraData: (_a = requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.extraTagData) === null || _a === void 0 ? void 0 : _a.response,
            requestConfig: {
                baseUrl: requestConfig.baseURL,
                url: requestConfig.url,
                data: requestConfig.data,
                headers: requestConfig.headers,
                method: requestConfig.method,
            },
            requestResponse: {
                data: requestResponse.data,
                status: requestResponse.status,
                headers: requestResponse.headers,
            },
        });
    };
    /**
     * Request the game mode to be updated
     * @param gameMode Game mode
     * @return Promise that resolves to the new game mode
     */
    ChannelProxy.prototype.updateGameMode = function (gameMode) {
        return this._callWithPromise("updateGameMode", [gameMode]);
    };
    /**
     * Get the current game mode
     * @return Promise that resolves to the current game mode
     */
    ChannelProxy.prototype.getGameMode = function () {
        return this._callWithPromise("getGameMode", []);
    };
    /**
     * Get information about the user
     * @param options IStateInformation
     *   - forceAuthenticate? : If true, require the user to be signed in before resolving the promise (default false)
     *   - sessionTokenType? : If provided, require a session token to be exchanged
     *   - state? : IF state for session creation
     *   - redirectUrl? : string
     * @return Promise that resolves to information about the user or null if the user is not signed in (if sessionTokenType is provided and the host does not perform the token exchange with the target, the sessionToken field is filled in the user information)
     */
    ChannelProxy.prototype.getUserInformation = function (options) {
        return this._callWithPromise("getUserInformation", [
            options.forceAuthenticate,
            options.platformSessionType,
            options,
        ]);
    };
    /**
     * Get information about the user's purse(s)
     * @param force wether or not the purse should be retrieved absolutely from the channel.
     * @return Promise that resolves to information about the user's purse(s)
     */
    ChannelProxy.prototype.getPurseInformation = function (force) {
        if (!force && this.bridge.displayedAmount) {
            return Promise.resolve(this.bridge.displayedAmount);
        }
        else {
            return this._callWithPromise("getPurseInformation", []);
        }
    };
    /**
     * Get information about the locale
     * @return Promise that resolves to information about the locale
     * @legacy
     */
    ChannelProxy.prototype.getLocaleInformation = function () {
        return this._callWithPromise("getLocaleInformation", []);
    };
    /**
     * Get the game configuration
     * @param type Guest type
     * @param name Guest name
     * @return Promise that resolves to the game configuration
     * @legacy
     */
    ChannelProxy.prototype.getGameConfiguration = function (type, name) {
        return this._callWithPromise("getGameConfiguration", [type, name]);
    };
    /**
     * Get information about a guest
     * @param type Guest type
     * @param name Guest name
     * @return Promise that resolves to the game information
     */
    ChannelProxy.prototype.getGameInformation = function (type, name) {
        return this._callWithPromise("getGameInformation", [type, name]);
    };
    /**
     * Get information about the host
     * @return Promise that resolves to information about the host
     */
    ChannelProxy.prototype.getHostInformation = function () {
        return this._callWithPromise("getHostInformation");
    };
    /**
     * LEGACY : Mask the user's purse
     * @param mask Mask
     * @return Promise that resolves to the updated purse information along with a mask identifier
     * @deprecated
     */
    ChannelProxy.prototype.maskPurse = function (mask) {
        return this._callWithPromise("maskPurse", [mask]);
    };
    /**
     * LEGACY : Clear a purse mask
     * @param maskId Mask identifier obtained from maskPurse()
     * @return Promise that resolves to the updated purse information
     * @deprecated
     */
    ChannelProxy.prototype.clearPurse = function (maskId) {
        return this._callWithPromise("clearPurse", [maskId]);
    };
    /**
     * Sends the given direct message to the host without waiting for a response
     * @param functionName the function the host should execute
     * @param parameters the parameters to send with the message
     */
    ChannelProxy.prototype._call = function (functionName, parameters) {
        this._sendMessage({
            functionName: functionName,
            channelId: this.channelId,
            parameters: parameters,
        });
    };
    /**
     * Sends a message to the host and saves the promise to be retrieved on the host answers
     * @param functionName the function the host should execute
     * @param parameters the parameters to send with the message
     */
    ChannelProxy.prototype._callWithPromise = function (functionName, parameters) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._sendMessage({
                channelId: _this.channelId,
                functionName: functionName,
                parameters: parameters,
                id: _this._savePromise({ resolve: resolve, reject: reject }),
            });
        });
    };
    /**
     * Sends the given message to the host
     * @param message
     */
    ChannelProxy.prototype._sendMessage = function (message) {
        (window.opener || window.parent || window).postMessage(message, this.channelOrigin);
    };
    /**
     * Saves the given promise until the host answers in order to resolve the given promise
     * @param promise the promise to save until it is resolved
     */
    ChannelProxy.prototype._savePromise = function (promise) {
        var id = (0, tools_1.uid)();
        this._savedPromises[id] = promise;
        return id;
    };
    /**
     * On the window receives a message from the host
     * @param message the message sent from the host
     */
    ChannelProxy.prototype._onMessage = function (message) {
        var data = message.data;
        // Jackpot?
        if (data.channelId === "__jackpot__") {
            return this.bridge.jackpot.handleMessage(message);
        }
        // Compute
        if (!data || typeof data !== "object" || !("result" in data)) {
            return;
        }
        if (data.id === -1 && this.notifier) {
            var notification = data.result;
            if (this.notifier[notification.type]) {
                this.notifier[notification.type].call(this.notifier, notification.data);
            }
            else {
                // eslint-disable-next-line no-console
                console.warn("Unknown notification type: \"".concat(notification.type, "\""), notification);
            }
            return;
        }
        var promise = this._savedPromises[data.id];
        if (!promise) {
            // eslint-disable-next-line no-console
            return console.error("No promise saved with id \"".concat(data.id, "\", result ").concat(data.result));
        }
        delete this._savedPromises[data.id];
        if (data.error) {
            promise.reject(data.result);
        }
        else {
            promise.resolve(data.result);
        }
    };
    return ChannelProxy;
}());
exports.ChannelProxy = ChannelProxy;
//# sourceMappingURL=channel.js.map