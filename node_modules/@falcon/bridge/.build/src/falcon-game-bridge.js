"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bridge = exports.EGameMode = void 0;
var blacklist_1 = require("@gdk/blacklist");
var tools_1 = require("./tools/tools");
var configuration_1 = require("./tools/configuration");
var channel_1 = require("./channel");
var uuid_1 = require("./tools/uuid");
var falcon_error_1 = require("./tools/falcon-error");
var jackpot_1 = require("./jackpot/jackpot");
var EGameMode;
(function (EGameMode) {
    EGameMode["demo"] = "DEMO";
    EGameMode["normal"] = "NORMAL";
})(EGameMode = exports.EGameMode || (exports.EGameMode = {}));
/**
 * main class which contains the host channel, the platform, etc.
 */
var Bridge = /** @class */ (function () {
    /**
     * Constructor.
     */
    function Bridge() {
        /**
         * Current key-value object from the current search value of the window (query parameters)
         */
        this.queryParameters = (0, tools_1.getQueryParameters)();
        /**
         * The current configuration of the bridge and game
         */
        this.configuration = null;
        /**
         * Development configuration. Typically used for local development.
         */
        this.developmentConfiguration = null;
        /**
         * The configuration of the current game.
         */
        this.gameConfiguration = null;
        /**
         * Channel proxy used to communicate with the host
         */
        this.channel = null;
        /**
         * Platform implementation used to communicate with the platform.
         */
        this.platform = null;
        /**
         * The old jackpot reference used to draw the jackpot applet when the player wins the jackpot.
         */
        this.jackpot = null;
        /**
         * The jackpot reference used to draw the jackpot widget
         */
        this.superJackpot = null;
        /**
         * Defines the current amount being displayed for the purse.
         */
        this.displayedAmount = null;
        /**
         * Bridge locales wordings
         */
        this.locales = {};
        /**
         * Guest factory reference. Will exist only if the game to load is defined in the compatibility JSON.
         */
        this.factory = null;
        /**
         * Mocks configuration
         */
        this.mocksConfiguration = null;
        this._iterator = 0;
        // Empty
    }
    /**
     * Initializes the bridge. It will:
     * - Load the current bridge configuration
     * - Create the communication channel
     * - Loads the guest implementation
     * @param config the optional configuration used to initialize the bridge.
     */
    Bridge.initialize = function (config) {
        var _a, _b;
        if (config === void 0) { config = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var configuration, platform, _c, _d, _e, _f, openGameParameters, gameMode, gameConfig, blacklisted, up_1, locales, msg, Jackpot_1, _g, _h, gamePath, _j;
            var _this = this;
            return __generator(this, function (_k) {
                switch (_k.label) {
                    case 0:
                        // Create instance
                        this._instance = new Bridge();
                        this._instance.developmentConfiguration = config;
                        return [4 /*yield*/, (0, tools_1.loadJSON)("".concat(config.basePath || "./", "assets/").concat(config.configFileName || "configuration.json"))];
                    case 1:
                        configuration = _k.sent();
                        this._instance.configuration = configuration;
                        (0, configuration_1.setConfiguration)(configuration);
                        // ANCHOR Channel
                        this._instance.channel =
                            config.channel || new channel_1.ChannelProxy(this._instance, this._instance.queryParameters.channel);
                        return [4 /*yield*/, this._instance.channel.initialize()];
                    case 2:
                        _k.sent();
                        platform = this._instance.getOpenGameParameters().platform || configuration.platform || "itf";
                        _c = platform;
                        switch (_c) {
                            case "gdk": return [3 /*break*/, 3];
                            case "itf": return [3 /*break*/, 5];
                            case "boi": return [3 /*break*/, 7];
                        }
                        return [3 /*break*/, 9];
                    case 3:
                        _d = this._instance;
                        return [4 /*yield*/, Promise.resolve().then(function () { return require(/* webpackChunkName: "platforms/platform-gdk" */ "./platforms/platform-gdk"); })];
                    case 4:
                        _d.platform = new (_k.sent()).default(this._instance);
                        return [3 /*break*/, 10];
                    case 5:
                        _e = this._instance;
                        return [4 /*yield*/, Promise.resolve().then(function () { return require(/* webpackChunkName: "platforms/platform-itf" */ "./platforms/platform-itf"); })];
                    case 6:
                        _e.platform = new (_k.sent()).default(this._instance);
                        return [3 /*break*/, 10];
                    case 7:
                        _f = this._instance;
                        return [4 /*yield*/, Promise.resolve().then(function () { return require(/* webpackChunkName: "platforms/platform-boi" */ "./platforms/platform-boi"); })];
                    case 8:
                        _f.platform = new (_k.sent()).default(this._instance);
                        return [3 /*break*/, 10];
                    case 9: throw new Error("Unknown platform type: \"".concat(platform, "\""));
                    case 10:
                        openGameParameters = this._instance.getOpenGameParameters();
                        gameMode = openGameParameters.gameMode;
                        return [4 /*yield*/, this._instance.getCurrentGameConfiguration()];
                    case 11:
                        gameConfig = _k.sent();
                        if (gameConfig.schemaVersion === 2) {
                            if (openGameParameters.theme && gameConfig.assets.themes[openGameParameters.theme]) {
                                gameConfig.game.theme = openGameParameters.theme;
                            }
                            if (openGameParameters.language && gameConfig.assets.i18n[openGameParameters.language]) {
                                gameConfig.locale = openGameParameters.language;
                            }
                            if (openGameParameters.soundEnabled !== undefined) {
                                gameConfig.game.parameters.soundEnabled = openGameParameters.soundEnabled;
                            }
                            // adapt the gameConfig for gdk3 compatibility
                            gameConfig.lotteryGameCode = gameConfig.technicalName;
                            gameConfig.selectedLocale = gameConfig.locale;
                        }
                        else if (gameConfig.schemaVersion === 3) {
                            if (openGameParameters.theme &&
                                gameConfig.gameDescription.assets.themes[openGameParameters.theme]) {
                                gameConfig.selectedTheme = openGameParameters.theme;
                            }
                            if (openGameParameters.language &&
                                gameConfig.gameDescription.assets.i18n[openGameParameters.language]) {
                                gameConfig.selectedLocale = openGameParameters.language;
                            }
                            if (openGameParameters.soundEnabled !== undefined) {
                                if (gameConfig.gameParameters) {
                                    gameConfig.gameParameters.soundEnabled = openGameParameters.soundEnabled;
                                }
                                else {
                                    gameConfig.gameParameters = {
                                        soundEnabled: openGameParameters.soundEnabled,
                                    };
                                }
                            }
                        }
                        if (!(configuration.blacklist && configuration.blacklist.enabled)) return [3 /*break*/, 18];
                        return [4 /*yield*/, this._instance._isBlacklisted()];
                    case 12:
                        blacklisted = _k.sent();
                        if (!blacklisted) return [3 /*break*/, 18];
                        _k.label = 13;
                    case 13:
                        _k.trys.push([13, 15, , 17]);
                        return [4 /*yield*/, this._instance.executeAction("OPEN_POPUP", { code: "blacklist" })];
                    case 14:
                        _k.sent();
                        return [3 /*break*/, 17];
                    case 15:
                        up_1 = _k.sent();
                        return [4 /*yield*/, this._instance.loadLocales(this._instance.gameConfiguration.selectedLocale)];
                    case 16:
                        locales = _k.sent();
                        msg = locales.bridge.error.blacklisted || "Device or browser not supported by this game.";
                        alert(msg);
                        return [3 /*break*/, 17];
                    case 17: return [2 /*return*/];
                    case 18:
                        if (!gameMode) return [3 /*break*/, 20];
                        return [4 /*yield*/, this._instance.updateGameMode(gameMode)];
                    case 19:
                        _k.sent();
                        return [3 /*break*/, 22];
                    case 20:
                        if (!(!gameConfig.demo || !gameConfig.demo.enabled)) return [3 /*break*/, 22];
                        return [4 /*yield*/, this._instance.updateGameMode(EGameMode.normal)];
                    case 21:
                        _k.sent();
                        _k.label = 22;
                    case 22:
                        if (!(platform !== "boi" && gameConfig.jackpots && gameConfig.jackpots.configurationName)) return [3 /*break*/, 25];
                        return [4 /*yield*/, Promise.resolve().then(function () { return require(/* webpackChunkName: "jackpot" */ "@gdk/super-jackpot"); })];
                    case 23:
                        Jackpot_1 = (_k.sent()).Jackpot;
                        _g = this._instance;
                        return [4 /*yield*/, Jackpot_1.instanciate({
                                lotteryCode: this._instance.channel.lotteryCode,
                                lotteryGameCode: gameConfig.lotteryGameCode,
                                lotteryGameName: this._instance.channel.name,
                                stakes: gameConfig.stakes,
                                baseUrl: (_a = configuration.paths.applications[configuration.platform.toUpperCase()]) !== null && _a !== void 0 ? _a : ".",
                                locale: gameConfig.selectedLocale,
                                defaultParams: {
                                    banner: {
                                        withMention: true,
                                    },
                                    banner_splash: {
                                        disableInteractive: true,
                                    },
                                },
                            })];
                    case 24:
                        _g.superJackpot = _k.sent();
                        // ANCHOR Jackpot EventListener
                        this._instance.superJackpot.div.addEventListener("jackpot", function (e) {
                            switch (e.detail) {
                                case "JACKPOT_SHOW_RULES":
                                    _this._instance.channel.notifier.notifyPause({
                                        isPaused: true,
                                        reason: "jackpot_rules",
                                    });
                                    break;
                                case "JACKPOT_SHOW_ERROR":
                                    _this._instance.channel.notifier.notifyPause({
                                        isPaused: true,
                                        reason: "jackpot_error",
                                    });
                                    break;
                                case "JACKPOT_HIDE_RULES":
                                    _this._instance.channel.notifier.notifyPause({
                                        isPaused: false,
                                        reason: "jackpot_rules",
                                    });
                                    break;
                                case "JACKPOT_HIDE_ERROR":
                                    _this._instance.channel.notifier.notifyPause({
                                        isPaused: false,
                                        reason: "jackpot_error",
                                    });
                                    break;
                                case "JACKPOT_ADHERENCE_CLICK":
                                    _this._instance.channel.executeAction("SUPERJACKPOT_RULES");
                                    break;
                            }
                        });
                        _k.label = 25;
                    case 25:
                        if (!(gameConfig.factory && gameConfig.factory.name)) return [3 /*break*/, 35];
                        _h = gameConfig.factory.name;
                        switch (_h) {
                            case "babylonjs-factory-example": return [3 /*break*/, 26];
                            case "legacy-itg-html5": return [3 /*break*/, 28];
                            case "legacy-mtr": return [3 /*break*/, 30];
                        }
                        return [3 /*break*/, 32];
                    case 26: return [4 /*yield*/, Promise.resolve().then(function () { return require(
                        /* webpackChunkName: "factories/babylonjs-factory-example" */ "./factories/babylonjs-factory-example"); })];
                    case 27:
                        _k.sent();
                        return [3 /*break*/, 34];
                    case 28: return [4 /*yield*/, Promise.resolve().then(function () { return require(
                        /* webpackChunkName: "factories/legacy-itg-html5" */ "./factories/legacy-itg-html5"); })];
                    case 29:
                        _k.sent();
                        return [3 /*break*/, 34];
                    case 30: return [4 /*yield*/, Promise.resolve().then(function () { return require(/* webpackChunkName: "factories/legacy-mtr" */ "./factories/legacy-mtr"); })];
                    case 31:
                        _k.sent();
                        return [3 /*break*/, 34];
                    case 32: return [4 /*yield*/, Promise.resolve().then(function () { return require(
                        /* webpackIgnore: true */ "".concat((_b = config.basePath) !== null && _b !== void 0 ? _b : "./", "factories/").concat(gameConfig.factory.name)); })];
                    case 33:
                        _k.sent();
                        _k.label = 34;
                    case 34:
                        this._instance.factory = new factories.default(this._instance, gameConfig.factory.parameters, this._instance.channel);
                        // The factory will load the game and do stuff it needs. So just return
                        return [2 /*return*/];
                    case 35: return [4 /*yield*/, this._instance.getIndexPath()];
                    case 36:
                        gamePath = _k.sent();
                        _k.label = 37;
                    case 37:
                        _k.trys.push([37, 39, , 41]);
                        return [4 /*yield*/, System.import(gamePath)];
                    case 38:
                        _k.sent();
                        return [3 /*break*/, 41];
                    case 39:
                        _j = _k.sent();
                        return [4 /*yield*/, Promise.resolve().then(function () { return require(/* webpackIgnore: true */ gamePath); })];
                    case 40:
                        _k.sent();
                        return [3 /*break*/, 41];
                    case 41:
                        if (!(configuration.mocks && configuration.mocks[this._instance.channel.type])) return [3 /*break*/, 43];
                        this._instance.mocksConfiguration =
                            configuration.mocks[this._instance.channel.type][this._instance.channel.hostKey] ||
                                configuration.mocks[this._instance.channel.type][""];
                        if (!(this._instance.mocksConfiguration && this._instance.mocksConfiguration.enabled)) return [3 /*break*/, 43];
                        return [4 /*yield*/, Promise.resolve().then(function () { return require(/* webpackChunkName: "mock" */ "../assets/mock"); })];
                    case 42:
                        _k.sent();
                        if (window["setMock"]) {
                            window["setMock"](this._instance, this._instance.channel.type, this._instance.channel.name);
                        }
                        _k.label = 43;
                    case 43: return [2 /*return*/];
                }
            });
        });
    };
    Bridge.prototype._isBlacklisted = function () {
        return __awaiter(this, void 0, void 0, function () {
            var games, game, client, isClientBlacklisted, error, isBlacklistActive;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getCurrentGameConfiguration()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.platform.getCompatibility(this.gameConfiguration.lotteryGameCode)];
                    case 2:
                        games = _a.sent();
                        if (!games || !games.length) {
                            return [2 /*return*/, false];
                        }
                        game = games.find(function (game) {
                            return game.code === (_this.gameConfiguration.lotteryGameCode || _this.channel.name) &&
                                game.engineCode === _this.channel.type;
                        });
                        if (!game) {
                            return [2 /*return*/, false];
                        }
                        client = new blacklist_1.UAParserEnvironment({ channelName: this.queryParameters.lotteryChannel });
                        isClientBlacklisted = false;
                        error = null;
                        try {
                            isClientBlacklisted = !(0, blacklist_1.isAllowedByList)(game.compatibility || {}, client);
                        }
                        catch (e) {
                            error = e.message;
                        }
                        isBlacklistActive = Boolean(this.configuration.blacklist && this.configuration.blacklist.active);
                        if (isClientBlacklisted) {
                            this.emitEvent("TAG", {
                                eventType: "blacklist",
                                client: { ua: client.toJSON() ? client.toJSON().ua : "unknown" },
                                isClientBlacklisted: isClientBlacklisted,
                                isBlacklistActive: isBlacklistActive,
                                //compatibility: game.compatibility || {},
                                error: error,
                            });
                        }
                        return [2 /*return*/, isClientBlacklisted && isBlacklistActive];
                }
            });
        });
    };
    /**
     * Returns the current bridge instance.
     */
    Bridge.getBridge = function () {
        return this._instance;
    };
    /**
     * Displays the old jackpot revelation according to the given jackpot result.
     * @param jackpotResult the jackpot result object that comes from the bet response.
     */
    Bridge.prototype.displayJackpotRevelation = function (jackpotResult) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.jackpot) {
                            this.jackpot = new jackpot_1.Jackpot(this);
                        }
                        return [4 /*yield*/, this.jackpot.displayJackpotRevelation(jackpotResult)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Bridge.prototype.executeAction = function (actionId, parameters) {
        return this.channel.executeAction(actionId, parameters);
    };
    Bridge.prototype.emitEvent = function (eventType, eventData) {
        return __awaiter(this, void 0, void 0, function () {
            var bridge;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        bridge = Bridge.getBridge();
                        if (!(bridge.superJackpot && eventType.startsWith("JACKPOT"))) return [3 /*break*/, 2];
                        return [4 /*yield*/, bridge.superJackpot.onEvent(eventType, eventData)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2: return [2 /*return*/, this.channel.emitEvent(eventType, eventData)];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns the path of the framework.
     */
    Bridge.prototype.getCurrentGameConfiguration = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!!this.gameConfiguration) return [3 /*break*/, 2];
                        _a = this;
                        return [4 /*yield*/, this.platform.getCurrentGameConfig()];
                    case 1:
                        _a.gameConfiguration = _b.sent();
                        _b.label = 2;
                    case 2: 
                    // this.gameConfiguration.betMode = "application/vnd.fgs.instant.ticket.betManualClaim-1+json";
                    return [2 /*return*/, this.gameConfiguration];
                }
            });
        });
    };
    /**
     * Returns the path of the framework.
     */
    Bridge.prototype.getFrameworkPath = function () {
        return this._computePath((0, configuration_1.getBridgeConfiguration)().paths.framework);
    };
    /**
     * Returns the path of the game directory.
     */
    Bridge.prototype.getGamePath = function () {
        return __awaiter(this, void 0, void 0, function () {
            var gameConf, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getCurrentGameConfiguration()];
                    case 1:
                        gameConf = _b.sent();
                        _a = "".concat;
                        return [4 /*yield*/, this._computePathV3((0, configuration_1.getBridgeConfiguration)().paths.gamesV3)];
                    case 2: return [2 /*return*/, _a.apply("", [_b.sent()]).replace(/index\.js|loader\.js/g, "")];
                }
            });
        });
    };
    /**
     * Returns the path of the game index.
     */
    Bridge.prototype.getIndexPath = function () {
        return __awaiter(this, void 0, void 0, function () {
            var gameConf, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getCurrentGameConfiguration()];
                    case 1:
                        gameConf = _b.sent();
                        if (!(gameConf.schemaVersion === 3)) return [3 /*break*/, 3];
                        _a = "".concat;
                        return [4 /*yield*/, this._computePathV3((0, configuration_1.getBridgeConfiguration)().paths.gamesV3)];
                    case 2: return [2 /*return*/, _a.apply("", [_b.sent()])];
                    case 3: return [2 /*return*/, this._computePath((0, configuration_1.getBridgeConfiguration)().paths.guests.default ||
                            this.getGameConfV2Path().replace("game.conf.json", "index.js"))];
                }
            });
        });
    };
    /**
     * Returns the path of the game configuration file.
     */
    Bridge.prototype.getGameConfPath = function () {
        return __awaiter(this, void 0, void 0, function () {
            var gamePath;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getGamePath()];
                    case 1:
                        gamePath = _a.sent();
                        return [2 /*return*/, "".concat(gamePath, "/index.js")];
                }
            });
        });
    };
    /**
     * Returns the path of the game configuration for a v2 file.
     */
    Bridge.prototype.getGameConfV2Path = function () {
        return this._computePath((0, configuration_1.getBridgeConfiguration)().paths.gameConf);
    };
    /**
     * Returns the current paths combining the gameconf and framework paths.
     * @legacy with bridge 1.x for loader.js to work.
     */
    Bridge.prototype.getPaths = function () {
        return {
            configPath: this.getGameConfV2Path(),
            frameworkPath: this.getFrameworkPath(),
            gamePath: this.getGameConfV2Path().replace("game.conf.json", ""),
        };
    };
    /**
     * Returns the current paths combining the gameconf and framework paths.
     */
    Bridge.prototype.getComputedPaths = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = {};
                        return [4 /*yield*/, this.getGameConfPath()];
                    case 1:
                        _a.configPath = _b.sent(),
                            _a.frameworkPath = this.getFrameworkPath();
                        return [4 /*yield*/, this.getGamePath()];
                    case 2: return [2 /*return*/, (_a.gamePath = _b.sent(),
                            _a)];
                }
            });
        });
    };
    /**
     * Loads the given script and adds in the document's head
     * @param url the url of the script to load
     * @legacy with bridge 1.x for loader.js to work.
     */
    Bridge.prototype.loadScripts = function (urls) {
        return __awaiter(this, void 0, void 0, function () {
            var promises;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = urls.map(function (u) { return (0, tools_1.loadScript)(u); });
                        return [4 /*yield*/, Promise.all(promises)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Load JSON file directly.
     * @param url the url of the json to load.
     * @return Promise that resolves once the json is loaded and parsed.
     * @legacy with bridge 1.x for loader.js to work.
     */
    Bridge.prototype.loadJSON = function (url) {
        return (0, tools_1.loadJSON)(url);
    };
    /**
     * Loads the locales of the given language. Returns a JSON containing global locales.
     * @param language the language type (fr-FR, en-US, etc.)
     */
    Bridge.prototype.loadLocales = function (language) {
        return __awaiter(this, void 0, void 0, function () {
            var locales;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.locales[language]) {
                            return [2 /*return*/, this.locales[language]];
                        }
                        return [4 /*yield*/, this.loadJSON("".concat(this.developmentConfiguration.basePath || "", "./locales/").concat(language, ".json"))];
                    case 1:
                        locales = _a.sent();
                        this.locales[language] = locales;
                        return [2 /*return*/, locales];
                }
            });
        });
    };
    /**
     * Just get information about the user
     * @return Promise that resolves to information about the user or null if the user is not signed in
     */
    Bridge.prototype.getUserInformation = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.getUserInformation({})];
            });
        });
    };
    /**
     * Notify the lottery that the player wants to buy a ticket with real money.
     * The lottery has the ability to check wether or not the player has sufficident funds in his purse.
     * If not the lottery should ask to the player to credit (with an overlay).
     * In any case it must respond with a promise.
     *  - when fullfiled the game will continue with the bet
     *  - when rejected the game will cancel the bet process
     * @return Promise
     */
    Bridge.prototype.preBet = function (betRequest) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.emitEvent("PREBET", betRequest)];
            });
        });
    };
    /**
     * Request the game mode to be updated
     * @param gameMode Game mode
     * @return Promise that resolves to the new game mode
     */
    Bridge.prototype.updateGameMode = function (gameMode, force) {
        if (force === void 0) { force = false; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b, conf, confDemo, forceAuthenticate, options, _c, userInformation, token, newMode;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, this.getCurrentGameConfiguration()];
                    case 1:
                        if ((_d.sent()).phygital) {
                            return [2 /*return*/, EGameMode.normal];
                        }
                        _a = !force;
                        if (!_a) return [3 /*break*/, 3];
                        _b = gameMode;
                        return [4 /*yield*/, this.getGameMode()];
                    case 2:
                        _a = _b === (_d.sent());
                        _d.label = 3;
                    case 3:
                        if (_a) {
                            // already in the requested demoMode, do nothing
                            return [2 /*return*/, gameMode];
                        }
                        return [4 /*yield*/, this.getCurrentGameConfiguration()];
                    case 4:
                        conf = _d.sent();
                        confDemo = conf.demo;
                        if (gameMode === EGameMode.demo && (!confDemo || !confDemo.enabled)) {
                            throw new falcon_error_1.default("unavailable-demo-mode");
                        }
                        forceAuthenticate = gameMode === EGameMode.demo && !confDemo.forceAuthentication ? false : true;
                        if (!forceAuthenticate) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.platform.getState(this.channel.lotteryCode)];
                    case 5:
                        _c = _d.sent();
                        return [3 /*break*/, 7];
                    case 6:
                        _c = {};
                        _d.label = 7;
                    case 7:
                        options = _c;
                        options.platformSessionType = (0, configuration_1.getBridgeConfiguration)().platformSessionType;
                        options.forceAuthenticate = forceAuthenticate;
                        return [4 /*yield*/, this.channel.getUserInformation(options)];
                    case 8:
                        userInformation = (_d.sent()) || {};
                        token = userInformation.sessionToken;
                        if (!token) return [3 /*break*/, 10];
                        // creates normal IF authenticated session
                        return [4 /*yield*/, this.platform.createSession(token, false)];
                    case 9:
                        // creates normal IF authenticated session
                        _d.sent();
                        _d.label = 10;
                    case 10:
                        if (!(gameMode === EGameMode.demo)) return [3 /*break*/, 12];
                        // Create the IF demo session
                        return [4 /*yield*/, this.platform.createSession(null, true)];
                    case 11:
                        // Create the IF demo session
                        _d.sent();
                        _d.label = 12;
                    case 12: return [4 /*yield*/, this.channel.updateGameMode(gameMode)];
                    case 13:
                        newMode = _d.sent();
                        return [2 /*return*/, newMode];
                }
            });
        });
    };
    /**
     * Get ticketId to replay if any, null otherwise
     * @return the ticketId to replay
     */
    Bridge.prototype.getTicketIdToReplay = function () {
        if (!this.queryParameters.betId) {
            return null;
        }
        if (/^[0-9]+$/.test(this.queryParameters.betId)) {
            return parseInt(this.queryParameters.betId, 10);
        }
        else {
            return this.queryParameters.betId;
        }
    };
    /**
     * Get QueryParams
     */
    Bridge.prototype.getOpenGameParameters = function () {
        return {
            betId: this.getTicketIdToReplay(),
            skipRules: this.queryParameters.skipRules === "true",
            gameMode: this.queryParameters.gameMode === EGameMode.demo ||
                this.queryParameters.gameMode === EGameMode.normal
                ? this.queryParameters.gameMode
                : undefined,
            lotteryChannel: this.queryParameters.lotteryChannel,
            platform: this.queryParameters.platform,
            soundEnabled: this.queryParameters.soundEnabled === "false"
                ? false
                : this.queryParameters.soundEnabled === "true"
                    ? true
                    : undefined,
            theme: !this.queryParameters.theme ? undefined : this.queryParameters.theme,
            language: !this.queryParameters.language ? undefined : this.queryParameters.language,
            gameSpecificParameters: !this.queryParameters.gameSpecificParameters
                ? null
                : JSON.parse(decodeURIComponent(this.queryParameters.gameSpecificParameters)),
        };
    };
    /**
     * Get the current game mode
     * @return Promise that resolves to the current game mode
     */
    Bridge.prototype.getGameMode = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.getGameMode()];
            });
        });
    };
    Object.defineProperty(Bridge.prototype, "version", {
        /**
         * Get this bridge version
         * @returns Bridge version
         */
        get: function () {
            return this.configuration.version;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Computes the given path to inject bridge path etc. in it
     * @param path the path to compute
     */
    Bridge.prototype._computePath = function (path) {
        return path
            .replace(/%bridgePath%/g, (0, tools_1.getBridgePath)())
            .replace(/%guestType%/g, this.channel.type)
            .replace(/%guestName%/g, this.channel.name);
    };
    /**
     * Computes the given path to inject bridge path etc. in it for games v3
     * @param path the path to compute
     */
    Bridge.prototype._computePathV3 = function (path) {
        return __awaiter(this, void 0, void 0, function () {
            var gameConf;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getCurrentGameConfiguration()];
                    case 1:
                        gameConf = _a.sent();
                        return [2 /*return*/, path
                                .replace(/%bridgePath%/g, (0, tools_1.getBridgePath)())
                                .replace(/%guestType%/g, this.channel.type)
                                .replace(/%guestName%/g, this.channel.name)
                                .replace(/%master%/g, gameConf.masterGameCode)
                                .replace(/%version%/g, gameConf.version)];
                }
            });
        });
    };
    Bridge.prototype.getCorrelationId = function () {
        return "".concat(uuid_1.UUID.get(), "--").concat(++this._iterator);
    };
    Bridge._instance = null;
    return Bridge;
}());
exports.Bridge = Bridge;
//# sourceMappingURL=falcon-game-bridge.js.map