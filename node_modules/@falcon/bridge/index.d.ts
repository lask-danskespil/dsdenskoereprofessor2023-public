// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../@gdk/super-jackpot
//   ../../@gdk/blacklist
//   ../../@falcon/push-client
//   ../../axios

declare module '@falcon/bridge' {
    import { Bridge } from "@falcon/bridge/falcon-game-bridge";
    export { Bridge, EGameMode } from "@falcon/bridge/falcon-game-bridge";
    export { ChannelProxy } from "@falcon/bridge/channel";
    export { getQueryParameters, uid, injectScript, loadScript, loadJSON, loadFile, } from "@falcon/bridge/tools/tools";
    export { IAmount, IDimension, ICurrencyPurse, ECurrencyPurseType } from "@falcon/bridge/typings/common";
    export { IUserInformation, IGameInformation, IGameConfiguration, ILocaleInformation, ITag, IPurseInformation, IPurseMask, IMaskedPurseInformation, IOpenGameParameters, } from "@falcon/bridge/typings/information";
    export { IBetRequest, IBetResult, IService } from "@falcon/bridge/typings/bet";
    export { IHostInformation } from "@falcon/bridge/typings/host";
    export { IPlatform, IPlayerInformation, IJackpotInformation, IItgBetRequest, IItgBetResult, IItgTicket, IItgPrize, EItgPrizeType, IMtpBetLevel, IMtpRoomParamsResult, IMtpEnterRoomRequest, IMtpRoom, IMtpSession, IMtpBetResult, IMtpBetRequest, EPushTransportMechanism, IPushTopic, IPushSettings, } from "@falcon/bridge/typings/platform";
    export * from "@falcon/bridge/typings/mtr";
    export { IHostChannel } from "@falcon/bridge/typings/channel";
    export { IMessage } from "@falcon/bridge/typings/messages";
    export { INotifier } from "@falcon/bridge/typings/notifier";
    export const game: {
        bridge: typeof Bridge;
    };
    const _default: "test";
    export default _default;
}

declare module '@falcon/bridge/falcon-game-bridge' {
    import type { Jackpot, IJackpotConfigurationParams, IJackpotShowBannerParams, IJackpotShowResultParams, IJackpotShowRulesParams } from "@gdk/super-jackpot";
    import { Jackpot as OldJackpot } from "@falcon/bridge/jackpot/jackpot";
    import type { IMessage } from "@falcon/bridge/typings/messages";
    import type { IConfiguration, IMocksConfiguration } from "@falcon/bridge/tools/configuration";
    import type { IFactory } from "@falcon/bridge/typings/factory";
    import type { IItgTicket, IPlatform } from "@falcon/bridge/typings/platform";
    import type { IHostChannel } from "@falcon/bridge/typings/channel";
    import type { IAmount, IDimension, IStringDictionary } from "@falcon/bridge/typings/common";
    import type { IJackpotResult, IBetRequest, IBetResult } from "@falcon/bridge/typings/bet";
    import type { IUserInformation, IGameConfiguration, IOpenGameParameters, IPurseInformation, IGameInformation, ITag } from "@falcon/bridge/typings/information";
    import type { IBoiMtrReplaySession, IMtrReplaySession } from "@falcon/bridge/typings/mtr";
    export enum EGameMode {
            demo = "DEMO",
            normal = "NORMAL"
    }
    export interface IDevelopmentConfiguration {
            /**
                * The base path of the bridge. Typically used for local development.
                */
            basePath?: string;
            /**
                * The configuration file name. Typically used for local development.
                */
            configFileName?: string;
            /**
                * The compatibility file name. Typically used for local development.
                */
            compatibilityFileName?: string;
            /**
                * Custom channel reference. Typically used for local development.
                */
            channel?: IHostChannel;
    }
    /**
        * main class which contains the host channel, the platform, etc.
        */
    export class Bridge {
            /**
                * Current key-value object from the current search value of the window (query parameters)
                */
            queryParameters: IStringDictionary<string>;
            /**
                * The current configuration of the bridge and game
                */
            configuration: IConfiguration;
            /**
                * Development configuration. Typically used for local development.
                */
            developmentConfiguration: IDevelopmentConfiguration;
            /**
                * The configuration of the current game.
                */
            gameConfiguration: IGameConfiguration;
            /**
                * Channel proxy used to communicate with the host
                */
            channel: IHostChannel;
            /**
                * Platform implementation used to communicate with the platform.
                */
            platform: IPlatform;
            /**
                * The old jackpot reference used to draw the jackpot applet when the player wins the jackpot.
                */
            jackpot: OldJackpot;
            /**
                * The jackpot reference used to draw the jackpot widget
                */
            superJackpot: Jackpot;
            /**
                * Defines the current amount being displayed for the purse.
                */
            displayedAmount: IPurseInformation;
            /**
                * Bridge locales wordings
                */
            locales: Record<string, any>;
            /**
                * Guest factory reference. Will exist only if the game to load is defined in the compatibility JSON.
                */
            factory: IFactory;
            /**
                * Mocks configuration
                */
            mocksConfiguration: IMocksConfiguration;
            /**
                * Constructor.
                */
            constructor();
            /**
                * Initializes the bridge. It will:
                * - Load the current bridge configuration
                * - Create the communication channel
                * - Loads the guest implementation
                * @param config the optional configuration used to initialize the bridge.
                */
            static initialize(config?: IDevelopmentConfiguration): Promise<void>;
            /**
                * Returns the current bridge instance.
                */
            static getBridge(): Bridge;
            /**
                * Displays the old jackpot revelation according to the given jackpot result.
                * @param jackpotResult the jackpot result object that comes from the bet response.
                */
            displayJackpotRevelation(jackpotResult: IJackpotResult): Promise<void>;
            /**
                * Execute an action
                * @param actionId Action identifier
                * @param parameters Action-specific parameters
                * @return Promise that resolves to an action-specific value (some actions don't return a promise)
                */
            executeAction(actionId: "CLOSE_GAME"): void;
            executeAction(actionId: "CREDIT" | "GLOBAL_RULES"): Promise<void>;
            executeAction(actionId: "GAME_RULES", parameters: IGameInformation): Promise<void>;
            executeAction(actionId: "OPEN_GAME", parameters: IGameInformation): void;
            executeAction(actionId: "IS_GAME_ENABLED", parameters: IGameInformation): void;
            executeAction(actionId: "OPEN_POPUP", parameters: IMessage): Promise<void>;
            executeAction(actionId: string, parameters?: any): Promise<any> | void;
            /**
                * Emit an event
                * @param eventType Event type
                * @param eventData Event data
                */
            emitEvent(eventType: "DIMENSIONS", eventData: IDimension): void;
            emitEvent(eventType: "TAG", eventData: ITag): void;
            emitEvent(eventType: "HAS_BET", eventData: IBetResult): void;
            emitEvent(eventType: "HAS_CLAIMED", eventData: IBetResult): void;
            emitEvent(eventType: "REPLAY_FINISHED", eventData: IItgTicket | IBoiMtrReplaySession<unknown, unknown> | IMtrReplaySession<unknown, unknown>): void;
            emitEvent(eventType: "PREBET", eventData: IBetRequest): Promise<void>;
            emitEvent(eventType: "SOUND_STATUS", eventData: boolean): void;
            emitEvent(eventType: "GAME_END_HOOK", eventData: {
                    ticket: IItgTicket;
                    stakes: IAmount[];
            }): Promise<undefined | {
                    stake: IAmount;
                    demoMode: boolean;
            }>;
            emitEvent(eventType: "RESUME_HOOK", eventData: IItgTicket): Promise<boolean>;
            emitEvent(eventType: "JACKPOT_CONFIGURE", params: IJackpotConfigurationParams): void;
            emitEvent(eventType: "JACKPOT_SHOW"): void;
            emitEvent(eventType: "JACKPOT_HIDE"): void;
            emitEvent(eventType: "JACKPOT_PAUSE"): void;
            emitEvent(eventType: "JACKPOT_RESUME"): void;
            emitEvent(eventType: "JACKPOT_SHOW_BANNER", params?: IJackpotShowBannerParams): void;
            emitEvent(eventType: "JACKPOT_HIDE_BANNER"): void;
            emitEvent(eventType: "JACKPOT_SHOW_RULES", params?: IJackpotShowRulesParams): Promise<void>;
            emitEvent(eventType: "JACKPOT_HIDE_RULES"): void;
            emitEvent(eventType: "JACKPOT_SHOW_RESULT", params?: IJackpotShowResultParams): Promise<void>;
            emitEvent(eventType: "JACKPOT_HIDE_RESULT"): void;
            emitEvent(eventType: "JACKPOT_SHOW_LOCKSCREEN"): void;
            emitEvent(eventType: "JACKPOT_HIDE_LOCKSCREEN"): void;
            emitEvent(eventType: string, eventData?: any): any;
            /**
                * Returns the path of the framework.
                */
            getCurrentGameConfiguration(): Promise<IGameConfiguration>;
            /**
                * Returns the path of the framework.
                */
            getFrameworkPath(): string;
            /**
                * Returns the path of the game directory.
                */
            getGamePath(): Promise<string>;
            /**
                * Returns the path of the game index.
                */
            getIndexPath(): Promise<string>;
            /**
                * Returns the path of the game configuration file.
                */
            getGameConfPath(): Promise<string>;
            /**
                * Returns the path of the game configuration for a v2 file.
                */
            getGameConfV2Path(): string;
            /**
                * Returns the current paths combining the gameconf and framework paths.
                * @legacy with bridge 1.x for loader.js to work.
                */
            getPaths(): {
                    configPath: string;
                    frameworkPath: string;
                    gamePath: string;
            };
            /**
                * Returns the current paths combining the gameconf and framework paths.
                */
            getComputedPaths(): Promise<{
                    configPath: string;
                    frameworkPath: string;
                    gamePath: string;
            }>;
            /**
                * Loads the given script and adds in the document's head
                * @param url the url of the script to load
                * @legacy with bridge 1.x for loader.js to work.
                */
            loadScripts(urls: string[]): Promise<void>;
            /**
                * Load JSON file directly.
                * @param url the url of the json to load.
                * @return Promise that resolves once the json is loaded and parsed.
                * @legacy with bridge 1.x for loader.js to work.
                */
            loadJSON<T>(url: string): Promise<T>;
            /**
                * Loads the locales of the given language. Returns a JSON containing global locales.
                * @param language the language type (fr-FR, en-US, etc.)
                */
            loadLocales(language: string): Promise<Object>;
            /**
                * Just get information about the user
                * @return Promise that resolves to information about the user or null if the user is not signed in
                */
            getUserInformation(): Promise<IUserInformation>;
            /**
                * Notify the lottery that the player wants to buy a ticket with real money.
                * The lottery has the ability to check wether or not the player has sufficident funds in his purse.
                * If not the lottery should ask to the player to credit (with an overlay).
                * In any case it must respond with a promise.
                *  - when fullfiled the game will continue with the bet
                *  - when rejected the game will cancel the bet process
                * @return Promise
                */
            preBet(betRequest: IBetRequest): Promise<void>;
            /**
                * Request the game mode to be updated
                * @param gameMode Game mode
                * @return Promise that resolves to the new game mode
                */
            updateGameMode(gameMode: string, force?: boolean): Promise<string>;
            /**
                * Get ticketId to replay if any, null otherwise
                * @return the ticketId to replay
                */
            getTicketIdToReplay(): number | string;
            /**
                * Get QueryParams
                */
            getOpenGameParameters(): IOpenGameParameters;
            /**
                * Get the current game mode
                * @return Promise that resolves to the current game mode
                */
            getGameMode(): Promise<string>;
            /**
                * Get this bridge version
                * @returns Bridge version
                */
            get version(): string;
            getCorrelationId(): string;
    }
}

declare module '@falcon/bridge/channel' {
    import type { Bridge } from "@falcon/bridge/falcon-game-bridge";
    import type { IHostChannel } from "@falcon/bridge/typings/channel";
    import type { IGameInformation, IPurseInformation, IUserInformation, ILocaleInformation, IGameConfiguration, IStateInformation, IPurseMask, IMaskedPurseInformation } from "@falcon/bridge/typings/information";
    import type { IHostInformation } from "@falcon/bridge/typings/host";
    import type { IMessage } from "@falcon/bridge/typings/messages";
    import type { INotifier } from "@falcon/bridge/typings/notifier";
    import type { CustomAxiosRequestConfig } from "@falcon/bridge/platforms/platform-itf";
    /**
        * Proxy request
        */
    export interface IProxyRequest {
            channelId?: string;
            functionName: string;
            parameters: any[];
            id?: number;
    }
    /**
        * Proxy response
        */
    export interface IProxyResponse {
            result: any;
            id?: number;
            error?: any;
            channelId?: string;
    }
    /**
        * Initialization result
        */
    export interface IProxyInitializationResult {
            type: string;
            name: string;
    }
    /**
        * Interface used to save promises when sending a message
        * to the host
        */
    export interface ISavedPromise<T> {
            resolve: (data?: T) => void;
            reject: (data?: T) => void;
    }
    export class ChannelProxy implements IHostChannel {
            bridge: Bridge;
            /**
                * the id of the channel being created
                */
            channelId: string;
            /**
                * the origin of the channel to post message
                */
            channelOrigin: string;
            /**
                * the code of the lottery
                */
            lotteryCode: string;
            /**
                * the host key
                */
            hostKey: string;
            /**
                * Guest type
                */
            type: string;
            /**
                * Guest name
                */
            name: string;
            /**
                * Defines the reference to the notifier used to notify the game.
                */
            notifier: INotifier;
            /**
                * Constructor
                * @param channelId the id of the channel being created
                */
            constructor(bridge: Bridge, channelId: string);
            /**
                * Initializes the channel proxy
                */
            initialize(): Promise<void>;
            /**
                * Sets the new notifier to use to listen the notifications of the host.
                * @param notifier defines the reference to the notifier listening the notifications.
                */
            setNotifier(notifier: INotifier): void;
            /**
                * Execute an action
                * @param actionId Action identifier
                * @param parameters Action-specific parameters
                * @return Promise that resolves to an action-specific value (some actions don't return a promise)
                */
            executeAction(actionId: "CLOSE_GAME"): void;
            executeAction(actionId: "CREDIT" | "GLOBAL_RULES"): Promise<void>;
            executeAction(actionId: "GAME_RULES", parameters: IGameInformation): Promise<void>;
            executeAction(actionId: "OPEN_GAME", parameters: IGameInformation): void;
            executeAction(actionId: "IS_GAME_ENABLED", parameters: IGameInformation): void;
            executeAction(actionId: "OPEN_POPUP", parameters: IMessage): Promise<void>;
            /**
                * Emit an event
                * @param eventType Event type
                * @param eventData Event data
                */
            emitEvent(eventType: string, eventData?: any): void | Promise<any>;
            /**
                * Sends the tag for a request params event.
                * @param requestConfig
                */
            emitRequestParamsTag(requestConfig: CustomAxiosRequestConfig): void;
            /**
                * Sends the tag for a request response event.
                * @param requestConfig
                * @param requestResponse
                */
            emitRequestResponseTag(requestConfig: CustomAxiosRequestConfig, requestResponse: {
                    data: any;
                    status: number;
                    headers: any;
            }): void;
            /**
                * Sends the tag for a request error event.
                * @param requestConfig
                * @param requestResponse
                */
            emitRequestErrorTag(requestConfig: CustomAxiosRequestConfig, requestResponse: {
                    data: any;
                    status: number;
                    headers: any;
            }): void;
            /**
                * Request the game mode to be updated
                * @param gameMode Game mode
                * @return Promise that resolves to the new game mode
                */
            updateGameMode(gameMode: string): Promise<string>;
            /**
                * Get the current game mode
                * @return Promise that resolves to the current game mode
                */
            getGameMode(): Promise<string>;
            /**
                * Get information about the user
                * @param options IStateInformation
                *   - forceAuthenticate? : If true, require the user to be signed in before resolving the promise (default false)
                *   - sessionTokenType? : If provided, require a session token to be exchanged
                *   - state? : IF state for session creation
                *   - redirectUrl? : string
                * @return Promise that resolves to information about the user or null if the user is not signed in (if sessionTokenType is provided and the host does not perform the token exchange with the target, the sessionToken field is filled in the user information)
                */
            getUserInformation(options: IStateInformation): Promise<IUserInformation>;
            /**
                * Get information about the user's purse(s)
                * @param force wether or not the purse should be retrieved absolutely from the channel.
                * @return Promise that resolves to information about the user's purse(s)
                */
            getPurseInformation(force?: boolean): Promise<IPurseInformation>;
            /**
                * Get information about the locale
                * @return Promise that resolves to information about the locale
                * @legacy
                */
            getLocaleInformation(): Promise<ILocaleInformation>;
            /**
                * Get the game configuration
                * @param type Guest type
                * @param name Guest name
                * @return Promise that resolves to the game configuration
                * @legacy
                */
            getGameConfiguration(type: string, name: string): Promise<IGameConfiguration>;
            /**
                * Get information about a guest
                * @param type Guest type
                * @param name Guest name
                * @return Promise that resolves to the game information
                */
            getGameInformation(type: string, name: string): Promise<IGameInformation>;
            /**
                * Get information about the host
                * @return Promise that resolves to information about the host
                */
            getHostInformation(): Promise<IHostInformation>;
            /**
                * LEGACY : Mask the user's purse
                * @param mask Mask
                * @return Promise that resolves to the updated purse information along with a mask identifier
                * @deprecated
                */
            maskPurse(mask: IPurseMask): Promise<IMaskedPurseInformation>;
            /**
                * LEGACY : Clear a purse mask
                * @param maskId Mask identifier obtained from maskPurse()
                * @return Promise that resolves to the updated purse information
                * @deprecated
                */
            clearPurse(maskId: string): Promise<IPurseInformation>;
    }
}

declare module '@falcon/bridge/tools/tools' {
    import type { IStringDictionary } from "@falcon/bridge/typings/common";
    /**
        * Returns the current query parameters according to the current window's search URL
        */
    export function getQueryParameters(): IStringDictionary<string>;
    /**
        * Returns an uid
        */
    export function uid(): number;
    /**
        * Returns the current path of the bridge
        */
    export function getBridgePath(): string;
    /**
        * Loads the given file
        * @param url the url of the file to load on the server
        */
    export function loadFile(url: string): Promise<string>;
    /**
        * Injects a new script in the document's head
        * @param content the content of the script
        */
    export function injectScript(content: string, url?: string): HTMLScriptElement;
    /**
        * Loads the given script and adds in the document's head
        * @param url the url of the script to load
        */
    export function loadScript(url: string): Promise<void>;
    /**
        * Loads the given style sheet and adds in the document's head.
        * @param url the url of the stylesheet to load.
        */
    export function loadStyleSheet(url: string): Promise<void>;
    /**
        * Load JSON file directly
        * @param url file name
        * @return Promise that resolves once the json is loaded and parsed
        */
    export function loadJSON<T>(url: string): Promise<T>;
}

declare module '@falcon/bridge/typings/common' {
    /**
        * Helper interface to define a string dictionary
        */
    export interface IStringDictionary<T> {
            [key: string]: T;
    }
    /**
        * Helper interface to define a number dictionary
        */
    export interface INumberDictionary<T> {
            [index: number]: T;
    }
    /**
        * Dimensions
        */
    export interface IDimension {
            width: number;
            height: number;
    }
    /**
        * Amount
        */
    export interface IAmount {
            value: number;
            currency: string;
            /**
                * Defines the minimal fraction digit to use (see ISO 4217)
                * For exemple `EUR` will be with a scale of 2
                */
            scale?: number;
    }
    /**
        * HTTP headers
        */
    export interface IHttpHeaderMap {
            [headerName: string]: string;
    }
    /**
        * Currency Purse types
        */
    export enum ECurrencyPurseType {
            DEFAULT = "DEFAULT",
            GIFT = "GIFT"
    }
    /**
        * Currency purse
        */
    export interface ICurrencyPurse {
            balance: IAmount;
            playerId: string;
            restrictions: {
                    applicationId: string;
                    serviceName: string;
            };
            type: ECurrencyPurseType;
            validFrom: string;
            validTo: string;
    }
}

declare module '@falcon/bridge/typings/information' {
    import type { IList } from "@gdk/blacklist";
    import type { IStringDictionary, IAmount } from "@falcon/bridge/typings/common";
    /**
        * Catalog Game informations
        */
    export interface ICatalogGame {
            code: string;
            engineCode: string;
            compatibility?: IList;
    }
    /**
        * Game information
        */
    export interface IGameInformation {
            type: string;
            name: string;
            parameters?: IStringDictionary<any>;
    }
    /**
        * Game configuration
        */
    export interface IBaseGameConfiguration {
            masterGameCode?: string;
            lotteryGameCode: string;
            version?: string;
            betMode: string;
            selectedLocale: string;
            selectedBetMode: string;
            phygital?: boolean;
            stakes: IAmount[];
            jackpots?: any;
            demo?: {
                    enabled: boolean;
                    forceAuthentication: boolean;
            };
            /**
                * Defines the optional factory set in game configuration that tell
                * the bridge to load a factory instead of the game.
                */
            factory?: {
                    name: string;
                    parameters?: any;
            };
    }
    export interface IGameConfigurationV2 extends IBaseGameConfiguration {
            schemaVersion: 2;
            technicalName: string;
            locale: string;
            assets: {
                    themes: {
                            [name: string]: string;
                    };
                    i18n: {
                            [name: string]: string;
                    };
            };
            game: {
                    theme: string;
                    parameters: {
                            soundEnabled: boolean;
                    };
            };
    }
    export interface IGameConfigurationV3 extends IBaseGameConfiguration {
            schemaVersion: 3;
            gameDescription: {
                    assets: {
                            themes: {
                                    [name: string]: string;
                            };
                            i18n: {
                                    [name: string]: string;
                            };
                    };
            };
            selectedTheme: string;
            selectedLocale: string;
            gameParameters: {
                    soundEnabled: boolean;
            };
    }
    export type IGameConfiguration = IGameConfigurationV2 | IGameConfigurationV3;
    /**
        * Purse information
        */
    export interface IPurseInformation {
            values?: IStringDictionary<IAmount>;
            displayedAmount: IAmount;
    }
    /**
        * Purse mask
        */
    export interface IPurseMask {
            purseInformation: IPurseInformation;
            betAmount: IAmount;
            winAmount: IAmount;
    }
    /**
        * Purse information (masked)
        */
    export interface IMaskedPurseInformation extends IPurseInformation {
            maskId: string;
    }
    /**
        * Session token information
        */
    export interface ISessionTokenInformation {
            provider: string;
            value: string;
            state: string;
    }
    /**
        * User information
        */
    export interface IUserInformation {
            gender: string;
            firstName: string;
            lastName: string;
            sessionToken?: ISessionTokenInformation;
    }
    /**
        * State options for authentication
        */
    export interface IStateInformation {
            state?: string;
            redirectUrl?: string;
            forceAuthenticate?: boolean;
            platformSessionType?: string;
    }
    /**
        * Locale information
        * @legacy
        */
    export interface ILocaleInformation {
            availableLanguages: string[];
            activeLanguage: string;
            activeCurrency: string;
    }
    /**
        * OpenGame parameters (as query params)
        */
    export interface IOpenGameParameters {
            betId?: number | string;
            skipRules?: boolean;
            gameMode?: string;
            lotteryChannel?: string;
            platform?: string;
            language?: string;
            theme?: string;
            soundEnabled?: boolean;
            gameSpecificParameters?: {
                    [key: string]: any;
            };
    }
    export interface ITag {
            eventType: string;
            uuid: string;
            seqNum: number;
            applicationId: string;
            gameName: string;
            date: number;
            [key: string]: any;
    }
}

declare module '@falcon/bridge/typings/bet' {
    import type { IAmount } from "@falcon/bridge/";
    import type { IMessage } from "@falcon/bridge/typings/messages";
    /**
        * Identifies a service
        */
    export interface IService {
            applicationId?: string;
            serviceName?: string;
    }
    /**
        * Old jackpot result type
        */
    export interface IJackpotResult {
            /**
                * The jackpot application id
                */
            applicationId: string;
            /**
                *
                */
            receiptId: string;
            /**
                * The service name of the jackpot
                */
            serviceName: string;
            /**
                * The won amount
                */
            wonAmount: IAmount;
    }
    /**
        * Bet request
        */
    export interface IBetRequest extends IService {
            stake?: IAmount;
            demo?: boolean;
            eventReference?: {
                    [index: string]: string;
            };
    }
    /**
        * Bet result
        */
    export interface IBetResult extends IService {
            /**
                * Bet Amount
                */
            betAmount: IAmount;
            /**
                * Amount won
                */
            wonAmount?: IAmount;
            /**
                * The receipt id of the ticket.
                */
            receiptId: string;
            /**
                * Is demo
                */
            demo: boolean;
            /**
                * Platform bet id
                */
            platformBetId: string;
            /**
                * Old jackpot betResult
                */
            jackpotResult?: IJackpotResult;
            /**
                * Server messages
                */
            serverMessage: {
                    id: string;
            }[];
            /**
                * message for in game messaging
                */
            message?: IMessage;
    }
}

declare module '@falcon/bridge/typings/host' {
    /**
        * Host video information
        */
    export interface IHostVideoInformation {
            width: number;
            height: number;
            dpi: number;
            orientation: number;
            fullscreen: boolean;
    }
    /**
        * Host audio information
        */
    export interface IHostAudioInformation {
            effects: boolean;
            background: boolean;
    }
    /**
        * Host information
        */
    export interface IHostInformation {
            video: IHostVideoInformation;
            audio: IHostAudioInformation;
    }
}

declare module '@falcon/bridge/typings/platform' {
    import type { PushChannel } from "@falcon/push-client";
    import type { IBetRequest, IBetResult, IService, IJackpotResult } from "@falcon/bridge/typings/bet";
    import type { ISessionTokenInformation, IStateInformation, IGameConfiguration, ICatalogGame } from "@falcon/bridge/typings/information";
    import type { IAmount, ICurrencyPurse } from "@falcon/bridge/typings/common";
    import type { IMtrModel, IMtrSession, IMtrBetRequest, IMtrBetResult, IMtrBetUpdateRequest, IMtrReplaySession } from "@falcon/bridge/typings/mtr";
    import type { IPrsTicketInfos } from "@falcon/bridge/typings/prs";
    export interface IPlatform {
            getReplayProtectionToken(): Promise<string>;
            createSession(sessionToken: ISessionTokenInformation, demo?: boolean): Promise<ISessionTokenInformation>;
            getState(lotteryCode?: string): Promise<IStateInformation>;
            getGames(lotteryCode?: string): Promise<ICatalogGame[]>;
            getCompatibility(lotteryGameCode?: string): Promise<ICatalogGame[]>;
            getCurrentGameConfig(lotteryCode?: string, service?: IService): Promise<IGameConfiguration>;
            getPlayerCurrency(currencyCode: string, playerId: string, service?: IService, lotteryCode?: string): Promise<ICurrencyPurse[]>;
            getAvatarUrl(id: string): string;
            getJackpotInformation(service?: IService): Promise<IJackpotInformation>;
            getJackpotConfiguration(serviceName: string): Promise<IJackpotConfiguration[]>;
            getItgModel(serviceName?: string): Promise<IItgModel>;
            getItgTicket(ticketId: string | number, demo?: boolean): Promise<IItgTicket>;
            getItgTickets(serviceName?: string, demo?: boolean): Promise<IItgTicket[]>;
            createITGBet(betRequest: IItgBetRequest): Promise<IItgBetResult>;
            updateItgBet(betRequest: IItgBetRequest, ticketId: number): Promise<IItgBetResult>;
            claimItgBet(betRequest: IItgBetRequest, ticketId: number): Promise<IItgBetResult>;
            getEinModel?(serviceName?: string, demo?: boolean): Promise<IEinModel>;
            getEinTicket?(ticketId: string, demo?: boolean): Promise<IEinTicket>;
            getEinTickets?(serviceName?: string, demo?: boolean): Promise<IEinTicket[]>;
            createEinBet?(betRequest: IEinBetRequest): Promise<IEinBetResult>;
            updateEinBet?(betRequest: IEinBetRequest, ticketId: string): Promise<IEinBetResult>;
            claimEinBet?(betRequest: IEinBetRequest, ticketId: string): Promise<IEinBetResult>;
            getMtrModel<TModel>(service: IService, demoMode?: boolean): Promise<IMtrModel<TModel>>;
            getMtrSession<TGameData, TEventResponse, TEventParameters>(service: IService, demoMode?: boolean, sessionId?: string): Promise<IMtrSession<TGameData, TEventParameters, TEventResponse> | IMtrReplaySession<TEventResponse, TEventParameters> | undefined>;
            createMtrBet<TEventResponse, TEventParameters>(betRequest: IMtrBetRequest<TEventParameters>): Promise<IMtrBetResult<TEventResponse>>;
            updateMtrBet<TEventResponse, TEventParameters>(data: IMtrBetUpdateRequest<TEventParameters>): Promise<IMtrBetResult<TEventResponse>>;
            getPrsTicketInfos(): Promise<IPrsTicketInfos>;
            getGamifContext<T>(service: IService): Promise<IGamifContext<T>>;
            getMtpModel<T>(service: IService): Promise<IMtpRoomParamsResult<T>>;
            getMtpRoom(service: IService, roomId?: string, demo?: boolean): Promise<IMtpRoom>;
            getMtpRooms(service: IService, demo?: boolean): Promise<IMtpRoom[]>;
            getMtpSession<T>(service: IService, roomId: string): Promise<IMtpSession<T>>;
            enterMtpRoom(enterRoomRequest: IMtpEnterRoomRequest, demo?: boolean): Promise<IMtpRoom>;
            enterMtpRoomAndBet(enterAndBetRequest: IMtpEnterRoomRequest & IMtpBetRequest, demo?: boolean): Promise<IMtpBetResult & IMtpRoom>;
            createMtpBet(betRequest: IMtpBetRequest): Promise<IMtpBetResult>;
            updateMtpBet(betRequest: IMtpBetRequest): Promise<IMtpBetResult>;
            createNotificationsChannel(settings: IPushSettings): Promise<PushChannel>;
            getPlayersInfo(playersIds: string[], lotteryCode?: string): Promise<IPlayerInformation[]>;
            getCurrentPlayerInfo(): Promise<IPlayerInformation>;
    }
    export interface IPlayerInformation {
            alias: string;
            avatarCode: string;
            lotteryId: string;
            playerId: string;
    }
    /**
        * Old jackpot information type
        */
    export interface IJackpotInformation {
            amount: IAmount;
            /**
                * The last time the amount has been refreshed
                */
            amountTime: string;
            /**
                * The initial amount of the jackpot (min amount)
                */
            initialAmount: IAmount;
            /**
                *  The last time the jackpot has been won
                */
            lastWinTime: string;
    }
    export type IJackpotConfiguration = {
            name: string;
            type: "progressive" | "fixed";
            amount: IAmount;
    };
    export interface IItgBetRequest extends IBetRequest {
            /**
                * The stake linked to the croupier.
                */
            stake: IAmount;
            /**
                * Optionnal revelation data as a json
                */
            revelationData?: any;
    }
    export enum EItgPrizeType {
            periodicWinning = "PERIODIC_WINNING"
    }
    export interface IEventReference {
            eventReference: {
                    /**
                        * The prize rank id of the ticket.
                        */
                    prizeRank: number;
                    /**
                        * The prize type : Periodic for Exemple
                        */
                    prizeType: EItgPrizeType;
                    /**
                        * A description of the prize. The duration of a periodic for exemple.
                        */
                    prizeDescription: string;
            };
    }
    export interface IItgPrize {
            /**
                * The prize rank id of the ticket.
                */
            rank: number;
            /**
                * The prize type : Periodic for Exemple
                */
            type: EItgPrizeType;
            /**
                * A description of the prize. The duration of a periodic for exemple.
                */
            description: string;
    }
    export interface IItgTicket {
            /**
                * The id of the ticket.
                */
            id: number;
            /**
                * The bet amount (stake) used for the ticket.
                */
            betAmount?: IAmount;
            /**
                * Won Amout for the ticket
                */
            wonAmount?: IAmount;
            /**
                * The symbol of the ticket.
                */
            symbol: string;
            /**
                * The custom revelations datas of the ticket sent in the bet/update.
                */
            revelationData: any;
            /**
                * The prize of the ticket.
                */
            prize: IItgPrize;
            /**
                * The status of the ticket
                */
            status: string;
            openedTime: string;
            claimedTime: string;
            serviceName: string;
            receiptId: string;
            platformBetId?: string;
            lotteryCode: string;
            demo: boolean;
            action: string;
            jackpotResult: IJackpotResult;
    }
    export interface IItgBetResult extends IBetResult {
            wonAmount: IAmount;
            /**
                * The ticket data (symbol, etc.).
                */
            data: IItgTicket;
    }
    export interface IItgModel {
    }
    export interface IGamifContext<T> {
    }
    export interface IMtpBetLevel {
            id: string;
            ranges: {
                    minValue: number;
                    maxValue: number;
                    step?: number;
            };
    }
    export interface IMtpRoomParamsResult<T> extends IService {
            data: {
                    content: T;
                    betLevelList: IMtpBetLevel[];
                    maxPlayers: number;
                    minPlayers: number;
            };
    }
    export interface IMtpEnterRoomRequest extends IService {
            betLevelId: string;
    }
    export interface IMtpRoom extends IService {
            betLevelId: string;
            gameSessionId: string;
            roomId: string;
            nbPlayers: number;
    }
    export interface IMtpPlayer {
            id: string;
            protected: any;
            public: any;
    }
    export interface IMtpSession<T> extends IService {
            id: string;
            data: {
                    gameSessionState: string;
                    lastGameSessionNotificationId: number;
                    lastPlayerNotificationId: number;
                    playerGameSessionId: string;
                    playerId: string;
                    roomId: string;
                    time: number;
                    totalActivePlayerInRoom: number;
                    totalUserInRoom: number;
                    data: {
                            currentPlayer: IMtpPlayer;
                            players: IMtpPlayer[];
                            public: T;
                    };
            };
    }
    export interface IMtpBetResult extends IBetResult {
            data: any;
    }
    export interface IMtpBetRequest extends IBetRequest {
            stake: IAmount;
            roomId?: string;
            sessionId?: string;
            parameters: any;
            playerGameSessionId?: string;
    }
    /**
        * Push transport mechanism
        */
    export enum EPushTransportMechanism {
            MQTT = 1,
            SERVER_SENT_EVENTS = 2,
            WEBSOCKET = 3
    }
    /**
        * Push topic
        */
    export interface IPushTopic {
            type: string;
            id: string;
    }
    export interface IPushSettings {
            topic: IPushTopic;
            transport: EPushTransportMechanism;
            secure?: boolean;
            hostName?: string;
            port?: number;
            path?: string;
            accessToken?: string;
    }
    export interface IEinBetRequest extends IBetRequest {
            stake: IAmount;
            /**
                * Free map to store client information on the ticket
                */
            gameClientData?: {
                    [key: string]: any;
            };
    }
    export interface IEinBetResult extends IBetResult {
            wonAmount: IAmount;
            data: {
                    /**
                        * revelationData stored by the game client
                        */
                    gameClientData?: {
                            [key: string]: any;
                    };
                    /**
                        * engineData added by the engine
                        */
                    engineData?: {
                            [key: string]: any;
                    };
                    id: string;
                    eventReference: {
                            [index: string]: string;
                    };
                    status: "DRAWN" | "CLAIMED";
            };
    }
    export interface IEinTicket extends IService {
            id: string;
            historyId: string;
            betAmount: IAmount;
            wonAmount: IAmount;
            status: "DRAWN" | "CLAIMED";
            lotteryCode: string;
            receiptId: string;
            demo: boolean;
            /**
                * engineData added by the engine
                */
            engineData?: {
                    [key: string]: any;
            };
    }
    export interface IEinModel extends IService {
            data: {
                    lotteryCode: string;
                    stakes: {
                            amount: IAmount;
                            numberOfPools: number;
                            variant: {
                                    code: string;
                                    status: string;
                                    game: {
                                            code: string;
                                    };
                                    ranks: {
                                            rankId: number;
                                            numberOfTickets: number;
                                            amount: IAmount;
                                            data: {
                                                    [index: string]: any;
                                            };
                                    }[];
                                    data: {
                                            [index: string]: any;
                                    };
                            };
                            data: {
                                    [index: string]: any;
                            };
                    }[];
                    data: {
                            [index: string]: any;
                    };
                    betGameCode: string;
                    poolRemit: boolean;
            };
    }
}

declare module '@falcon/bridge/typings/mtr' {
    import type { IService, IBetResult, IBetRequest } from "@falcon/bridge/typings/bet";
    import type { IAmount } from "@falcon/bridge/typings/common";
    export interface IMtrModel<TModel> extends IService {
            data: {
                    /**
                        * Game model ID.
                        */
                    gmid: number;
                    /**
                        * Game model
                        */
                    mdl: TModel;
                    /**
                        * Bet list
                        */
                    bam?: {
                            [betID: number]: number;
                    };
            };
    }
    /**
        * Mtr session steps for replay.
        * @template TEventResponse Event response
        * @template TEventParameters Event parameters
        */
    export interface IMtrSessionStep<TEventParameters, TEventResponse> {
            /**
                * Event parameters.
                */
            par: TEventParameters;
            /**
                * State after the event.
                */
            st: string;
            /**
                * Event result.
                */
            res: TEventResponse;
            /**
                * Date of the event.
                */
            dat: number;
            /**
                *  Event name.
                */
            nam: string;
    }
    export enum EMtrSessionState {
            InProgress = "INPR",
            Stopped = "STPD",
            Resolved = "RSLD",
            Completed = "CMPL"
    }
    /**
        * Session data for finished session.
        * Used for replay.
        * @template TEventParameters Event parameters
        * @template TEventResponse Event response
        */
    export interface IMtrReplaySessionData<TEventParameters, TEventResponse> {
            /**
                * Game model ID.
                */
            gmid: number;
            /**
                * Sessions steps for replay.
                */
            steps: IMtrSessionStep<TEventParameters, TEventResponse>[];
            /**
                * State of the session.
                */
            state: EMtrSessionState;
    }
    /**
        * Session data for open session;
        * @template TGameData session model
        */
    export interface IMtrSessionData<TGameData, TEventParameters, TEventResponse> extends IMtrReplaySessionData<TEventParameters, TEventResponse> {
            /**
                * State.
                */
            st: string;
            /**
                * Game data.
                * Script defined session payload.
                */
            gmd: TGameData;
    }
    /**
        * Mtr session response.
        * @template TGameData Game data.
        * @template TEventResponse Event response.
        * @template TEventParameters Event parameters.
        */
    export interface IMtrSession<TGameData, TEventParameters, TEventResponse> extends IService {
            /**
                * Session ID.
                */
            id: string;
            /**
                * Session data.
                */
            data: IMtrSessionData<TGameData, TEventParameters, TEventResponse>;
            /**
                * Bet amount.
                */
            betAmount: IAmount;
    }
    /**
        * Mtr finished session response for replay.
        * @template TEventResponse Event response.
        * @template TEventParameters Event parameters.
        */
    export interface IMtrReplaySession<TEventResponse, TEventParameters> extends IService {
            /**
                * Session ID.
                */
            id: string;
            /**
                * Session data.
                */
            data: IMtrReplaySessionData<TEventParameters, TEventResponse>;
            /**
                * Bet amount.
                */
            betAmount: IAmount;
            /**
                * Won amount.
                */
            wonAmount: IAmount;
    }
    /**
        * Session from BOI for replay.
        * @template TEventResponse Event response.
        * @template TEventParameters Event parameters.
        */
    export interface IBoiMtrReplaySession<TEventResponse, TEventParameters> {
            id: number;
            gameId: number;
            gameName: string;
            externalGameCode: string;
            gameModelVersionId: string;
            userId: string;
            lottery: string;
            startTime: string;
            endTime: string;
            betAmount: IAmount;
            wonAmount: IAmount;
            archived: boolean;
            state: EMtrSessionState;
            suspended: boolean;
            steps: IMtrSessionStep<TEventParameters, TEventResponse>[];
    }
    /**
        * Session data. Returned by a bet / updateBet.
        * @template TEventResponse Event response.
        */
    export interface IMtrBetResultData<TEventResponse> {
            /**
                * Event response.
                * Probably empty on a session response.
                * Probably not empty on a bet response.
                * Script defined response payload.
                */
            evr?: TEventResponse;
            /**
                * Game model ID.
                */
            gmid: number;
            /**
                * Session ID.
                */
            id: string;
            /**
                * State.
                */
            st: string;
    }
    /**
        * Mtr bet / updateBet response.
        * @template TEventResponse Event response.
        */
    export interface IMtrBetResult<TEventResponse> extends IBetResult {
            betAmount: IAmount;
            wonAmount?: IAmount;
            data: {
                    /**
                        * Request result.
                        */
                    res: string;
                    /**
                        * Session data.
                        */
                    data: IMtrBetResultData<TEventResponse>;
            };
    }
    /**
        * Mtr bet request.
        */
    export interface IMtrBetRequest<TEventParameters> extends IBetRequest {
            stake: IAmount;
            parameters: {
                    betId?: number;
                    prm?: TEventParameters;
            };
    }
    export interface IMtrBetUpdateRequestParameters<TEventParameters> {
            /**
                * Session ID.
                */
            sid: string;
            prm: TEventParameters;
            evn: string;
    }
    /**
        * Mtr update bet request.
        */
    export interface IMtrBetUpdateRequest<TEventParameters> extends IBetRequest {
            /**
                * The parameters of the update bet request to send to Motors.
                */
            parameters: IMtrBetUpdateRequestParameters<TEventParameters>;
    }
}

declare module '@falcon/bridge/typings/channel' {
    import type { Bridge } from "@falcon/bridge/";
    import type { IDimension } from "@falcon/bridge/typings/common";
    import type { IHostInformation } from "@falcon/bridge/typings/host";
    import type { IPurseInformation, IUserInformation, ITag, IGameInformation, IStateInformation, IPurseMask, IMaskedPurseInformation, IGameConfiguration, ILocaleInformation } from "@falcon/bridge/typings/information";
    import type { IBetRequest, IBetResult } from "@falcon/bridge/typings/bet";
    import type { IMessage } from "@falcon/bridge/typings/messages";
    import type { INotifier } from "@falcon/bridge/typings/notifier";
    import type { IEinTicket, IItgTicket } from "@falcon/bridge/typings/platform";
    import type { IBoiMtrReplaySession, IMtrReplaySession } from "@falcon/bridge/typings/mtr";
    import type { CustomAxiosRequestConfig } from "@falcon/bridge/platforms/platform-itf";
    /**
        * Host channel interface
        */
    export interface IHostChannel {
            /**
                * Channel id
                */
            bridge: Bridge;
            /**
                * Channel id
                */
            channelId: string;
            /**
                * Guest type
                */
            type: string;
            /**
                * Guest name
                */
            name: string;
            /**
                * Lottery code
                */
            lotteryCode: string;
            /**
                * Host key
                */
            hostKey: string;
            /**
                * Defines the reference to the notifier used to notify the game.
                */
            notifier?: INotifier;
            /**
                * Initializes the channel proxy
                */
            initialize(): Promise<void>;
            /**
                * Sets the new notifier to use to listen the notifications of the host.
                * @param notifier defines the reference to the notifier listening the notifications.
                */
            setNotifier(notifier: INotifier): void;
            /**
                * Emit an event
                * @param eventType Event type
                * @param eventData Event data
                * @return Promise that resolves to an event-specific value (some event don't return a promise)
                */
            emitEvent(eventType: "DIMENSIONS", eventData: IDimension): void;
            /**
                * Sends tags on game actions so the lottery can track
                */
            emitEvent(eventType: "TAG", eventData: ITag): void;
            /**
                * Notify the lottery that the player wants to buy a ticket with real money.
                * The lottery has the ability to check wether or not the player has sufficident funds in his purse.
                * If not the lottery should ask to the player to credit (with an overlay).
                * In any case it must respond with a promise.
                *  - when fullfiled the game will continue with the bet
                *  - when rejected the game will cancel the bet process
                * @return Promise<void>
                */
            emitEvent(eventType: "PREBET", eventData: IBetRequest): void | Promise<void>;
            /**
                * Notify the lottery that the player has just made a bet.
                */
            emitEvent(eventType: "HAS_BET", eventData: IBetResult): void;
            /**
                * Notify the lottery that the player has just claim a bet.
                */
            emitEvent(eventType: "HAS_CLAIMED", eventData: IBetResult): void;
            /**
                * Notify the lottery that, in case of a replay, the game finished replaying the ticket or the session.
                */
            emitEvent(eventType: "REPLAY_FINISHED", eventData: IItgTicket | IEinTicket | IBoiMtrReplaySession<unknown, unknown> | IMtrReplaySession<unknown, unknown>): void;
            /**
                * Notify the lottery that the sound status changed.
                * @param eventType
                * @param eventData
                */
            emitEvent(eventType: "SOUND_STATUS", eventData: boolean): void;
            emitEvent(eventType: string, eventData?: any): void | Promise<any>;
            /**
                * Sends the tag for a request params event.
                * @param requestConfig
                */
            emitRequestParamsTag(requestConfig: CustomAxiosRequestConfig): void;
            /**
                * Sends the tag for a request response event.
                * @param requestConfig
                * @param requestResponse
                */
            emitRequestResponseTag(requestConfig: CustomAxiosRequestConfig, requestResponse: {
                    data: any;
                    status: number;
                    headers: any;
            }): void;
            /**
                * Sends the tag for a request error event.
                * @param requestConfig
                * @param requestResponse
                */
            emitRequestErrorTag(requestConfig: CustomAxiosRequestConfig, requestResponse: {
                    data: any;
                    status: number;
                    headers: any;
            }): void;
            /**
                * Request the game mode to be updated
                * @param gameMode Game mode
                * @return Promise that resolves to the new game mode
                */
            updateGameMode(gameMode: string): Promise<string>;
            /**
                * Get the current game mode
                * @return Promise that resolves to the current game mode
                */
            getGameMode(): Promise<string>;
            /**
                * Get information about the user
                * @param options IStateInformation
                *   - forceAuthenticate? : If true, require the user to be signed in before resolving the promise (default false)
                *   - sessionTokenType? : If provided, require a session token to be exchanged
                *   - state? : must be provided in the case forceAuthenticate is set to true
                *   - redirectUrl? : must be provided in the case forceAuthenticate is set to true
                * @return Promise that resolves to information about the user or null if the user is not signed in (if sessionTokenType is provided and the host does not perform the token exchange with the target, the sessionToken field is filled in the user information)
                */
            getUserInformation(options: IStateInformation): Promise<IUserInformation>;
            /**
                * Get information about the user's purse(s)
                * @param force wether or not the purse should be retrieved absolutely from the channel.
                * @return Promise that resolves to information about the user's purse(s)
                */
            getPurseInformation(force?: boolean): Promise<IPurseInformation>;
            /**
                * Get information about the host
                * @return Promise that resolves to information about the host
                */
            getHostInformation(): Promise<IHostInformation>;
            /**
                * Get information about a guest
                * @param type Guest type
                * @param name Guest name
                * @return Promise that resolves to the game information
                */
            getGameInformation(type: string, name: string): Promise<IGameInformation>;
            /**
                * LEGACY : Mask the user's purse
                * @param mask Mask
                * @return Promise that resolves to the updated purse information along with a mask identifier
                * @deprecated
                */
            maskPurse(mask: IPurseMask): Promise<IMaskedPurseInformation>;
            /**
                * LEGACY : Clear a purse mask
                * @param maskId Mask identifier obtained from maskPurse()
                * @return Promise that resolves to the updated purse information
                * @deprecated
                */
            clearPurse(maskId: string): Promise<IPurseInformation>;
            /**
                * Execute an action
                * @param actionId Action identifier
                * @param parameters Action-specific parameters
                * @return Promise that resolves to an action-specific value (some actions don't return a promise)
                */
            executeAction(actionId: "CLOSE_GAME"): void;
            executeAction(actionId: "CREDIT" | "GLOBAL_RULES"): Promise<void>;
            executeAction(actionId: "GAME_RULES", parameters: IGameInformation): Promise<void>;
            executeAction(actionId: "OPEN_GAME", parameters: IGameInformation): void;
            executeAction(actionId: "OPEN_POPUP", parameters: IMessage): Promise<void>;
            executeAction(actionId: string, parameters?: any): Promise<any> | void;
            /**
                * LEGACY
                * Get the game configuration
                * @param type Guest type
                * @param name Guest name
                * @return Promise that resolves to the game configuration
                * @legacy
                */
            getGameConfiguration?(type: string, name: string): Promise<IGameConfiguration>;
            /**
                * LEGACY
                * Get information about the locale
                * @return Promise that resolves to information about the locale
                * @legacy
                */
            getLocaleInformation(): Promise<ILocaleInformation>;
    }
}

declare module '@falcon/bridge/typings/messages' {
    /**
        * Log level
        */
    export enum EPopinLevel {
            Info = "info",
            Warning = "warning",
            Error = "error"
    }
    /**
        * Interface defining popin options & content
        */
    export interface IPopinDefinition {
            /**
                * Log level.
                */
            level: EPopinLevel;
            /**
                * Title of the popin.
                */
            title?: string;
            /**
                * Content of the popin.
                */
            content?: string;
            /**
                * Alias for content.
                */
            text?: string;
            /**
                * Display a close button in the top right of the popin.
                */
            closable?: boolean;
            /**
                * Give possibility fo close the popin by clicking on the background overlay.
                */
            clickOutsideToClose?: boolean;
            /**
                * List of buttons for the popin.
                */
            buttons?: IPopinButton[];
            /**
                * For overriding the popin CSS.
                */
            style?: {
                    [key: string]: string | number;
            };
            /**
                * For overriding the title CSS.
                */
            titleStyle?: {
                    [key: string]: string | number;
            };
            /**
                * For overriding the text CSS.
                */
            textStyle?: {
                    [key: string]: string | number;
            };
            /**
                * To hide the shadow background overlay.
                */
            disableOverlay?: boolean;
    }
    /**
        * List of actions available for a popin button.
        */
    export enum PopinButtonAction {
            /**
                * Open a link.
                */
            Link = "link",
            /**
                * Close the popin.
                */
            ClosePopin = "closePopup",
            /**
                * Close the game through the bridge.
                */
            CloseGame = "closeGame",
            /**
                * Call a callback with the popin as argument.
                */
            Callback = "callback"
    }
    /**
        * Set type of link.
        */
    export enum PopinLinkTarget {
            /**
                * Open the link in an another page.
                */
            Blank = "blank",
            /**
                * Open the link in the current page.
                */
            Self = "self"
    }
    /**
        * Definition of a link for a popin link button.
        */
    export interface IPopinLink {
            /**
                * Target of the link.
                */
            url: string;
            /**
                * Type of link.
                */
            target: PopinLinkTarget;
    }
    /**
        * Definition of a popin button.
        */
    export interface IPopinButton {
            /**
                * Label of the button.
                */
            label: string;
            /**
                * Type of click action.
                */
            action: PopinButtonAction;
            /**
                * Optionnal link definition for a Link button.
                */
            link?: IPopinLink;
            /**
                * For overriding the button CSS;
                */
            style?: {
                    [key: string]: string | number;
            };
    }
    /**
        * When to display the message.
        */
    export enum EMessageType {
            /**
                * Immediatly after the call of the message manager.
                */
            Immediate = "immediate",
            /**
                * At the end of a game.
                */
            End = "end"
    }
    /**
        * Definition of an inGame message.
        */
    export interface IMessage {
            /**
                * Error code.
                */
            code: string;
            /**
                * When to display the message.
                */
            type: EMessageType;
            /**
                * Popin definition.
                */
            popup?: IPopinDefinition;
            /**
                * Context in case of an IF error
                */
            context?: {
                    code: string;
                    message: string;
            };
    }
}

declare module '@falcon/bridge/typings/notifier' {
    import type { ILocaleInformation, IPurseInformation, IUserInformation } from "@falcon/bridge/typings/information";
    export interface INotifier {
            /**
                * Notifies the game that the purse information changed.
                * @param purseInformation defines the new purse information to display in the game.
                */
            notifyPurseInformationChange?(purseInformation?: IPurseInformation): void;
            /**
                * Notifies the game that the sound status changed.
                * @param soundEnabled defines the sound status.
                */
            notifySoundStatus?(soundEnabled?: boolean): void;
            /**
                * Notifies the game about pause/resume status.
                */
            notifyPause?(message: {
                    isPaused: boolean;
                    reason: string;
            }): void;
            /**
                * Notifies the game that the current game mode changed.
                * @param gameMode defines the new game mode.
                */
            notifyGameModeChange?(gameMode: string): void;
            /**
                * Notifies the game that the localed changed.
                * @param localeInformation defines the new locale information to apply.
                */
            notifyLocaleInformationChange?(localeInformation: ILocaleInformation): void;
            /**
                * Notifies the game that the user information changed.
                * @param userInformation defines the new user informations.
                */
            notifyUserInformationChange?(userInformation: IUserInformation): void;
    }
}

declare module '@falcon/bridge/jackpot/jackpot' {
    import type { IJackpotResult } from "@falcon/bridge/typings/bet";
    import type { IGameInformation, IUserInformation, IPurseInformation, ILocaleInformation, IGameConfiguration } from "@falcon/bridge/typings/information";
    import type { Bridge } from "@falcon/bridge/falcon-game-bridge";
    export class Jackpot {
            bridge: Bridge;
            /**
                * The iFrame reference used to display the jackpot applet.
                */
            iframe: HTMLIFrameElement;
            /**
                * The saved promise reference that will be resolved when jackpot applet asks to quit.
                */
            promise: Promise<void>;
            /**
                * Constructor
                * @param bridge the bridge instance used to access channel etc.
                */
            constructor(bridge: Bridge);
            /**
                * Displays the jackpot reveleation by creating a new iframe.
                * @param jackpotResult the jackpot result object from the bet response.
                */
            displayJackpotRevelation(jackpotResult: IJackpotResult): Promise<void>;
            /**
                * Handles the given message that comes from the superjackpot applet.
                * @comes from Channel.onMessage.
                */
            handleMessage(message: MessageEvent): void;
            /**
                * Returns the current game information.
                * @param type the game type (application Id)
                * @param name the name of the game (service name)
                */
            getGameInformation(type: string, name: string): Promise<IGameInformation>;
            /**
                * Returns the current user information.
                * @param forceAuthenticated If true, require the user to be signed in before resolving the promise.
                * @param sessionTokenType If provided, require a session token to be exchanged.
                */
            getUserInformation(forceAuthenticated?: boolean, sessionTokenType?: string): Promise<IUserInformation>;
            /**
                * Returns the current purse information.
                */
            getPurseInformation(): Promise<IPurseInformation>;
            /**
                * Returns the current locale informations.
                * @legacy
                */
            getLocaleInformation(): Promise<ILocaleInformation>;
            /**
                * Returns the current game configuration.
                * @param type the application type (applicationId)
                * @param name the service name
                * @legacy
                */
            getGameConfiguration(type: string, name: string): Promise<IGameConfiguration>;
            /**
                * Executes the given action whith the given parameters.
                * @param actionId the action id to execute (CLOSE_GAME, etc.).
                * @param parameters the parameters to send to the action being called.
                */
            executeAction(actionId: string, parameters?: any): Promise<any> | void;
    }
}

declare module '@falcon/bridge/tools/configuration' {
    import type { IStringDictionary } from "@falcon/bridge/typings/common";
    /**
        * Path configuration
        */
    export interface IPathConfiguration {
            guests?: any;
            applications?: {
                    [applicationId: string]: string;
            };
            platforms?: string;
            gamesV3?: string;
            media?: string;
            push: {
                    libPath: string;
                    hostName: string;
                    port: number;
                    path: string;
                    secure: false;
            };
            framework?: string;
            gameConf?: string;
    }
    /**
        * Tags Configuration
        */
    export interface ITagsConfiguration {
            enabled?: boolean;
            path?: string;
            allowedTagsList?: {
                    [lotteryCode: string]: string[];
            } | string[];
            gameExclusionList?: {
                    [lotteryCode: string]: string[];
            } | string[];
            delay?: number;
            log?: boolean;
    }
    /**
        * Configuration
        */
    export interface IConfiguration {
            version: string;
            platform?: string;
            lotteryCode: IStringDictionary<string>;
            platformSessionType?: string;
            channelOrigin?: IStringDictionary<string>;
            paths?: IPathConfiguration;
            guests?: any;
            messages?: IStringDictionary<IStringDictionary<string>>;
            tags: ITagsConfiguration;
            blacklist?: {
                    enabled?: boolean;
                    active?: boolean;
            };
            mocks?: {
                    [applicationId: string]: {
                            [hostKey: string]: IMocksConfiguration;
                    };
            };
            correlationIdHeaderName?: string;
            multiBetDelay?: number;
    }
    export interface IMocksConfiguration {
            enabled: boolean;
            path: "string";
    }
    /**
        * Returns the current bridge configuration stored in the
        */
    export function getBridgeConfiguration(): IConfiguration;
    /**
        * Sets the current configuration of the bridge
        * @param configuration the configuration object
        */
    export function setConfiguration(configuration: IConfiguration): void;
}

declare module '@falcon/bridge/typings/factory' {
    export interface IFactory {
    }
}

declare module '@falcon/bridge/platforms/platform-itf' {
    import type { AxiosInstance, AxiosRequestConfig, AxiosError } from "axios";
    import type { PushChannel } from "@falcon/push-client";
    import { TokenStore } from "@falcon/bridge/tools/token-store";
    import type { IPlatform, IItgModel, IJackpotInformation, IItgBetRequest, IItgBetResult, IItgTicket, IGamifContext, IMtpRoomParamsResult, IMtpRoom, IMtpSession, IMtpEnterRoomRequest, IMtpBetResult, IMtpBetRequest, IPlayerInformation, IPushSettings, IEinModel, IEinTicket, IEinBetRequest, IEinBetResult, IJackpotConfiguration } from "@falcon/bridge/typings/platform";
    import type { IMtrModel, IMtrBetRequest, IMtrBetUpdateRequest, IMtrSession, IMtrBetResult, IMtrReplaySession } from "@falcon/bridge/typings/mtr";
    import type { IPrsTicketInfos } from "@falcon/bridge/typings/prs";
    import type { IConfiguration } from "@falcon/bridge/tools/configuration";
    import type { IStateInformation, IGameConfiguration, ISessionTokenInformation, ICatalogGame } from "@falcon/bridge/typings/information";
    import type { ICurrencyPurse } from "@falcon/bridge/typings/common";
    import type { IService } from "@falcon/bridge/typings/bet";
    import type { Bridge } from "@falcon/bridge/falcon-game-bridge";
    export interface IExtraData {
            [key: string]: any;
    }
    export interface ICustomTagData {
            response?: IExtraData;
            request?: IExtraData;
    }
    export type CustomAxiosRequestConfig = AxiosRequestConfig & {
            eventTag: string;
            extraTagData?: ICustomTagData;
    };
    export enum EGameMode {
            demo = "DEMO",
            normal = "NORMAL"
    }
    export enum EMediaTypes {
            ERROR = "application/vnd.lotsys.falcon.error-1+json",
            REPLAYTOKEN = "application/vnd.lotsys.falcon.gateway.replayprotection.token-1+json",
            SESSIONCREATE = "application/vnd.lotsys.itf.session.request-1+json",
            CATALOG = "application/vnd.fgs.itf.catalog.game.list-5+json",
            COMPATIBILITY = "application/vnd.fgs.itf.catalog.unauthenticated.lottery.games.compatibility-1+json",
            USERDATAREQUEST = "application/vnd.lotsys.itf.game.userdata.search.parameters-1+json",
            USERDATARESPONSE = "application/vnd.lotsys.itf.game.userdata-1+json",
            JACKPOT = "application/vnd.lotsys.itf.jackpot-1+json",
            GAMEMODEL = "application/vnd.lotsys.itf.game.model-1+json",
            GAMESESSIONS = "application/vnd.lotsys.itf.game.session.list-1+json",
            GAMESESSIONSPARAMETERS = "application/vnd.lotsys.itf.game.session.search.parameters-1+json",
            BETREQUEST = "application/vnd.lotsys.itf.game.bet.request-1+json",
            BETRESULT = "application/vnd.lotsys.itf.game.bet.result-1+json",
            GAMIFCONTEXT = "application/vnd.lotsys.itf.gamification.context-1+json",
            BETANDCLAIM = "application/vnd.lotsys.itg.ticket.betManualClaim-1+json",
            AUTOCLAIM = "application/vnd.lotsys.itg.ticket.betAutoClaim-1+json",
            TICKETSLIST = "application/vnd.lotsys.itf.game.ticket.list-1+json",
            TICKETSLIST2 = "application/vnd.lotsys.itf.game.ticket.list-2+json",
            TICKETSLIST3 = "application/vnd.lotsys.itf.game.ticket.list-3+json",
            GETSTATE = "application/vnd.lotsys.itf.session.state.info-1+json",
            GAMECONFIGURATION = "application/vnd.fgs.itf.catalog.unauthenticated.lotterygame.config.map-1+json",
            PURSE = "application/vnd.fgs.itf.virtualcurrency.purse.list-1+json",
            MTP_GETROOMS = "application/vnd.lotsys.itf.game.room.list-1+json",
            MTP_GETROOM = "application/vnd.lotsys.itf.game.room-1+json",
            MTP_GETSESSION = "application/vnd.lotsys.itf.game.session-1+json",
            MTP_ENTERANDBET_REQUEST = "application/vnd.lotsys.itf.game.enter.bet.request-1+json",
            MTP_ENTERROOM_RESULT = "application/vnd.lotsys.itf.game.enter.result-1+json",
            MTP_ENTERROOM_REQUEST = "application/vnd.lotsys.itf.game.enter.request-1+json",
            PRS_TICKET_INFOS = "application/vnd.fgs.itf.presto.ticket-1+json"
    }
    export enum EPath {
            REPLAYPROTECTION = "/falcon/gateway/replayprotectiontokens",
            USERDATA = "/itf/game/userdata",
            ITFSESSION = "/itf/session",
            GAMES = "/itf/catalog/games/lotteries",
            JACKPOT = "/itf/jackpot/lotteries",
            GAMEMODEL = "/itf/game/model",
            GAMECONFIGURATION = "/itf/catalog-unauthenticated/lotteries",
            GAMESESSIONS = "/itf/game/sessions",
            BET = "/itf/game/bet",
            GAMIFCONTEXT = "/itf/gamif/games",
            GETITGTICKETS = "/itf/game/ITG/tickets",
            PURSE = "/itf/virtual-currency-purse/lotteries",
            MTP_ROOMS = "/itf/game/MTP/rooms",
            MTP_ENTER = "/itf/game/enter",
            MTP_ENTERANDBET = "/itf/game/enter/bet",
            MTP_SESSION = "/itf/game/session/room",
            WIZZ_AVATAR = "/avatar"
    }
    export enum EHeader {
            CONTENTTYPE = "Content-Type",
            ACCEPT = "Accept",
            TOKEN = "replay-token",
            ASK_TOKEN = "replay-token-generate",
            GENERATED_TOKEN = "replay-token-generated",
            CORRELATION_ID = "correlation-id"
    }
    export enum EItgBetMode {
            AUTO = "BET_AUTO_CLAIM",
            MANUAL = "BET_MANUAL_CLAIM"
    }
    interface IRetriableAxiosRequestConfig extends AxiosRequestConfig {
            retries?: number;
    }
    export default class PlatformITF implements IPlatform {
            bridge: Bridge;
            protected _configuration: IConfiguration;
            protected _tokens: TokenStore;
            protected _request: AxiosInstance;
            protected _requestWithToken: AxiosInstance;
            protected ticketsMap: {
                    [ticketId: number]: any;
            };
            protected masksMap: {
                    [ticketId: number]: string;
            };
            /**
                * Constructor
                * @param bridge
                */
            constructor(bridge: Bridge);
            /**
                * Retrive a replay protection token
                */
            getReplayProtectionToken(): Promise<string>;
            /**
                * Retrieve state information from IF in order to authenticate
                * @param lotteryCode
                */
            getState(lotteryCode?: string): Promise<IStateInformation>;
            /**
                * Creates an IF session
                * @param sessionToken
                * @param demo
                */
            createSession(sessionToken: ISessionTokenInformation, demo?: boolean): Promise<any>;
            /**
                * Retrive game configuration, try to get the config from getGameConfigurationService, fallback to loadJSON on error
                * @param lotteryCode the code of the current lottery. @example "fdj" or "fake-lottery".
                * @param service the service object containing the applicationId and service name.
                */
            getCurrentGameConfig(lotteryCode?: string, service?: IService): Promise<IGameConfiguration>;
            /**
                * Retrieve games compatibility for a lottery
                * @param lotteryGameCode
                */
            getCompatibility(lotteryGameCode?: string): Promise<ICatalogGame[]>;
            /**
                * Retrieve games catalog for a lottery
                * @param lotteryCode
                */
            getGames(lotteryCode?: string): Promise<ICatalogGame[]>;
            /**
                * Retrieves players information
                * @param playersIds string[]
                * @param lotteryCode
                * @return IPlayerInformation[]
                */
            getPlayersInfo(playersIds: string[], lotteryCode?: string): Promise<IPlayerInformation[]>;
            /**
                * Retrieves current player information
                * @return IPlayerInformation
                */
            getCurrentPlayerInfo(lotteryCode?: string): Promise<IPlayerInformation>;
            /**
                * Retrieves the player purses for a currency
                * @param currencyCode
                * @param playerId
                * @param service
                * @param lotteryCode
                */
            getPlayerCurrency(currencyCode: string, playerId: string, service?: IService, lotteryCode?: string): Promise<ICurrencyPurse[]>;
            /**
                * Return avatar url for id
                * @param id
                */
            getAvatarUrl(id: string): string;
            /**
                * Retrieve old Jackpot balance
                */
            getJackpotInformation(service?: IService): Promise<IJackpotInformation>;
            /**
                * Returns the current jackpots.
                * @param service the service's informations.
                */
            getJackpotConfiguration(serviceName: string): Promise<IJackpotConfiguration[]>;
            /**
                * Retrieve model for an ITG game
                * @param serviceName
                */
            getItgModel(serviceName?: string): Promise<IItgModel>;
            /**
                * retrieve a specific ticket
                * @param ticketId
                * @param demo
                * @returns a ticket or null if no ticket was found
                */
            getItgTicket(ticketId: string | number, demo?: boolean): Promise<IItgTicket>;
            /**
                * Retrieve all non claimed ticket for a game (and current player)
                * @param serviceName
                * @param demo
                */
            getItgTickets(serviceName?: string, demo?: boolean): Promise<IItgTicket[]>;
            /**
                * Place a bet on an ITG game.
                * @param betRequest the bet request object containing the needed bet request informations.
                */
            createITGBet(betRequest: IItgBetRequest): Promise<IItgBetResult>;
            /**
                *
                * @param betRequest
                * @param ticketId
                */
            updateItgBet(betRequest: IItgBetRequest, ticketId: number): Promise<IItgBetResult>;
            /**
                * Claim a ticket on an ITG game.
                * @param betRequest the bet request object containing the needed bet request informations.
                * @param ticketId the id of the ticket to claim.
                */
            claimItgBet(betRequest: IItgBetRequest, ticketId: number): Promise<IItgBetResult>;
            /**
                * Retrieve model for an ITG game
                * @param serviceName
                */
            getEinModel(serviceName?: string, demo?: boolean): Promise<IEinModel>;
            /**
                * retrieve a specific ticket
                * @param ticketId
                * @param demo
                * @returns a ticket or null if no ticket was found
                */
            getEinTicket(ticketId: string, demo?: boolean): Promise<IEinTicket>;
            /**
                * Retrieve all non claimed ticket for a game (and current player)
                * @param serviceName
                * @param demo
                */
            getEinTickets(serviceName?: string, demo?: boolean): Promise<IEinTicket[]>;
            /**
                * Place a bet on an ITG game.
                * @param betRequest the bet request object containing the needed bet request informations.
                */
            createEinBet(betRequest: IEinBetRequest): Promise<IEinBetResult>;
            /**
                *
                * @param betRequest
                * @param ticketId
                */
            updateEinBet(betRequest: IEinBetRequest, ticketId: string): Promise<IEinBetResult>;
            /**
                * Claim a ticket on an ITG game.
                * @param betRequest the bet request object containing the needed bet request informations.
                * @param ticketId the id of the ticket to claim.
                */
            claimEinBet(betRequest: IEinBetRequest, ticketId: string): Promise<IEinBetResult>;
            getMtrModel<TModel>(service: IService, demoMode?: boolean): Promise<IMtrModel<TModel>>;
            getMtrSession<TGameData, TEventResponse, TEventParameters>(service: IService, demoMode?: boolean, sessionId?: string): Promise<IMtrSession<TGameData, TEventParameters, TEventResponse> | IMtrReplaySession<TEventResponse, TEventParameters> | undefined>;
            createMtrBet<TEventResponse, TEventParameters>(betRequest: IMtrBetRequest<TEventParameters>): Promise<IMtrBetResult<TEventResponse>>;
            updateMtrBet<TEventResponse, TEventParameters>(betUpdateRequest: IMtrBetUpdateRequest<TEventParameters>): Promise<IMtrBetResult<TEventResponse>>;
            getPrsTicketInfos(): Promise<IPrsTicketInfos>;
            getGamifContext<T>(service?: IService): Promise<IGamifContext<T>>;
            getMtpModel<T>(service: IService, demo?: boolean): Promise<IMtpRoomParamsResult<T>>;
            getMtpRoom(service: IService, roomId: string, demo?: boolean): Promise<IMtpRoom>;
            getMtpRooms(service: IService, demo?: boolean): Promise<IMtpRoom[]>;
            getMtpSession<T>(service: IService, roomId: string, demo?: boolean): Promise<IMtpSession<T>>;
            enterMtpRoom(enterRoomRequest: IMtpEnterRoomRequest, demo?: boolean): Promise<IMtpRoom>;
            enterMtpRoomAndBet(enterAndBetRequest: IMtpEnterRoomRequest & IMtpBetRequest, demo?: boolean): Promise<IMtpBetResult & IMtpRoom>;
            createMtpBet(betRequest: IMtpBetRequest, demo?: boolean): Promise<IMtpBetResult>;
            updateMtpBet(betRequest: IMtpBetRequest, demo?: boolean): Promise<IMtpBetResult>;
            createNotificationsChannel(settings: IPushSettings): Promise<PushChannel>;
            /**
                * Handle errors on reponse in error
                * @param error the error object that comes from the request
                */
            protected _handleResponseErrors(error: AxiosError): Promise<any>;
            /**
                * Retry 401 errored request.
                * Will try to relog user and get a new replay token if necessary.
                * @param config - original axios request
                */
            protected _retryOn401(config: IRetriableAxiosRequestConfig): Promise<any>;
            mockAddMTR(applicationId: string, serviceName: string, mockValues: number[]): Promise<void>;
            mockResetMTR(applicationId: string, serviceName: string): Promise<void>;
            mockAddITG(applicationId: string, mockValues: any): Promise<void>;
            mockGetITG(applicationId: string): Promise<any>;
            mockResetITG(applicationId: string): Promise<any>;
            mockResetAllITG(applicationId: string): Promise<any>;
    }
    export {};
}

declare module '@falcon/bridge/' {
    import { Bridge } from "@falcon/bridge/falcon-game-bridge";
    export { Bridge, EGameMode } from "@falcon/bridge/falcon-game-bridge";
    export { ChannelProxy } from "@falcon/bridge/channel";
    export { getQueryParameters, uid, injectScript, loadScript, loadJSON, loadFile, } from "@falcon/bridge/tools/tools";
    export { IAmount, IDimension, ICurrencyPurse, ECurrencyPurseType } from "@falcon/bridge/typings/common";
    export { IUserInformation, IGameInformation, IGameConfiguration, ILocaleInformation, ITag, IPurseInformation, IPurseMask, IMaskedPurseInformation, IOpenGameParameters, } from "@falcon/bridge/typings/information";
    export { IBetRequest, IBetResult, IService } from "@falcon/bridge/typings/bet";
    export { IHostInformation } from "@falcon/bridge/typings/host";
    export { IPlatform, IPlayerInformation, IJackpotInformation, IItgBetRequest, IItgBetResult, IItgTicket, IItgPrize, EItgPrizeType, IMtpBetLevel, IMtpRoomParamsResult, IMtpEnterRoomRequest, IMtpRoom, IMtpSession, IMtpBetResult, IMtpBetRequest, EPushTransportMechanism, IPushTopic, IPushSettings, } from "@falcon/bridge/typings/platform";
    export * from "@falcon/bridge/typings/mtr";
    export { IHostChannel } from "@falcon/bridge/typings/channel";
    export { IMessage } from "@falcon/bridge/typings/messages";
    export { INotifier } from "@falcon/bridge/typings/notifier";
    export const game: {
        bridge: typeof Bridge;
    };
    const _default: "test";
    export default _default;
}

declare module '@falcon/bridge/typings/prs' {
    export interface IPrsTicketInfos {
        lotteryCode: string;
        status: "UNPLAYED" | "LOCKED" | "DRAWN" | "ERROR" | "INVALID" | "RETRY";
        token: string;
        info: {
            ticketNSD: string;
            ticketNo: string;
            masterPrizeDescription: string;
            creditCurrency: string;
            creditAmount: number;
            contextElements: string;
        };
    }
}

declare module '@falcon/bridge/tools/token-store' {
    /**
        * ReplayProtectionToken store
        */
    export class TokenStore {
            /**
                * Constructor
                * @param tokenGetter async lambda resolving to a rpToken, will be called to retrieve new token
                */
            constructor(tokenGetter: () => Promise<string>);
            /**
                * Get a token from store
                * It will request a new one if none is present
                */
            get(): Promise<string>;
            /**
                * Add a token to the store
                * @param token
                */
            add(token: string): void;
    }
}

